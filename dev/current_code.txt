/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> tsmis@1.0.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ .env
   ├─ babel.config.js
   ├─ coverage
   │  ├─ clover.xml
   │  ├─ coverage-final.json
   │  ├─ lcov-report
   │  │  ├─ base.css
   │  │  ├─ block-navigation.js
   │  │  ├─ container
   │  │  │  ├─ Container.js.html
   │  │  │  └─ index.html
   │  │  ├─ core
   │  │  │  ├─ bootstrap.js.html
   │  │  │  ├─ container
   │  │  │  │  ├─ Container.js.html
   │  │  │  │  └─ index.html
   │  │  │  ├─ errors
   │  │  │  │  ├─ Error.js.html
   │  │  │  │  ├─ ErrorService.js.html
   │  │  │  │  ├─ index.html
   │  │  │  │  ├─ index.js.html
   │  │  │  │  ├─ integrations
   │  │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  │  ├─ fastify
   │  │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  │  ├─ index.html
   │  │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  │  └─ index.html
   │  │  │  │  ├─ manifest.js.html
   │  │  │  │  └─ types
   │  │  │  │     ├─ AccessError.js.html
   │  │  │  │     ├─ AuthError.js.html
   │  │  │  │     ├─ ConfigError.js.html
   │  │  │  │     ├─ ModuleError.js.html
   │  │  │  │     ├─ NetworkError.js.html
   │  │  │  │     ├─ ServiceError.js.html
   │  │  │  │     ├─ ValidationError.js.html
   │  │  │  │     ├─ index.html
   │  │  │  │     └─ index.js.html
   │  │  │  └─ index.html
   │  │  ├─ errors
   │  │  │  ├─ Error.js.html
   │  │  │  ├─ ErrorSystem.js.html
   │  │  │  ├─ index.html
   │  │  │  ├─ index.js.html
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  ├─ fastify
   │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  ├─ index.html
   │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  └─ index.html
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js.html
   │  │  │     ├─ AuthError.js.html
   │  │  │     ├─ ConfigError.js.html
   │  │  │     ├─ ModuleError.js.html
   │  │  │     ├─ NetworkError.js.html
   │  │  │     ├─ ServiceError.js.html
   │  │  │     ├─ ValidationError.js.html
   │  │  │     ├─ index.html
   │  │  │     └─ index.js.html
   │  │  ├─ favicon.png
   │  │  ├─ index.html
   │  │  ├─ prettify.css
   │  │  ├─ prettify.js
   │  │  ├─ sort-arrow-sprite.png
   │  │  └─ sorter.js
   │  └─ lcov.info
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ claude_prompt.md
   │  │  ├─ dev_manual.md
   │  │  ├─ dev_roadmap.md
   │  │  └─ technical.md
   │  └─ tools
   │     ├─ combined-files.js
   │     ├─ reverse-files.js
   │     └─ setup-project.js
   ├─ jest.config.mjs
   ├─ package-lock.json
   ├─ package.json
   ├─ server.js
   ├─ src
   │  ├─ app.js
   │  ├─ config
   │  ├─ core
   │  │  ├─ container
   │  │  │  └─ Container.js
   │  │  ├─ errors
   │  │  │  ├─ Error.js
   │  │  │  ├─ ErrorSystem.js
   │  │  │  ├─ index.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.js
   │  │  │  │     ├─ handler.js
   │  │  │  │     ├─ index.js
   │  │  │  │     └─ serializer.js
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js
   │  │  │     ├─ AuthError.js
   │  │  │     ├─ ConfigError.js
   │  │  │     ├─ ModuleError.js
   │  │  │     ├─ NetworkError.js
   │  │  │     ├─ ServiceError.js
   │  │  │     ├─ ValidationError.js
   │  │  │     └─ index.js
   │  │  ├─ module
   │  │  ├─ service
   │  │  └─ validation
   │  ├─ modules
   │  └─ services
   │     ├─ cache
   │     ├─ database
   │     ├─ email
   │     ├─ ip
   │     └─ logger
   ├─ tests
   │  ├─ core
   │  │  ├─ container
   │  │  │  └─ Container.test.js
   │  │  └─ errors
   │  │     ├─ Error.test.js
   │  │     ├─ ErrorSystem.test.js
   │  │     ├─ integration.test.js
   │  │     ├─ integrations
   │  │     │  ├─ IFrameworkIntegration.test.js
   │  │     │  └─ fastify
   │  │     │     ├─ FastifyIntegration.test.js
   │  │     │     ├─ handler.test.js
   │  │     │     └─ serializer.test.js
   │  │     └─ types
   │  │        ├─ ErrorTypes.test.js
   │  │        └─ index.test.js
   │  └─ index.test.js
   └─ vite.config.js

```
*/


// src/app.js

import { setupErrorHandler, errorSerializer } from './core/errors/integrations/fastify/index.js';

// In your Fastify setup
const fastify = Fastify({
  logger: {
    level: process.env.LOG_LEVEL || 'info',
    serializers: {
      error: errorSerializer.serializer
    }
  }
});

// Setup error handling
setupErrorHandler(fastify);


// src/core/container/Container.js

// src/core/container/Container.js

import { EventEmitter } from 'events';
import { CoreError, ConfigError, ServiceError } from '../errors/index.js';
// import { ValidationService } from '../validation/ValidationService.js';

export class CoreContainer extends EventEmitter {
  constructor() {
    super();
    this.components = new Map();
    this.instances = new Map();
    this.dependencies = new Map();
    this.manifests = new Map();
    this.initialized = false;
  }

  /**
   * Register a component manifest
   * @param {string} type - Component type
   * @param {object} manifest - Component manifest
   */
  registerManifest(type, manifest) {
    if (this.manifests.has(type)) {
      throw new ConfigError(
        'DUPLICATE_MANIFEST',
        `Manifest already registered for type: ${type}`
      );
    }
    this.manifests.set(type, manifest);
    this.emit('manifest:registered', { type, manifest });
  }

  /**
   * Register a component with the container
   * @param {string} name - Component name
   * @param {Class} Component - Component constructor
   * @param {object} options - Registration options
   */
  register(name, Component, options = {}) {
    if (this.components.has(name)) {
      throw new ConfigError(
        'DUPLICATE_COMPONENT',
        `Component ${name} is already registered`
      );
    }

    // Store component definition
    this.components.set(name, {
      Component,
      options: {
        singleton: true,
        ...options
      }
    });

    // Store dependencies
    this.dependencies.set(name, Component.dependencies || []);

    this.emit('component:registered', { name, Component });
    return this;
  }

  /**
   * Discover components in a directory
   * @param {string} type - Component type
   * @param {string} basePath - Base directory path
   */
  async discover(type, basePath) {
    if (!this.manifests.has(type)) {
      throw new ConfigError(
        'INVALID_TYPE',
        `No manifest registered for type: ${type}`
      );
    }

    try {
      const manifest = this.manifests.get(type);
      const componentPaths = await this.scanDirectory(basePath);
      const discoveredComponents = new Map();

      for (const path of componentPaths) {
        try {
          const component = await this.loadComponent(path, manifest);
          if (component) {
            discoveredComponents.set(component.name, component);
          }
        } catch (error) {
          this.emit('discovery:error', { path, error });
        }
      }

      this.emit('discovery:completed', { type, components: discoveredComponents });
      return discoveredComponents;
    } catch (error) {
      throw new ServiceError(
        'DISCOVERY_FAILED',
        `Failed to discover ${type} components`,
        { originalError: error }
      );
    }
  }

  /**
   * Load a component from a path
   * @private
   */
  async loadComponent(path, manifest) {
    try {
      const config = await this.loadConfig(path);
      if (config.enabled === false) return null;

      await this.validateConfig(config, manifest.configSchema);
      const implementation = await this.loadImplementation(path);

      return {
        name: config.name,
        config,
        implementation
      };
    } catch (error) {
      throw new ConfigError(
        'LOAD_FAILED',
        `Failed to load component from ${path}`,
        { originalError: error }
      );
    }
  }

  /**
   * Get an instance of a component
   * @param {string} name - Component name
   */
  async resolve(name) {
    if (!this.components.has(name)) {
      throw new ServiceError(
        'UNKNOWN_COMPONENT',
        `Component ${name} is not registered`
      );
    }

    const { Component, options } = this.components.get(name);

    // Return existing instance for singletons
    if (options.singleton && this.instances.has(name)) {
      return this.instances.get(name);
    }

    // Resolve dependencies
    const deps = this.dependencies.get(name);
    const resolvedDeps = {};

    for (const dep of deps) {
      resolvedDeps[dep] = await this.resolve(dep);
    }

    // Create instance
    const instance = new Component(resolvedDeps);
    
    if (options.singleton) {
      this.instances.set(name, instance);
    }

    // Initialize if container is already initialized
    if (this.initialized && typeof instance.initialize === 'function') {
      await instance.initialize();
    }

    this.emit('component:resolved', { name, instance });
    return instance;
  }

  /**
   * Initialize all registered components
   */
  async initialize() {
    if (this.initialized) {
      throw new ServiceError(
        'ALREADY_INITIALIZED',
        'Container is already initialized'
      );
    }

    const order = this.resolveDependencyOrder();

    for (const name of order) {
      const instance = await this.resolve(name);
      if (typeof instance.initialize === 'function') {
        await instance.initialize();
      }
    }

    this.initialized = true;
    this.emit('initialized');
  }

  /**
   * Resolve dependency order for initialization
   * @private
   */
  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ConfigError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected: ${name}`
        );
      }

      visiting.add(name);
      
      const deps = this.dependencies.get(name) || [];
      for (const dep of deps) {
        if (!this.components.has(dep)) {
          throw new ConfigError(
            'MISSING_DEPENDENCY',
            `Dependency ${dep} required by ${name} is not registered`
          );
        }
        visit(dep);
      }
      
      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    for (const name of this.components.keys()) {
      visit(name);
    }

    return order;
  }

  /**
   * Shutdown all components
   */
//   async shutdown() {
//     const order = this.resolveDependencyOrder().reverse();

//     for (const name of order) {
//       const instance = this.instances.get(name);
//       if (instance && typeof instance.shutdown === 'function') {
//         await instance.shutdown();
//       }
//     }

//     this.instances.clear();
//     this.initialized = false;
//     this.emit('shutdown');
//   }

async shutdown() {
    // Shutdown in reverse dependency order
    const order = this.resolveDependencyOrder().reverse();
  
    for (const name of order) {
      const instance = this.instances.get(name);
      if (instance && typeof instance.shutdown === 'function') {
        try {
          await instance.shutdown();
        } catch (error) {
          // Log error but continue shutdown process
          this.emit('shutdown:error', { 
            component: name, 
            error 
          });
        }
      }
    }
  
    this.instances.clear();
    this.initialized = false;
    this.emit('shutdown');
  }
}


// src/core/errors/Error.js

/**
 * Universal base error class for both client and server environments
 * @extends Error
 */
export class CoreError extends Error {
  /**
   * Create a new CoreError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(message);
    
    // Basic properties
    this.name = this.constructor.name;
    this.code = code;
    this.details = this.sanitizeDetails(details);
    this.timestamp = new Date().toISOString();

      //Debug line 29
      // console.log('Line 29 debug:', {
      //   hasOptions: options !== undefined,
      //   hasCause: options?.cause !== undefined,
      //   causeValue: options?.cause
      // });

    // Handle error cause
    this.initCause(options?.cause);
    
    // Ensure instanceof works correctly
    Object.setPrototypeOf(this, new.target.prototype);
    
    // Capture stack trace if available
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Format stack for browser environment
    if (this.isClientEnvironment()) {
      this.stack = this.formatStackTrace(this.stack);
    }
  }

  /**
   * Initialize error cause with proper error instance
   * @private
   */
  initCause(cause) {
    const ensureValidName = (error) => {
      // Reset to 'Error' if name is empty or only whitespace
      if (!error.name || !error.name.trim()) {
        error.name = 'Error';
      }
      return error;
    };
  
    if (cause instanceof Error) {
      this.cause = ensureValidName(cause);
    } else if (cause && typeof cause === 'object') {
      const error = new Error(cause.message || JSON.stringify(cause));
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        error.name = cause.name;
      }
      this.cause = error;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause);
    }
  }

  /**
   * Sanitize error details for safe serialization
   * @private
   */
  sanitizeDetails(details) {
    try {
      // Test if details can be safely serialized
      JSON.stringify(details);
      return details;
    } catch (error) {
      // If serialization fails, return safe version
      return { 
        error: 'Details contained non-serializable values',
        safeDetails: String(details)
      };
    }
  }

  /**
   * Format stack trace for better readability
   * @private
   */
  formatStackTrace(stack) {
    if (!stack) return stack;
    
    return stack
      .split('\n')
      .filter(line => line.trim())
      .map(line => line.replace(/^ {4}at /, ''))
      .join('\n');
  }

  /**
   * Check if running in client environment
   * @private
   */
  isClientEnvironment() {
    return typeof window !== 'undefined';
  }

  /**
   * Check if running in development environment
   * @private
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';
    }
    return this.isClientEnvironment() && window.ENV === 'development';
  }

  /**
   * Convert error to JSON format
   */
  toJSON() {
    const json = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp
    };
  
    // Only include stack if it exists AND we're in dev
    if (this.isDevEnvironment() && this.stack) {
      json.stack = this.stack;
    }
  
    // Include cause if present
    if (this.cause) {
      json.cause = {
        message: this.cause.message,
        name: this.cause.name || 'Error'
      };
      
      // Only include cause stack if it exists AND we're in dev
      if (this.isDevEnvironment() && this.cause.stack) {
        json.cause.stack = this.cause.stack;
      }
    }
  
    return json;
  }

  /**
   * Create error instance from JSON data
   * @static
   */
  static fromJSON(data) {
    const options = {};
    
    if (data.cause) {
      if (typeof data.cause === 'string') {
        options.cause = data.cause;
      } else {
        options.cause = {
          message: data.cause.message,
          name: data.cause.name
        };
      }
    }

    return new this(
      data.code,
      data.message,
      data.details || {},
      options
    );
  }
}


// src/core/errors/ErrorSystem.js

// src/core/errors/ErrorSystem.js

import { EventEmitter } from 'events';
import { CoreError } from './Error.js';
import { ErrorTypes } from './types/index.js';
import { FastifyIntegration } from './integrations/fastify/FastifyIntegration.js';

export class ErrorSystem extends EventEmitter {
  static dependencies = ['logger'];

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.logger = deps.logger || console;
    this.integrations = new Map();
    this.handlers = new Map();
    this.errorTypes = new Map(Object.entries(ErrorTypes));
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) {
      throw new Error('Already initialized');
    }

    // Register default handler
    this.registerHandler('*', this.defaultErrorHandler.bind(this));
    
    // Validate error types
    for (const [name, ErrorType] of this.errorTypes) {
      if (!(ErrorType.prototype instanceof CoreError)) {
        throw new CoreError('INVALID_ERROR_TYPE', `Error type ${name} must extend CoreError`);
      }
    }

    this.initialized = true;
    this.emit('initialized');
  }

  registerIntegration(framework, options = {}) {
    if (!framework) {
      throw new CoreError('INVALID_FRAMEWORK', 'Framework is required');
    }

    const integration = new FastifyIntegration();
    integration.initialize(framework, options);
    
    this.integrations.set(framework, integration);
    return integration;
  }

  registerHandler(errorType, handler) {
    if (typeof handler !== 'function') {
      throw new CoreError('INVALID_HANDLER', 'Handler must be a function');
    }
    this.handlers.set(errorType, handler);
  }

  async handleError(error, context = {}) {
    const errorType = error.constructor.name;
    const handler = this.handlers.get(errorType) || this.handlers.get('*');

    try {
      await handler(error, context);
      this.emit('error:handled', { error, context });
    } catch (handlerError) {
      this.logger.error('Error handler failed:', handlerError);
      this.emit('error:handler:failed', { error: handlerError, originalError: error });
      throw handlerError;
    }
  }

  defaultErrorHandler(error, context = {}) {
    this.logger.error('Error:', {
      type: error.constructor.name,
      code: error.code,
      message: error.message,
      details: error.details,
      context
    });
  }

  createError(type, code, message, details = {}, options = {}) {
    const ErrorType = this.errorTypes.get(type) || CoreError;
    return new ErrorType(code, message, details, options);
  }

  async shutdown() {
    if (!this.initialized) return;
    
    this.handlers.clear();
    this.integrations.clear();
    this.errorTypes.clear();
    this.removeAllListeners();
    this.initialized = false;
    this.emit('shutdown');
  }
}

// Factory function for container
export function createErrorSystem(deps) {
  return new ErrorSystem(deps);
}


// src/core/errors/index.js

// src/core/errors/index.js

import { CoreError } from './Error.js';
import { ErrorTypes as TypedErrors, 
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
} from './types/index.js';

// Create complete ErrorTypes including CoreError
export const ErrorTypes = {
    CoreError,
    ...TypedErrors
};

// Export individual error classes
export {
    CoreError,
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

/**
 * Standard error codes
 */
export const ErrorCodes = {
  // Core errors
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },

  // Module related
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    ROUTE: 'ROUTE_ERROR'
  },

  // Service related
  SERVICE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    CONFIGURATION: 'CONFIGURATION_ERROR',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    RUNTIME: 'RUNTIME_ERROR'
  },

  // Configuration related
  CONFIG: {
    VALIDATION: 'VALIDATION_FAILED',
    MISSING: 'MISSING_REQUIRED',
    INVALID: 'INVALID_VALUE'
  },

  // Validation related
  VALIDATION: {
    SCHEMA: 'SCHEMA_VALIDATION_FAILED',
    TYPE: 'INVALID_TYPE',
    REQUIRED: 'REQUIRED_FIELD_MISSING',
    FAILED: 'VALIDATION_FAILED'  // Added for validation errors
  },

  // Network related
  NETWORK: {
    REQUEST: 'REQUEST_FAILED',
    RESPONSE: 'RESPONSE_ERROR',
    TIMEOUT: 'REQUEST_TIMEOUT',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND'  // Added for 404 errors
  },

  // Authentication related
  AUTH: {
    UNAUTHORIZED: 'UNAUTHORIZED',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    INVALID_TOKEN: 'INVALID_TOKEN'
  },

  // Authorization related
  ACCESS: {
    FORBIDDEN: 'FORBIDDEN',
    INSUFFICIENT_RIGHTS: 'INSUFFICIENT_RIGHTS',
    RESOURCE_ACCESS_DENIED: 'RESOURCE_ACCESS_DENIED'
  }
};

export function createErrorFromResponse(response, defaultMessage = 'Unknown error occurred') {
  const errorData = response.data || response;
  
  // Map error names to constructors from ErrorTypes
  const ErrorConstructor = ErrorTypes[errorData.name] || CoreError;

  return new ErrorConstructor(
      errorData.code || ErrorCodes.CORE.UNKNOWN,
      errorData.message || defaultMessage,
      errorData.details || {},
      { cause: response }
  );
}

export default ErrorTypes;


// src/core/errors/integrations/IFrameworkIntegration.js

// src/core/errors/integrations/IFrameworkIntegration.js

/**
 * Interface for framework error integration
 * @interface
 */
export class IFrameworkIntegration {
  /**
   * Initialize error handling for framework
   * @param {any} framework - Framework instance
   * @param {Object} options - Integration options
   */
  initialize(framework, options = {}) {
    throw new Error('initialize() must be implemented');
  }

  /**
   * Serialize error for framework response
   * @param {Error} error - Error to serialize
   * @returns {Object} Serialized error
   */
  serializeError(error) {
    throw new Error('serializeError() must be implemented');
  }

  /**
   * Map framework error to core error
   * @param {Error} frameworkError - Framework-specific error
   * @returns {CoreError} Mapped core error
   */
  mapError(frameworkError) {
    throw new Error('mapError() must be implemented');
  }
}


// src/core/errors/integrations/fastify/FastifyIntegration.js

// src/core/errors/integrations/fastify/FastifyIntegration.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

export class FastifyIntegration extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  async initialize(fastify, options = {}) {
    if (this.initialized) {
      return;
    }

    // Add error context to request
    fastify.addHook('onRequest', async (request) => {
      if (!request) {
        return;
      }
      
      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    // Set error handler
    fastify.setErrorHandler(async (error, request, reply) => {
      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
  }

  mapError(error) {
    // Already our custom error
    if (error instanceof CoreError) {
      return error;
    }

    // Fastify validation errors
    // TODO: Need a network error
    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    // Route not found
    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    // Generic error
    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}


// src/core/errors/integrations/fastify/handler.js

// src/core/errors/integrations/fastify/handler.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

class FastifyErrorHandler extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  initialize(fastify, options = {}) {
    if (this.initialized) {
      return this;
    }

    if (!fastify || typeof fastify.addHook !== 'function') {
      throw new Error('Invalid fastify instance');
    }

    fastify.addHook('onRequest', async (request) => {
      if (!request) return;

      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    fastify.setErrorHandler(async (error, request, reply) => {
      if (!reply || typeof reply.status !== 'function') {
        throw new Error('Invalid reply object');
      }

      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
    return this;
  }

  mapError(error) {
    if (error instanceof CoreError) {
      return error;
    }

    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}

// Create singleton instance
const fastifyErrorHandler = new FastifyErrorHandler();

export function setupErrorHandler(fastify, options = {}) {
  return fastifyErrorHandler.initialize(fastify, options);
}

export { fastifyErrorHandler, FastifyErrorHandler };


// src/core/errors/integrations/fastify/index.js

export { setupErrorHandler } from './handler.js';
export { errorSerializer } from './serializer.js';


// src/core/errors/integrations/fastify/serializer.js

import { fastifyErrorHandler } from './handler.js';

export const errorSerializer = {
  serializer: (error) => fastifyErrorHandler.serializeError(error)
};


// src/core/errors/types/AccessError.js

import { CoreError } from '../Error.js';

/**
 * Authorization and access control related errors
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Create a new AccessError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options);
    this.statusCode = 403;
  }
}


// src/core/errors/types/AuthError.js

import { CoreError } from '../Error.js';

/**
 * Authentication related errors
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Create a new AuthError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options);
    this.statusCode = 401;
  }
}


// src/core/errors/types/ConfigError.js

import { CoreError } from '../Error.js';

/**
 * Configuration related errors
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Create a new ConfigError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/ModuleError.js

import { CoreError } from '../Error.js';

/**
 * Module system related errors
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Create a new ModuleError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/NetworkError.js

import { CoreError } from '../Error.js';

/**
 * Network related errors
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Create a new NetworkError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options);
    // Use provided status code or default to 503
    this.statusCode = details.statusCode || 503;
  }
}


// src/core/errors/types/ServiceError.js

import { CoreError } from '../Error.js';

/**
 * Service related errors
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Create a new ServiceError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options);
    this.statusCode = 503;
  }
}


// src/core/errors/types/ValidationError.js

import { CoreError } from '../Error.js';

/**
 * Validation related errors
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Create a new ValidationError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details with validation errors
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options);
    this.statusCode = 400;
    this.validationErrors = this.validationErrors = Array.isArray(details.validationErrors) ? details.validationErrors : [];
  }

  /**
   * Convert to JSON format with validation errors
   */
  toJSON() {
    const json = super.toJSON();
    json.validationErrors = this.validationErrors;
    return json;
  }

  /**
   * Create from JSON with validation errors
   * @param {Object} data - JSON data
   */
  static fromJSON(data) {
    const error = super.fromJSON(data);
    error.validationErrors = Array.isArray(data.validationErrors) ? data.validationErrors : [];
    return error;
  }
}


// src/core/errors/types/index.js

// src/core/errors/types/index.js

import { AccessError } from './AccessError.js';
import { AuthError } from './AuthError.js';
import { ConfigError } from './ConfigError.js';
import { ModuleError } from './ModuleError.js';
import { NetworkError } from './NetworkError.js';
import { ServiceError } from './ServiceError.js';
import { ValidationError } from './ValidationError.js';

// Export individual error types
export {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Create the ErrorTypes namespace
const ErrorTypes = {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Export ErrorTypes as both named and default export
export { ErrorTypes };
export default ErrorTypes;


// tests/core/container/Container.test.js

// tests/core/container/Container.test.js

import { CoreContainer } from "../../../src/core/container/Container.js";
import { ConfigError, ServiceError } from "../../../src/core/errors/index.js";

describe("Container", () => {
  let container;

  function createMockFn() {
    const fn = (...args) => {
      fn.mock.calls.push(args);
      return fn.mockReturnValue;
    };
    fn.mock = { calls: [] };
    fn.mockReturnValue = fn;
    fn.mockClear = () => {
      fn.mock.calls = [];
    };
    return fn;
  }

  beforeEach(() => {
    container = new CoreContainer();
  });

  describe("Component Registration", () => {
    test("should register component successfully", () => {
      class TestComponent {}
      container.register("test", TestComponent);
      expect(container.components.has("test")).toBe(true);
    });

    test("should throw on duplicate registration", () => {
      class TestComponent {}
      container.register("test", TestComponent);
      expect(() => container.register("test", TestComponent)).toThrow(
        ConfigError
      );
    });

    test("should store component dependencies", () => {
      class TestComponent {
        static dependencies = ["dep1", "dep2"];
      }
      container.register("test", TestComponent);
      expect(container.dependencies.get("test")).toEqual(["dep1", "dep2"]);
    });
  });

  describe("Manifest Management", () => {
    test("should register manifest successfully", () => {
      const manifest = { configSchema: {} };
      container.registerManifest("test", manifest);
      expect(container.manifests.has("test")).toBe(true);
    });

    test("should throw on duplicate manifest", () => {
      const manifest = { configSchema: {} };
      container.registerManifest("test", manifest);
      expect(() => container.registerManifest("test", manifest)).toThrow(
        ConfigError
      );
    });
  });

  describe("Component Resolution", () => {
    test("should resolve component without dependencies", async () => {
      class TestComponent {}
      container.register("test", TestComponent);
      const instance = await container.resolve("test");
      expect(instance).toBeInstanceOf(TestComponent);
    });

    test("should resolve dependencies", async () => {
      class Dependency {}
      class TestComponent {
        static dependencies = ["dep"];
        constructor(deps) {
          this.deps = deps;
        }
      }

      container.register("dep", Dependency);
      container.register("test", TestComponent);

      const instance = await container.resolve("test");
      expect(instance.deps.dep).toBeInstanceOf(Dependency);
    });

    test("should maintain singleton instances", async () => {
      class TestComponent {}
      container.register("test", TestComponent);

      const instance1 = await container.resolve("test");
      const instance2 = await container.resolve("test");
      expect(instance1).toBe(instance2);
    });

    test("should throw on unknown component", async () => {
      await expect(container.resolve("unknown")).rejects.toThrow(ServiceError);
    });
  });

  describe("Dependency Resolution", () => {
    test("should detect circular dependencies", () => {
      class A {
        static dependencies = ["b"];
      }
      class B {
        static dependencies = ["a"];
      }

      container.register("a", A);
      container.register("b", B);

      expect(() => container.resolveDependencyOrder()).toThrow(ConfigError);
    });

    test("should resolve dependencies in correct order", () => {
      class A {
        static dependencies = ["b"];
      }
      class B {
        static dependencies = ["c"];
      }
      class C {}

      container.register("a", A);
      container.register("b", B);
      container.register("c", C);

      const order = container.resolveDependencyOrder();
      expect(order).toEqual(["c", "b", "a"]);
    });
  });

  describe("Lifecycle Management", () => {
    test("should initialize components in dependency order", async () => {
      const initialized = [];

      class A {
        static dependencies = ["b"];
        async initialize() {
          initialized.push("a");
        }
      }
      class B {
        async initialize() {
          initialized.push("b");
        }
      }

      container.register("a", A);
      container.register("b", B);
      await container.initialize();

      expect(initialized).toEqual(["b", "a"]);
    });

    test("should throw on double initialization", async () => {
      await container.initialize();
      await expect(container.initialize()).rejects.toThrow(ServiceError);
    });

    test("should shutdown components in reverse order", async () => {
      const shutdown = [];

      class A {
        static dependencies = ["b"];
        async shutdown() {
          shutdown.push("a");
        }
      }
      class B {
        async shutdown() {
          shutdown.push("b");
        }
      }

      container.register("a", A);
      container.register("b", B);
      await container.initialize();
      await container.shutdown();

      expect(shutdown).toEqual(["a", "b"]);
    });
  });

  describe("Event Emission", () => {
    test("should emit events on component registration", (done) => {
      container.once("component:registered", ({ name }) => {
        expect(name).toBe("test");
        done();
      });

      class TestComponent {}
      container.register("test", TestComponent);
    });

    test("should emit events on component resolution", async () => {
      const mockListener = createMockFn();
      container.on("component:resolved", mockListener);

      class TestComponent {}
      container.register("test", TestComponent);
      await container.resolve("test");

      expect(mockListener.mock.calls.length).toBe(1);
    });

    test("should emit initialization events", async () => {
      const mockListener = createMockFn();
      container.on("initialized", mockListener);

      await container.initialize();
      expect(mockListener.mock.calls.length).toBe(1);
    });

    test("should emit shutdown events", async () => {
      const mockListener = createMockFn();
      container.on("shutdown", mockListener);

      await container.initialize();
      await container.shutdown();
      expect(mockListener.mock.calls.length).toBe(1);
    });
  });
  ////////////
  // Add these test cases in the Container.test.js

  describe("Component Discovery", () => {
    test("should throw error when discovering unknown type", async () => {
      await expect(container.discover("unknown", "/some/path")).rejects.toThrow(
        ConfigError
      );
    });

    test("should handle discovery errors", async () => {
      const manifest = { configSchema: {} };
      container.registerManifest("test", manifest);

      // Mock scanDirectory to simulate error
      container.scanDirectory = async () => {
        throw new Error("Scan failed");
      };

      await expect(container.discover("test", "/some/path")).rejects.toThrow(
        ServiceError
      );
    });

    test("should handle component loading errors", async () => {
      const manifest = { configSchema: {} };
      container.registerManifest("test", manifest);

      // Mock methods to test error paths
      container.scanDirectory = async () => ["/path/component"];
      container.loadComponent = async () => {
        throw new Error("Load failed");
      };

      const mockListener = createMockFn();
      container.on("discovery:error", mockListener);

      await container.discover("test", "/some/path");
      expect(mockListener.mock.calls.length).toBe(1);
    });

    test("should skip disabled components", async () => {
      const manifest = { configSchema: {} };
      container.registerManifest("test", manifest);

      // Mock methods to test disabled component
      container.scanDirectory = async () => ["/path/component"];
      container.loadConfig = async () => ({ enabled: false });

      const discovered = await container.discover("test", "/some/path");
      expect(discovered.size).toBe(0);
    });
  });

  describe("Component Loading", () => {
    test("should handle validation errors during loading", async () => {
      const manifest = {
        configSchema: {
          required: ["name"],
        },
      };

      container.registerManifest("test", manifest);
      container.loadConfig = async () => ({ enabled: true });

      await expect(
        container.loadComponent("/some/path", manifest)
      ).rejects.toThrow(ConfigError);
    });

    test("should emit discovery completed event", async () => {
      const manifest = { configSchema: {} };
      container.registerManifest("test", manifest);

      // Mock successful component loading
      container.scanDirectory = async () => ["/path/component"];
      container.loadComponent = async () => ({
        name: "test",
        config: { enabled: true },
        implementation: class Test {},
      });

      const mockListener = createMockFn();
      container.on("discovery:completed", mockListener);

      await container.discover("test", "/some/path");
      expect(mockListener.mock.calls.length).toBe(1);
    });

    test("should handle component implementation loading error", async () => {
      const manifest = {
        configSchema: {},
      };

      // Mock methods to simulate implementation loading error
      container.loadConfig = async () => ({ enabled: true, name: "test" });
      container.loadImplementation = async () => {
        throw new Error("Implementation load failed");
      };

      await expect(container.loadComponent("/path", manifest)).rejects.toThrow(
        ConfigError
      );
    });

    test("should successfully load complete component", async () => {
      const manifest = {
        configSchema: {}, // Schema for validation
      };

      // Mock all required methods to test successful path
      container.loadConfig = async () => ({
        enabled: true,
        name: "test-component",
      });

      container.validateConfig = async () => true; // Validation passes

      container.loadImplementation = async () => {
        return class TestComponent {};
      };

      const component = await container.loadComponent("/test/path", manifest);

      // Verify full component object is returned
      expect(component).toEqual({
        name: "test-component",
        config: { enabled: true, name: "test-component" },
        implementation: expect.any(Function),
      });
    });
  });

  describe("Resolution Tests", () => {
    test("should initialize newly resolved component when container is initialized", async () => {
      const initialized = [];

      class TestComponent {
        async initialize() {
          initialized.push("test");
        }
      }

      container.register("test", TestComponent);
      await container.initialize();

      // Resolve after initialization
      await container.resolve("test");
      expect(initialized).toContain("test");
    });
    test("should handle non-initialized component after container initialization", async () => {
      // This should cover line 165
      container.initialized = true;

      class TestComponent {
        async initialize() {}
      }
      container.register("test", TestComponent);

      const instance = await container.resolve("test");
      expect(instance).toBeInstanceOf(TestComponent);
    });
  });

  describe("Shutdown Tests", () => {
    test("should handle errors during component shutdown", async () => {
      class A {
        async shutdown() {
          throw new Error("Shutdown failed");
        }
      }
      class B {
        async shutdown() {}
      }

      container.register("a", A);
      container.register("b", B);
      await container.initialize();

      // Should complete shutdown despite errors
      await container.shutdown();
      expect(container.initialized).toBe(false);
      expect(container.instances.size).toBe(0);
    });
    test("should skip shutdown for non-initialized component", async () => {
      class TestComponent {
        async shutdown() {}
      }
      container.register("test", TestComponent);

      // Don't initialize, just shutdown
      await container.shutdown();
      expect(container.initialized).toBe(false);
    });
    test("should successfully execute component shutdown", async () => {
      const executionOrder = [];

      class A {
        static dependencies = ["b"]; // A depends on B
        async shutdown() {
          executionOrder.push("a-shutdown");
        }
      }
      class B {
        async shutdown() {
          executionOrder.push("b-shutdown");
        }
      }

      // Register both components
      container.register("a", A);
      container.register("b", B);

      // Initialize and resolve to create instances
      await container.initialize();
      await container.resolve("a");
      await container.resolve("b");

      // Listen for shutdown events
      const mockListener = createMockFn();
      container.on("shutdown", mockListener);

      // Execute shutdown
      await container.shutdown();

      // Verify execution - reversed order means A first, then B
      expect(executionOrder).toEqual(["a-shutdown", "b-shutdown"]);
      expect(container.initialized).toBe(false);
      expect(container.instances.size).toBe(0);
      expect(mockListener.mock.calls.length).toBe(1);
    });
    test("should execute successful component shutdown", async () => {
      let shutdownCalled = false;

      class TestComponent {
        async shutdown() {
          shutdownCalled = true;
          return Promise.resolve(); // Explicitly return resolved promise
        }
      }

      container.register("test", TestComponent);
      await container.initialize();
      const instance = await container.resolve("test"); // Important: Get the instance

      await container.shutdown();

      expect(shutdownCalled).toBe(true);
      expect(container.initialized).toBe(false);
      expect(container.instances.size).toBe(0);
    });
    test("should execute async shutdown properly", async () => {
      const shutdownPromise = new Promise((resolve) => {
        // Track actual promise resolution
        setTimeout(() => resolve(), 10);
      });

      class TestComponent {
        async shutdown() {
          await shutdownPromise; // Forces the await to actually happen
          return true;
        }
      }

      // Setup and get instance
      container.register("test", TestComponent);
      await container.initialize();
      await container.resolve("test"); // Important: Get instance

      // Ensure shutdown error handler is set up
      const errorListener = createMockFn();
      container.on("shutdown:error", errorListener);

      // Execute shutdown
      await container.shutdown();

      // Verify
      expect(errorListener.mock.calls.length).toBe(0); // No errors
      expect(container.initialized).toBe(false);
      expect(container.instances.size).toBe(0);
    });
    test("should execute async shutdown without error", async () => {
      let shutdownExecuted = false;
      let awaitCompleted = false;

      class TestComponent {
        constructor() {
          this.shutdown = async () => {
            shutdownExecuted = true;
            await new Promise((resolve) => setTimeout(resolve, 0));
            awaitCompleted = true;
          };
        }
      }

      // Register and get instance
      container.register("test", TestComponent);
      await container.initialize();
      const instance = await container.resolve("test");

      // Track shutdown error events
      const errorHandler = createMockFn();
      container.on("shutdown:error", errorHandler);

      // Execute shutdown
      await container.shutdown();

      // Verify every step
      expect(shutdownExecuted).toBe(true);
      expect(awaitCompleted).toBe(true);
      expect(errorHandler.mock.calls.length).toBe(0);
      expect(container.initialized).toBe(false);
      expect(container.instances.size).toBe(0);
    });
    test("should execute async shutdown properly", async () => {
      const shutdownPromise = new Promise((resolve) => {
        // Track actual promise resolution
        setTimeout(() => resolve(), 10);
      });

      class TestComponent {
        async shutdown() {
          await shutdownPromise; // Forces the await to actually happen
          return true;
        }
      }

      // Setup and get instance
      container.register("test", TestComponent);
      await container.initialize();
      await container.resolve("test"); // Important: Get instance

      // Ensure shutdown error handler is set up
      const errorListener = createMockFn();
      container.on("shutdown:error", errorListener);

      // Execute shutdown
      await container.shutdown();

      // Verify
      expect(errorListener.mock.calls.length).toBe(0); // No errors
      expect(container.initialized).toBe(false);
      expect(container.instances.size).toBe(0);
    });
  });
  describe("Initialization Edge Cases", () => {
    test("should prevent double initialization by throwing ServiceError", async () => {
      // Create a container with a component that can be initialized
      class TestComponent {
        async initialize() {}
      }

      container.register("test", TestComponent);

      // First initialization should succeed
      await container.initialize();

      // Second initialization attempt should throw ServiceError
      await expect(container.initialize()).rejects.toThrow(ServiceError);
      await expect(container.initialize()).rejects.toThrow(
        "Container is already initialized"
      );
    });
    test("should prevent subsequent initialization attempts after first successful init", async () => {
      // Ensure previous tests don't interfere
      const freshContainer = new CoreContainer();

      class TestComponent {
        async initialize() {}
      }

      freshContainer.register("test", TestComponent);

      // First initialization
      await freshContainer.initialize();

      // Verify container is marked as initialized
      expect(freshContainer.initialized).toBe(true);

      // Subsequent initialization attempts should throw
      await expect(freshContainer.initialize()).rejects.toThrow(ServiceError);
      await expect(freshContainer.initialize()).rejects.toThrow(
        "Container is already initialized"
      );
    });
    test("should throw ConfigError for missing dependency", () => {
      const container = new CoreContainer();

      class ComponentA {
        static dependencies = ["missingComponent"];
      }

      class ComponentB {
        // No dependencies
      }

      // Register ComponentB, but not the dependency of ComponentA
      container.register("componentB", ComponentB);

      // Attempt to register ComponentA
      container.register("componentA", ComponentA);

      // Expect an error when resolving dependency order
      expect(() => container.resolveDependencyOrder()).toThrow(ConfigError);

      try {
        container.resolveDependencyOrder();
      } catch (error) {
        // Specific assertions about the error
        expect(error).toBeInstanceOf(ConfigError);
        expect(error.code).toBe("CONFIG_MISSING_DEPENDENCY");
        expect(error.message).toContain(
          "Dependency missingComponent required by componentA is not registered"
        );
      }
    });

    test("should handle multiple missing dependencies", () => {
      const container = new CoreContainer();

      class ComponentA {
        static dependencies = ["missingComponentX", "missingComponentY"];
      }

      // Register ComponentA with unregistered dependencies
      container.register("componentA", ComponentA);

      // Expect an error when resolving dependency order
      expect(() => container.resolveDependencyOrder()).toThrow(ConfigError);

      try {
        container.resolveDependencyOrder();
      } catch (error) {
        // The error should be for the first missing dependency
        expect(error).toBeInstanceOf(ConfigError);
        expect(error.code).toBe("CONFIG_MISSING_DEPENDENCY");
        expect(error.message).toContain(
          "Dependency missingComponentX required by componentA is not registered"
        );
      }
    });
  });
  describe("Container Initialization", () => {
    let container;

    beforeEach(() => {
      container = new CoreContainer();
    });

    describe("Initialization Prevention", () => {
      test("should prevent re-initialization with direct state manipulation", async () => {
        class TestComponent {
          static initializationAttempts = 0;
          async initialize() {
            TestComponent.initializationAttempts++;
          }
        }

        container.register("test", TestComponent);

        // First initialization
        await container.initialize();

        // Reset initialization tracking
        TestComponent.initializationAttempts = 0;

        // Manually set initialized to true to simulate prevented initialization
        Object.defineProperty(container, "initialized", {
          value: true,
          writable: true,
        });

        // Attempt re-initialization
        let thrownError = null;
        try {
          await container.initialize();
        } catch (error) {
          thrownError = error;
        }

        // Assertions
        expect(thrownError).not.toBeNull();
        expect(thrownError).toBeInstanceOf(ServiceError);
        expect(thrownError.code).toBe("SERVICE_ALREADY_INITIALIZED");
        expect(thrownError.message).toBe("Container is already initialized");

        // Verify no additional initialization occurred
        expect(TestComponent.initializationAttempts).toBe(0);
      });

      test("should block repeated initialization attempts", async () => {
        class TestComponent {
          static initCount = 0;
          async initialize() {
            TestComponent.initCount++;
          }
        }

        container.register("test", TestComponent);

        // First initialization
        await container.initialize();

        // Verify initial state
        expect(container.initialized).toBe(true);
        const initialInitCount = TestComponent.initCount;

        // Multiple re-initialization attempts
        for (let i = 0; i < 5; i++) {
          try {
            await container.initialize();
          } catch (error) {
            // Verify each attempt throws ServiceError
            expect(error).toBeInstanceOf(ServiceError);
            expect(error.code).toBe("SERVICE_ALREADY_INITIALIZED");
          }
        }

        // Verify no additional initializations occurred
        expect(TestComponent.initCount).toBe(initialInitCount);
      });

      test("should maintain initialization state after prevention", async () => {
        class TestComponent {
          async initialize() {}
        }

        container.register("test", TestComponent);

        // First initialization
        await container.initialize();

        // Store initial state
        const initialState = container.initialized;

        // Attempt re-initialization multiple times
        for (let i = 0; i < 3; i++) {
          try {
            await container.initialize();
          } catch (error) {
            // Verify error type
            expect(error).toBeInstanceOf(ServiceError);
          }

          // Ensure state remains unchanged
          expect(container.initialized).toBe(initialState);
        }
      });

      test("should handle initialization guard with multiple components", async () => {
        const initializationLog = [];

        class ComponentA {
          async initialize() {
            initializationLog.push("A");
          }
        }

        class ComponentB {
          async initialize() {
            initializationLog.push("B");
          }
        }

        container.register("componentA", ComponentA);
        container.register("componentB", ComponentB);

        // First initialization
        await container.initialize();

        // Clear initialization log
        initializationLog.length = 0;

        // Manually set initialized to true
        Object.defineProperty(container, "initialized", {
          value: true,
          writable: true,
        });

        // Attempt re-initialization
        try {
          await container.initialize();
        } catch (error) {
          // Verify error type
          expect(error).toBeInstanceOf(ServiceError);
        }

        // Verify no additional initialization occurred
        expect(initializationLog.length).toBe(0);
      });
      // End of existing tests
    });
    describe("Initialization Guard Coverage", () => {
      test("should definitively cover line 219 condition", async () => {
        // Create a subclass to expose internal state for testing
        class TestableContainer extends CoreContainer {
          getInitializedState() {
            return this.initialized;
          }
        }

        const testContainer = new TestableContainer();

        class TestComponent {
          static initializationAttempts = 0;
          async initialize() {
            TestComponent.initializationAttempts++;
          }
        }

        testContainer.register("test", TestComponent);

        // First initialization
        await testContainer.initialize();

        // Verify initial state is true
        expect(testContainer.getInitializedState()).toBe(true);

        // Reset initialization attempts
        TestComponent.initializationAttempts = 0;

        // Attempt re-initialization multiple times
        for (let i = 0; i < 3; i++) {
          let errorThrown = false;
          try {
            // Deliberately call initialize again
            await testContainer.initialize();
          } catch (error) {
            errorThrown = true;

            // Specific assertions about the error
            expect(error).toBeInstanceOf(ServiceError);
            expect(error.code).toBe("SERVICE_ALREADY_INITIALIZED");
            expect(error.message).toBe("Container is already initialized");
          }

          // Ensure error was thrown
          expect(errorThrown).toBe(true);
        }

        // Verify no additional initialization occurred
        expect(TestComponent.initializationAttempts).toBe(0);
      });

      test("should trigger initialization guard explicitly", async () => {
        const testContainer = new CoreContainer();

        class TestComponent {
          static initLog = [];
          async initialize() {
            TestComponent.initLog.push("initialized");
          }
        }

        testContainer.register("test", TestComponent);

        // First initialization
        await testContainer.initialize();

        // Spy on the initialized state
        const originalInitialize = testContainer.initialize.bind(testContainer);

        // Capture the initialization guard condition
        testContainer.initialize = async function () {
          // The critical line we want to cover
          if (this.initialized) {
            throw new ServiceError(
              "ALREADY_INITIALIZED",
              "Container is already initialized"
            );
          }
          return originalInitialize();
        };

        // Attempt re-initialization
        await expect(testContainer.initialize()).rejects.toThrow(ServiceError);
      });

      test("should verify initialization guard state", async () => {
        const testContainer = new CoreContainer();

        class TestComponent {
          async initialize() {}
        }

        testContainer.register("test", TestComponent);

        // First initialization
        await testContainer.initialize();

        // Directly verify the internal state
        expect(testContainer.initialized).toBe(true);

        // Attempt re-initialization
        await expect(testContainer.initialize()).rejects.toThrow(ServiceError);
      });
    });
  });
  describe("Detailed Component Resolution and Dependency Order Tests", () => {
    describe("Singleton Instance Caching", () => {
      test("should return cached singleton instance", async () => {
        class TestComponent {
          constructor() {
            this.id = Math.random(); // Unique identifier
          }
        }

        const container = new CoreContainer();
        container.register("test", TestComponent, { singleton: true });

        // First resolution
        const firstInstance = await container.resolve("test");

        // Second resolution should return the same instance
        const secondInstance = await container.resolve("test");

        // Verify same instance is returned
        expect(firstInstance).toBe(secondInstance);
      });

      test("should create new instance for non-singleton components", async () => {
        class TestComponent {
          constructor() {
            this.id = Math.random(); // Unique identifier
          }
        }

        const container = new CoreContainer();
        container.register("test", TestComponent, { singleton: false });

        // First resolution
        const firstInstance = await container.resolve("test");

        // Second resolution should return a different instance
        const secondInstance = await container.resolve("test");

        // Verify different instances are returned
        expect(firstInstance).not.toBe(secondInstance);
      });
    });

    describe("Dependency Order Tracking", () => {
      test("should properly manage visiting set during dependency resolution", () => {
        const container = new CoreContainer();

        class ComponentA {
          static dependencies = ["componentB"];
        }
        class ComponentB {
          static dependencies = ["componentC"];
        }
        class ComponentC {
          // No dependencies
        }

        container.register("componentA", ComponentA);
        container.register("componentB", ComponentB);
        container.register("componentC", ComponentC);

        // Resolve dependency order
        const order = container.resolveDependencyOrder();

        // Verify correct order of resolution
        expect(order).toEqual(["componentC", "componentB", "componentA"]);
      });

      test("should handle complex dependency graphs", () => {
        const container = new CoreContainer();

        class ComponentA {
          static dependencies = ["componentB", "componentC"];
        }
        class ComponentB {
          static dependencies = ["componentD"];
        }
        class ComponentC {
          static dependencies = ["componentD"];
        }
        class ComponentD {
          // No dependencies
        }

        container.register("componentA", ComponentA);
        container.register("componentB", ComponentB);
        container.register("componentC", ComponentC);
        container.register("componentD", ComponentD);

        // Resolve dependency order
        const order = container.resolveDependencyOrder();

        // Verify correct order of resolution
        expect(order).toEqual([
          "componentD",
          "componentB",
          "componentC",
          "componentA",
        ]);
      });
    });

    describe("Dependency Order Edge Cases", () => {
      test("should handle components with no dependencies", () => {
        const container = new CoreContainer();

        class ComponentWithNoDependencies {}
        class ComponentWithEmptyDependencies {
          static dependencies = [];
        }

        // Register components with different dependency configurations
        container.register("noDeps", ComponentWithNoDependencies);
        container.register("emptyDeps", ComponentWithEmptyDependencies);

        // Resolve dependency order
        const order = container.resolveDependencyOrder();

        // Verify components are included in the order
        expect(order).toContain("noDeps");
        expect(order).toContain("emptyDeps");
      });

      test("should correctly handle fallback to empty array for dependencies", () => {
        const container = new CoreContainer();

        class TestComponent {
          // No static dependencies defined
        }

        container.register("test", TestComponent);

        // Create a custom container to track dependency retrieval
        class TrackingContainer extends CoreContainer {
          constructor() {
            super();
            this.dependencyRetrievals = 0;
          }

          resolveDependencyOrder() {
            const originalGet = this.dependencies.get.bind(this.dependencies);

            // Override get method to track retrievals
            this.dependencies.get = (name) => {
              this.dependencyRetrievals++;
              return originalGet(name) || [];
            };

            return super.resolveDependencyOrder();
          }
        }

        const trackingContainer = new TrackingContainer();
        trackingContainer.register("test", TestComponent);

        // Resolve dependency order
        const order = trackingContainer.resolveDependencyOrder();

        // Verify components are processed correctly
        expect(order).toContain("test");
        expect(trackingContainer.dependencyRetrievals).toBeGreaterThan(0);
      });

      test("should process components with mix of dependencies", () => {
        const container = new CoreContainer();

        class ComponentA {
          static dependencies = ["componentB"];
        }
        class ComponentB {
          static dependencies = [];
        }
        class ComponentC {
          // No dependencies defined
        }

        container.register("componentA", ComponentA);
        container.register("componentB", ComponentB);
        container.register("componentC", ComponentC);

        // Resolve dependency order
        const order = container.resolveDependencyOrder();

        // Verify correct order and inclusion of all components
        expect(order).toContain("componentA");
        expect(order).toContain("componentB");
        expect(order).toContain("componentC");
      });

      test("should handle multiple components with varying dependency configurations", () => {
        const container = new CoreContainer();

        class ComponentWithSingleDependency {
          static dependencies = ["simpleComponent"];
        }
        class SimpleComponent {}
        class ComponentWithMultipleDependencies {
          static dependencies = ["componentA", "componentB"];
        }
        class ComponentA {}
        class ComponentB {}

        container.register("complexComponent", ComponentWithSingleDependency);
        container.register("simpleComponent", SimpleComponent);
        container.register(
          "multiDepsComponent",
          ComponentWithMultipleDependencies
        );
        container.register("componentA", ComponentA);
        container.register("componentB", ComponentB);

        // Resolve dependency order
        const order = container.resolveDependencyOrder();

        // Verify all components are processed
        expect(order).toContain("simpleComponent");
        expect(order).toContain("componentA");
        expect(order).toContain("componentB");
        expect(order).toContain("complexComponent");
        expect(order).toContain("multiDepsComponent");
      });
    });
    describe('Dependency Retrieval Branch Coverage', () => {
        test('should handle component with absolutely no dependency information', () => {
          class ComponentWithNoDepInfo {}
      
          const container = new CoreContainer();
      
          // Manually manipulate dependencies to ensure no entry
          container.dependencies.delete('noDepComponent');
      
          // Register component
          container.register('noDepComponent', ComponentWithNoDepInfo);
      
          // Override dependencies.get to return undefined explicitly
          const originalGet = container.dependencies.get.bind(container.dependencies);
          container.dependencies.get = (name) => {
            if (name === 'noDepComponent') return undefined;
            return originalGet(name);
          };
      
          // Resolve dependency order
          const order = container.resolveDependencyOrder();
      
          // Verify component is processed
          expect(order).toContain('noDepComponent');
      
          // Restore original method
          container.dependencies.get = originalGet;
        });
      
        test('should explicitly test null/undefined dependency fallback', () => {
          class ComponentWithNullDeps {
            static dependencies = null;
          }
      
          const container = new CoreContainer();
          container.register('nullDepComponent', ComponentWithNullDeps);
      
          // Directly verify dependencies
          const deps = container.dependencies.get('nullDepComponent');
          expect(deps).toEqual([]);
      
          // Resolve dependency order
          const order = container.resolveDependencyOrder();
          expect(order).toContain('nullDepComponent');
        });
      });
  });
});


// tests/core/errors/Error.test.js

import { CoreError } from '../../../src/core/errors/Error.js';

describe('CoreError', () => {
  const originalEnv = process.env.NODE_ENV;
  
  afterEach(() => {
    process.env.NODE_ENV = originalEnv;
  });

  it('should fallback to "Error" when cause.name is undefined', () => {
    const err = new CoreError("TEST_CODE", "Test message", {}, { cause: {} });
    expect(err.toJSON().cause.name).toBe("Error");
  });

  it('should store the correct cause name when provided', () => {
    const cause = new Error("Underlying issue");
    const err = new CoreError("TEST_CODE", "Test message", {}, { cause });
    expect(err.toJSON().cause.name).toBe("Error");
  });

  it('should store the correct cause name when cause has a custom name', () => {
    const cause = new Error("Underlying issue");
    cause.name = "CustomError";
    const err = new CoreError("TEST_CODE", "Test message", {}, { cause });
    expect(err.toJSON().cause.name).toBe("CustomError");
  });

  describe('Stack Trace Handling', () => {
    test('should handle environment without captureStackTrace', () => {
        const originalCaptureStackTrace = Error.captureStackTrace;
        Error.captureStackTrace = undefined;
        
        const error = new CoreError('TEST', 'message');
        expect(error.stack).toBeDefined(); // Default stack trace should exist
        
        Error.captureStackTrace = originalCaptureStackTrace;
    });

    test('should use captureStackTrace when available', () => {
        const error = new CoreError('TEST', 'message');
        expect(error.stack).toBeDefined();
        expect(error.stack).toContain('CoreError');
    });
});

describe('Error Cause Serialization', () => {
  test('should handle cause without name in development', () => {
      const cause = new Error('Cause message');
      delete cause.name; // Remove name property
      
      const error = new CoreError('TEST', 'message', {}, { cause });
      const json = error.toJSON();
      
      expect(json.cause.name).toBe('Error');
  });

  test('should handle cause without stack in development', () => {
      const cause = new Error('Cause message');
      delete cause.stack; // Remove stack property
      
      const error = new CoreError('TEST', 'message', {}, { cause });
      const json = error.toJSON();
      
      expect(json.cause.stack).toBeUndefined();
  });

  test('should handle complete cause properties in development', () => {
      const cause = new Error('Cause message');
      cause.stack = 'Error: Cause message\n    at Test';
      
      const error = new CoreError('TEST', 'message', {}, { cause });
      const json = error.toJSON();
      
      expect(json.cause.name).toBe('Error');
      expect(json.cause.stack).toBe(cause.stack);
  });
});

  describe('Constructor', () => {
    it('should create error with basic properties', () => {
      const error = new CoreError('TEST_ERROR', 'Test message');
      
      expect(error).toBeInstanceOf(Error);
      expect(error).toBeInstanceOf(CoreError);
      expect(error.name).toBe('CoreError');
      expect(error.code).toBe('TEST_ERROR');
      expect(error.message).toBe('Test message');
      expect(error.details).toEqual({});
      expect(error.timestamp).toBeDefined();
    });

    it('should handle detailed error creation', () => {
      const details = { foo: 'bar' };
      const cause = new Error('Original error');
      const error = new CoreError('TEST_ERROR', 'Test message', details, { cause });

      expect(error.details).toEqual(details);
      expect(error.cause).toBe(cause);
    });

    it('should handle object cause with message', () => {
      const error = new CoreError('TEST_ERROR', 'Test message', {}, { 
        cause: { message: 'Custom error', name: 'CustomError' } 
      });

      expect(error.cause).toBeInstanceOf(Error);
      expect(error.cause.message).toBe('Custom error');
      expect(error.cause.name).toBe('CustomError');
    });

    it('should handle string cause', () => {
      const error = new CoreError('TEST_ERROR', 'Test message', {}, {
        cause: 'String error'
      });

      expect(error.cause).toBeInstanceOf(Error);
      expect(error.cause.message).toBe('String error');
    });

    it('should handle object cause without message', () => {
      const causeObj = { foo: 'bar' };
      const error = new CoreError('TEST_ERROR', 'Test message', {}, { cause: causeObj });
      
      expect(error.cause).toBeInstanceOf(Error);
      expect(error.cause.message).toBe(JSON.stringify(causeObj));
    });

    it('should sanitize non-serializable details', () => {
      const circular = {};
      circular.self = circular;
      
      const error = new CoreError('TEST_ERROR', 'Test message', circular);
      
      expect(() => JSON.stringify(error)).not.toThrow();
      expect(error.details).toHaveProperty('error');
      expect(error.details).toHaveProperty('safeDetails');
    });

    it('should format stack trace in browser environment', () => {
      const originalWindow = global.window;
      global.window = {}; // Mock browser environment
      
      const error = new CoreError('TEST_ERROR', 'Test message');
      expect(error.stack).toBeDefined();
      
      global.window = originalWindow;
    });
  });

  describe('toJSON', () => {
    it('should include stack trace in development', () => {
      process.env.NODE_ENV = 'development';
      const error = new CoreError('TEST_ERROR', 'Test message');
      const json = error.toJSON();

      expect(json).toHaveProperty('stack');
    });

    it('should exclude stack trace in production', () => {
      process.env.NODE_ENV = 'production';
      const error = new CoreError('TEST_ERROR', 'Test message');
      const json = error.toJSON();

      expect(json).not.toHaveProperty('stack');
    });

    it('should handle cause serialization in development', () => {
      process.env.NODE_ENV = 'development';
      const cause = new Error('Original error');
      const error = new CoreError('TEST_ERROR', 'Test message', {}, { cause });
      const json = error.toJSON();

      expect(json.cause).toHaveProperty('message', 'Original error');
      expect(json.cause).toHaveProperty('name', 'Error');
      expect(json.cause).toHaveProperty('stack');
    });
  });

  describe('fromJSON', () => {
    it('should recreate error from complete JSON data', () => {
      const original = new CoreError('TEST_ERROR', 'Test message', { foo: 'bar' });
      const json = original.toJSON();
      const recreated = CoreError.fromJSON(json);

      expect(recreated).toBeInstanceOf(CoreError);
      expect(recreated.code).toBe(original.code);
      expect(recreated.message).toBe(original.message);
      expect(recreated.details).toEqual(original.details);
    });

    it('should handle JSON with cause', () => {
      const json = {
        code: 'TEST_ERROR',
        message: 'Test message',
        cause: { message: 'Original error', name: 'CustomError' }
      };
      const error = CoreError.fromJSON(json);

      expect(error.cause).toBeInstanceOf(Error);
      expect(error.cause.message).toBe('Original error');
      expect(error.cause.name).toBe('CustomError');
    });

    it('should handle string cause in JSON', () => {
      const json = {
        code: 'TEST_ERROR',
        message: 'Test message',
        cause: 'String error'
      };
      const error = CoreError.fromJSON(json);

      expect(error.cause).toBeInstanceOf(Error);
      expect(error.cause.message).toBe('String error');
    });
  });

  describe('Environment Detection', () => {
    it('should detect development environment', () => {
      process.env.NODE_ENV = 'development';
      const error = new CoreError('TEST_ERROR', 'Test message');
      
      expect(error.isDevEnvironment()).toBe(true);
    });

    it('should detect test environment as development', () => {
      process.env.NODE_ENV = 'test';
      const error = new CoreError('TEST_ERROR', 'Test message');
      
      expect(error.isDevEnvironment()).toBe(true);
    });

    it('should detect production environment', () => {
      process.env.NODE_ENV = 'production';
      const error = new CoreError('TEST_ERROR', 'Test message');
      
      expect(error.isDevEnvironment()).toBe(false);
    });

    it('should detect client environment', () => {
      const originalWindow = global.window;
      global.window = { ENV: 'development' };
      
      const error = new CoreError('TEST_ERROR', 'Test message');
      expect(error.isClientEnvironment()).toBe(true);
      
      global.window = originalWindow;
    });
  });

  describe('CoreError - Additional Coverage Tests', () => {
    describe('Edge Cases', () => {
      test('should handle circular references in details', () => {
        const circularObj = {};
        circularObj.self = circularObj;
        
        const error = new CoreError('TEST', 'message', circularObj);
        expect(error.details).toHaveProperty('error');
        expect(error.details.error).toContain('non-serializable');
      });
  
      test('should handle undefined stack trace', () => {
        const error = new CoreError('TEST', 'message');
        delete error.stack;
        
        expect(error.formatStackTrace(undefined)).toBeUndefined();
        expect(error.toJSON()).not.toHaveProperty('stack');
      });
    });
  
    describe('Environment Detection', () => {
      const originalWindow = global.window;
      const originalProcess = global.process;
  
      afterEach(() => {
        global.window = originalWindow;
        global.process = originalProcess;
      });
  
      test('should detect development environment in Node.js', () => {
        global.window = undefined;
        process.env.NODE_ENV = 'development';
        
        const error = new CoreError('TEST', 'message');
        expect(error.isDevEnvironment()).toBe(true);
      });
  
      test('should detect development environment in browser', () => {
        delete global.process;
        global.window = { ENV: 'development' };
        
        const error = new CoreError('TEST', 'message');
        expect(error.isDevEnvironment()).toBe(true);
      });
    });
  });

  describe('Cause Serialization Edge Cases', () => {
    test('should handle cause with missing name property', () => {
        // Create a plain object that mimics an Error
        const cause = {
            message: 'Test cause',
            stack: 'Test stack'
        };
        
        const error = new CoreError('TEST', 'Test message', {}, { cause });
        const json = error.toJSON();
        
        expect(json.cause.name).toBe('Error');
        expect(json.cause.message).toBe('Test cause');
    });

    test('should handle cause with empty name property', () => {
        // Create a plain object that mimics an Error
        const cause = {
            name: '',
            message: 'Test cause'
        };
        
        const error = new CoreError('TEST', 'Test message', {}, { cause });
        const json = error.toJSON();
        
        expect(json.cause.name).toBe('Error');
    });

    test('should handle cause with whitespace name', () => {
        // Create a plain object that mimics an Error
        const cause = {
            name: '   ',
            message: 'Test cause'
        };
        
        const error = new CoreError('TEST', 'Test message', {}, { cause });
        const json = error.toJSON();
        
        expect(json.cause.name).toBe('Error');
    });

    test('should handle non-Error cause object', () => {
        const cause = {
            customProp: 'test',
            message: 'Custom error message'
        };
        
        const error = new CoreError('TEST', 'Test message', {}, { cause });
        const json = error.toJSON();
        
        expect(json.cause.name).toBe('Error');
        expect(json.cause.message).toBe('Custom error message');
    });
});

// describe('Cause Name Edge Cases', () => {
//   test('should handle cause with undefined name property', () => {
//       // Create a cause with Object.create to avoid read-only properties
//       const cause = Object.create(Error.prototype, {
//           message: { value: 'Test cause', enumerable: true },
//           stack: { value: 'Test stack trace', enumerable: true }
//       });
//       // This ensures cause.name is actually undefined, not just empty string
//       Object.defineProperty(cause, 'name', {
//           value: undefined,
//           enumerable: true,
//           configurable: true
//       });

//       const error = new CoreError('TEST', 'Test message', {}, { cause });
//       const json = error.toJSON();

//       expect(json.cause).toBeDefined();
//       expect(json.cause.name).toBe('Error');
//       expect(json.cause.message).toBe('Test cause');
//   });

//   test('should handle cause with name explicitly set to undefined', () => {
//       const cause = {
//           message: 'Test cause',
//           name: undefined,  // Explicitly undefined name
//           stack: 'Test stack'
//       };

//       const error = new CoreError('TEST', 'Test message', {}, { cause });
//       const json = error.toJSON();

//       expect(json.cause.name).toBe('Error');
//       expect(json.cause.message).toBe('Test cause');
//   });
// });
describe('Cause Name Edge Cases', () => {
  test('should handle cause with name implicitly undefined', () => {
      // Create a plain object without name property
      const cause = {
          message: 'Test cause',
          stack: 'Test stack'
          // name property deliberately omitted
      };

      const error = new CoreError('TEST', 'Test message', {}, { cause });
      const json = error.toJSON();

      expect(json.cause).toBeDefined();
      expect(json.cause.name).toBe('Error');
      expect(json.cause.message).toBe('Test cause');
  });

  test('should handle cause with explicit undefined name', () => {
      // Create a cause as plain object
      const cause = {
          message: 'Test cause',
          name: undefined,
          stack: 'Test stack'
      };

      const error = new CoreError('TEST', 'Test message', {}, { cause });
      const json = error.toJSON();

      expect(json.cause).toBeDefined();
      expect(json.cause.name).toBe('Error');
      expect(json.cause.message).toBe('Test cause');
  });

  test('should handle non-Error cause object', () => {
      // Test with a completely different object structure
      const cause = {
          message: 'Test cause',
          customField: 'test'
      };

      const error = new CoreError('TEST', 'Test message', {}, { cause });
      const json = error.toJSON();

      expect(json.cause).toBeDefined();
      expect(json.cause.name).toBe('Error');
      expect(json.cause.message).toBe('Test cause');
  });

  test('should handle cause with name as null', () => {
      const cause = {
          message: 'Test cause',
          name: null
      };

      const error = new CoreError('TEST', 'Test message', {}, { cause });
      const json = error.toJSON();

      expect(json.cause).toBeDefined();
      expect(json.cause.name).toBe('Error');
  });
});

describe('Error Serialization Edge Cases', () => {
  test('should handle undefined cause name in toJSON', () => {
      const error = new CoreError('TEST', 'Test message');
      // Directly set cause after creation to bypass initCause
      Object.defineProperty(error, 'cause', {
          value: {
              message: 'Cause message',
              name: undefined  // This is key for line 144
          },
          configurable: true,
          writable: true
      });

      const json = error.toJSON();
      expect(json.cause.name).toBe('Error');
  });

  test('should preserve cause name when available', () => {
      const error = new CoreError('TEST', 'Test message');
      Object.defineProperty(error, 'cause', {
          value: {
              message: 'Cause message',
              name: 'CustomError'
          },
          configurable: true,
          writable: true
      });

      const json = error.toJSON();
      expect(json.cause.name).toBe('CustomError');
  });

  test('should handle missing cause name property', () => {
      const error = new CoreError('TEST', 'Test message');
      Object.defineProperty(error, 'cause', {
          value: {
              message: 'Cause message'
              // name property completely missing
          },
          configurable: true,
          writable: true
      });

      const json = error.toJSON();
      expect(json.cause.name).toBe('Error');
  });
});
});


// tests/core/errors/ErrorSystem.test.js

// tests/core/errors/ErrorSystem.test.js

import {
  ErrorSystem,
  createErrorSystem,
} from "../../../src/core/errors/ErrorSystem.js";
import { CoreError } from "../../../src/core/errors/Error.js";

describe("ErrorSystem", () => {
  let errorSystem;
  let mockLogger;

  function createMockFn() {
    const fn = (...args) => {
      fn.mock.calls.push(args);
      return fn.mockReturnValue;
    };
    fn.mock = { calls: [] };
    fn.mockReturnValue = fn;
    fn.mockClear = () => {
      fn.mock.calls = [];
    };
    return fn;
  }

  beforeEach(() => {
    mockLogger = {
      error: createMockFn(),
      warn: createMockFn(),
      info: createMockFn(),
    };
    errorSystem = new ErrorSystem({ logger: mockLogger });
  });

  // Add these tests inside describe('ErrorSystem')

  describe("Construction", () => {
    test("should use console logger when no logger provided", () => {
      const systemWithoutLogger = new ErrorSystem({});
      expect(systemWithoutLogger.logger).toBe(console);
    });

    test("should handle empty dependencies", () => {
      const systemNoDeps = new ErrorSystem();
      expect(systemNoDeps.deps).toEqual({});
      expect(systemNoDeps.logger).toBe(console);
    });

    test("should properly initialize all maps", () => {
      const system = new ErrorSystem({});
      expect(system.integrations).toBeInstanceOf(Map);
      expect(system.handlers).toBeInstanceOf(Map);
      expect(system.errorTypes).toBeInstanceOf(Map);
    });
  });

  describe("Handler Resolution", () => {
    beforeEach(async () => {
      await errorSystem.initialize();
    });

    test("should resolve to specific handler when available", async () => {
      const specificHandler = createMockFn();
      const defaultHandler = createMockFn();

      errorSystem.registerHandler("CoreError", specificHandler);
      errorSystem.registerHandler("*", defaultHandler);

      const error = new CoreError("TEST", "test");
      await errorSystem.handleError(error);

      expect(specificHandler.mock.calls.length).toBe(1);
      expect(defaultHandler.mock.calls.length).toBe(0);
    });

    test("should fallback to default handler when specific not found", async () => {
      const defaultHandler = createMockFn();
      errorSystem.registerHandler("*", defaultHandler);

      const error = new CoreError("TEST", "test");
      await errorSystem.handleError(error);

      expect(defaultHandler.mock.calls.length).toBe(1);
    });

    test("should pass context to handler", async () => {
      const handler = createMockFn();
      const context = { requestId: "123" };

      errorSystem.registerHandler("CoreError", handler);

      const error = new CoreError("TEST", "test");
      await errorSystem.handleError(error, context);

      expect(handler.mock.calls[0][1]).toBe(context);
    });
  });
  describe('Default Error Handler', () => {
    beforeEach(async () => {
      await errorSystem.initialize();
    });

    test('should handle undefined context', async () => {
      // Call defaultErrorHandler with undefined context
      errorSystem.defaultErrorHandler(new CoreError('TEST', 'test message'), undefined);
      
      expect(mockLogger.error.mock.calls.length).toBe(1);
      const loggedError = mockLogger.error.mock.calls[0][1];
      expect(loggedError.context).toEqual({});
    });

    test('should use provided context', async () => {
      const context = { requestId: '123' };
      errorSystem.defaultErrorHandler(new CoreError('TEST', 'test message'), context);
      
      const loggedError = mockLogger.error.mock.calls[0][1];
      expect(loggedError.context).toBe(context);
    });
  });
  describe("Factory Function", () => {
    test("should create new instance with dependencies", () => {
      const deps = { logger: mockLogger };
      const system = createErrorSystem(deps);
      expect(system).toBeInstanceOf(ErrorSystem);
      expect(system.logger).toBe(mockLogger);
    });
  });

  describe("Initialization", () => {
    test("should initialize with default handler", async () => {
      await errorSystem.initialize();
      expect(errorSystem.initialized).toBe(true);
      expect(errorSystem.handlers.has("*")).toBe(true);
    });

    test("should prevent double initialization", async () => {
      await errorSystem.initialize();
      await expect(errorSystem.initialize()).rejects.toThrow(
        "Already initialized"
      );
    });

    test("should validate error types during initialization", async () => {
      const invalidErrorSystem = new ErrorSystem({ logger: mockLogger });
      invalidErrorSystem.errorTypes.set("InvalidType", class Invalid {});

      await expect(invalidErrorSystem.initialize()).rejects.toThrow(
        "Error type InvalidType must extend CoreError"
      );
    });
  });

  describe("Error Handler Registration", () => {
    test("should throw on invalid handler registration", async () => {
      await errorSystem.initialize();
      expect(() => {
        errorSystem.registerHandler("TEST", null);
      }).toThrow("Handler must be a function");
    });

    test("should successfully register handler", async () => {
      await errorSystem.initialize();
      const handler = () => {};
      errorSystem.registerHandler("TEST", handler);
      expect(errorSystem.handlers.get("TEST")).toBe(handler);
    });
  });

  describe("Error Handling", () => {
    beforeEach(async () => {
      await errorSystem.initialize();
    });

    test("should handle errors with registered handler", async () => {
      const mockHandler = createMockFn();
      errorSystem.registerHandler("CoreError", mockHandler);

      const error = new CoreError("TEST", "test message");
      await errorSystem.handleError(error);

      expect(mockHandler.mock.calls.length).toBe(1);
      expect(mockHandler.mock.calls[0][0]).toBe(error);
    });

    test("should use default handler when no specific handler exists", async () => {
      const error = new CoreError("TEST", "test message");
      await errorSystem.handleError(error);

      expect(mockLogger.error.mock.calls.length).toBe(1);
    });

    test("should include all error details in default handler", async () => {
      const context = { requestId: "123" };
      const error = new CoreError("TEST", "test message", {
        someDetail: "test",
      });

      await errorSystem.handleError(error, context);

      const loggedError = mockLogger.error.mock.calls[0][1];
      expect(loggedError).toEqual({
        type: "CoreError",
        code: "TEST",
        message: "test message",
        details: { someDetail: "test" },
        context,
      });
    });
  });

  describe("Error Handler Failures", () => {
    beforeEach(async () => {
      await errorSystem.initialize();
    });

    test("should handle and log handler failures", async () => {
      const handlerError = new Error("Handler failed");
      errorSystem.registerHandler("CoreError", () => {
        throw handlerError;
      });

      let emittedEvent = null;
      errorSystem.on("error:handler:failed", (event) => {
        emittedEvent = event;
      });

      const originalError = new CoreError("TEST", "test");

      await expect(errorSystem.handleError(originalError)).rejects.toBe(
        handlerError
      );

      expect(mockLogger.error.mock.calls[0]).toEqual([
        "Error handler failed:",
        handlerError,
      ]);
      expect(emittedEvent).toEqual({
        error: handlerError,
        originalError,
      });
    });

    test("should log and rethrow handler errors with details", async () => {
      const error = new Error("Handler failed");
      error.details = { reason: "test" };

      errorSystem.registerHandler("CoreError", () => {
        throw error;
      });

      const originalError = new CoreError("TEST", "test message");
      await expect(errorSystem.handleError(originalError)).rejects.toBe(error);

      expect(mockLogger.error.mock.calls[0][1].details).toEqual({
        reason: "test",
      });
    });
  });

  describe("Framework Integration", () => {
    beforeEach(async () => {
      await errorSystem.initialize();
    });

    test("should register framework integration", async () => {
      const mockFramework = {
        addHook: createMockFn(),
        setErrorHandler: createMockFn(),
      };

      const integration = errorSystem.registerIntegration(mockFramework);

      expect(errorSystem.integrations.has(mockFramework)).toBe(true);
      expect(integration).toBeDefined();
    });

    test("should throw on invalid framework", async () => {
      expect(() => {
        errorSystem.registerIntegration(null);
      }).toThrow("Framework is required");
    });
  });

  describe("Event Emission", () => {
    beforeEach(async () => {
      await errorSystem.initialize();
    });

    test("should emit error handled event", async () => {
      const mockListener = createMockFn();
      errorSystem.on("error:handled", mockListener);

      const error = new CoreError("TEST", "test message");
      await errorSystem.handleError(error);

      expect(mockListener.mock.calls.length).toBe(1);
      expect(mockListener.mock.calls[0][0].error).toBe(error);
    });

    test("should emit handler failure event", async () => {
      const mockListener = createMockFn();
      errorSystem.on("error:handler:failed", mockListener);

      const handlerError = new Error("Handler failed");
      errorSystem.registerHandler("CoreError", () => {
        throw handlerError;
      });

      const originalError = new CoreError("TEST", "test message");
      await expect(errorSystem.handleError(originalError)).rejects.toBe(
        handlerError
      );

      expect(mockListener.mock.calls[0][0]).toEqual({
        error: handlerError,
        originalError,
      });
    });
  });

  describe("Shutdown", () => {
    test("should cleanup resources on shutdown", async () => {
      await errorSystem.initialize();
      errorSystem.registerHandler("test", () => {});

      await errorSystem.shutdown();

      expect(errorSystem.initialized).toBe(false);
      expect(errorSystem.handlers.size).toBe(0);
      expect(errorSystem.integrations.size).toBe(0);
      expect(errorSystem.errorTypes.size).toBe(0);
    });

    test("should handle multiple shutdown calls", async () => {
      await errorSystem.initialize();
      await errorSystem.shutdown();
      await errorSystem.shutdown(); // Should not throw
      expect(errorSystem.initialized).toBe(false);
    });
  });
  describe("Error Creation", () => {
    beforeEach(async () => {
      await errorSystem.initialize();
    });

    test("should create CoreError when no specific type is found", () => {
      const error = errorSystem.createError(
        'UNKNOWN_TYPE', 
        'TEST_CODE', 
        'Test message', 
        { detail: 'Some detail' }
      );

      expect(error).toBeInstanceOf(CoreError);
      expect(error.code).toBe('TEST_CODE');
      expect(error.message).toBe('Test message');
      expect(error.details).toEqual({ detail: 'Some detail' });
    });

    test("should create error with registered error type", () => {
      // Setup a custom error type
      class CustomError extends CoreError {
        constructor(code, message, details, options) {
          super(code, message, details, options);
          this.isCustom = true;
        }
      }

      // Register the custom error type
      errorSystem.errorTypes.set('CustomError', CustomError);

      const error = errorSystem.createError(
        'CustomError', 
        'SPECIFIC_CODE', 
        'Specific message', 
        { specific: 'detail' }
      );

      expect(error).toBeInstanceOf(CustomError);
      expect(error.code).toBe('SPECIFIC_CODE');
      expect(error.message).toBe('Specific message');
      expect(error.details).toEqual({ specific: 'detail' });
      expect(error.isCustom).toBe(true);
    });

    test("should pass additional options to error constructor", () => {
      const originalError = new Error('Original error');
      const options = { 
        cause: originalError,
        severity: 'high'
      };

      const error = errorSystem.createError(
        'UNKNOWN_TYPE', 
        'TEST_CODE', 
        'Test message', 
        { detail: 'Some detail' },
        options
      );

      expect(error).toBeInstanceOf(CoreError);
      
      // Verify that the options are correctly used during construction
      // This assumes that CoreError constructor uses these options
      // If the actual implementation differs, you may need to adjust this test
      expect(error.message).toBe('Test message');
      expect(error.details).toEqual({ detail: 'Some detail' });
      
      // The exact verification depends on how CoreError handles these options
      // You might want to check the CoreError.js implementation to confirm
      // This is a generic test that assumes some basic option handling
    });

    test("should handle empty details and options", () => {
      const error = errorSystem.createError(
        'UNKNOWN_TYPE', 
        'TEST_CODE', 
        'Test message'
      );

      expect(error).toBeInstanceOf(CoreError);
      expect(error.code).toBe('TEST_CODE');
      expect(error.message).toBe('Test message');
      expect(error.details).toEqual({});
    });
  });


});


// tests/core/errors/integration.test.js

import {
    ConfigError,
    ModuleError,
    ServiceError,
    ValidationError,
    NetworkError,
    AuthError,
    AccessError
  } from '../../../src/core/errors/types';
  
  import { createErrorFromResponse, ErrorCodes } from '../../../src/core/errors/index.js';
  import { CoreError } from '../../../src/core/errors/Error.js';

  describe('Error Types', () => {
    describe("Error Factory Function", () => {
      it('should fallback to CoreError when an unknown error type is encountered', () => {
        const unknownErrorData = { name: "UnknownError", code: "UNKNOWN_CODE", message: "Unknown error" };
        const error = createErrorFromResponse(unknownErrorData);
        expect(error).toBeInstanceOf(CoreError);
        expect(error.code).toBe("UNKNOWN_CODE");
      });
    
      it('should fallback to CoreError when errorData.name is undefined', () => {
        const unknownErrorData = { code: "UNKNOWN_CODE", message: "Unknown error" };
        const error = createErrorFromResponse(unknownErrorData);
        expect(error).toBeInstanceOf(CoreError);
      });
    });
    
    describe('ConfigError', () => {
      it('should create ConfigError with correct properties', () => {
        const error = new ConfigError('INVALID_CONFIG', 'Invalid configuration', { key: 'test' });
        expect(error.name).toBe('ConfigError');
        expect(error.code).toBe('CONFIG_INVALID_CONFIG');
        expect(error.statusCode).toBe(500);
      });
    });
  
    describe('ModuleError', () => {
      it('should create ModuleError with correct properties', () => {
        const error = new ModuleError('INIT_FAILED', 'Module initialization failed', { module: 'test' });
        expect(error.name).toBe('ModuleError');
        expect(error.code).toBe('MODULE_INIT_FAILED');
        expect(error.statusCode).toBe(500);
      });
    });
  
    describe('ServiceError', () => {
      it('should create ServiceError with correct properties', () => {
        const error = new ServiceError('SERVICE_DOWN', 'Service unavailable', { service: 'test' });
        expect(error.name).toBe('ServiceError');
        expect(error.code).toBe('SERVICE_SERVICE_DOWN');
        expect(error.statusCode).toBe(503);
      });
  
      it('should handle error cause properly', () => {
        const cause = new Error('Original error');
        const error = new ServiceError('TEST', 'Test error', {}, { cause });
        expect(error.cause).toBe(cause);
      });
    });
  
    describe('ValidationError', () => {
      it('should create ValidationError with correct properties', () => {
        const error = new ValidationError('INVALID_INPUT', 'Invalid input data', {
          validationErrors: [{ field: 'test', message: 'Required' }]
        });
        expect(error.name).toBe('ValidationError');
        expect(error.code).toBe('VALIDATION_INVALID_INPUT');
        expect(error.statusCode).toBe(400);
        expect(error.validationErrors).toHaveLength(1);
      });

      it('should fallback to an empty array when validationErrors is not an array', () => {
        const err1 = new ValidationError("INVALID_INPUT", "Invalid input", { validationErrors: "not an array" });
        expect(err1.validationErrors).toEqual([]);
    
        const err2 = new ValidationError("INVALID_INPUT", "Invalid input", { validationErrors: 42 });
        expect(err2.validationErrors).toEqual([]);
    
        const err3 = new ValidationError("INVALID_INPUT", "Invalid input", { validationErrors: {} });
        expect(err3.validationErrors).toEqual([]);
    
        const err4 = new ValidationError("INVALID_INPUT", "Invalid input", {});
        expect(err4.validationErrors).toEqual([]);
      });
    });
  
    describe('NetworkError', () => {
      it('should create NetworkError with correct properties', () => {
        const error = new NetworkError('REQUEST_FAILED', 'Network request failed', { 
          url: 'http://test.com',
          statusCode: 404 
        });
        expect(error.name).toBe('NetworkError');
        expect(error.code).toBe('NETWORK_REQUEST_FAILED');
        expect(error.statusCode).toBe(404);
      });
  
      it('should use default status code if not provided', () => {
        const error = new NetworkError('REQUEST_FAILED', 'Network request failed');
        expect(error.statusCode).toBe(503);
      });
    });
  
    describe('AuthError', () => {
      it('should create AuthError with correct properties', () => {
        const error = new AuthError('INVALID_TOKEN', 'Invalid authentication token');
        expect(error.name).toBe('AuthError');
        expect(error.code).toBe('AUTH_INVALID_TOKEN');
        expect(error.statusCode).toBe(401);
      });
    });
  
    describe('AccessError', () => {
      it('should create AccessError with correct properties', () => {
        const error = new AccessError('FORBIDDEN', 'Access denied', { resource: 'test' });
        expect(error.name).toBe('AccessError');
        expect(error.code).toBe('ACCESS_FORBIDDEN');
        expect(error.statusCode).toBe(403);
      });
    });
  });
  describe('Error Cause Edge Cases', () => {
    test('should handle error cause with empty name', () => {
        const causeError = new Error('test message');
        causeError.name = '';  // Empty name
        
        const error = new CoreError('TEST', 'message', {}, { cause: causeError });
        expect(error.cause.name).toBe('Error');
    });

    test('should handle error cause with whitespace name', () => {
        const causeError = new Error('test message');
        causeError.name = '   ';  // Whitespace name
        
        const error = new CoreError('TEST', 'message', {}, { cause: causeError });
        expect(error.cause.name).toBe('Error');
    });

    test('should handle error cause with null name', () => {
        const causeError = new Error('test message');
        causeError.name = null;  // Null name
        
        const error = new CoreError('TEST', 'message', {}, { cause: causeError });
        expect(error.cause.name).toBe('Error');
    });

    test('should handle error cause with undefined name', () => {
        const causeError = new Error('test message');
        causeError.name = undefined;  // Undefined name
        
        const error = new CoreError('TEST', 'message', {}, { cause: causeError });
        expect(error.cause.name).toBe('Error');
    });
  });
  // tests/core/errors/integration.test.js

describe('Error Response Creation', () => {
  // ... previous tests ...

  test('should use errorData code with empty message', () => {
      const response = {
          data: {
              code: 'CUSTOM_ERROR',
          }
      };
      const error = createErrorFromResponse(response);
      expect(error.code).toBe('CUSTOM_ERROR');
      expect(error.message).toBe('Unknown error occurred');
  });

  test('should use default code with custom message', () => {
      const response = {
          data: {
              message: 'Custom message only'
          }
      };
      const error = createErrorFromResponse(response);
      expect(error.code).toBe(ErrorCodes.CORE.UNKNOWN);
      expect(error.message).toBe('Custom message only');
  });

  test('should handle undefined error data properties', () => {
      const response = {
          data: {
              code: undefined,
              message: undefined
          }
      };
      const error = createErrorFromResponse(response);
      expect(error.code).toBe(ErrorCodes.CORE.UNKNOWN);
      expect(error.message).toBe('Unknown error occurred');
  });

  test('should handle non-object error data', () => {
      const response = {
          data: 'string data'
      };
      const error = createErrorFromResponse(response);
      expect(error.code).toBe(ErrorCodes.CORE.UNKNOWN);
      expect(error.message).toBe('Unknown error occurred');
  });
});


// tests/core/errors/integrations/IFrameworkIntegration.test.js

// tests/core/errors/integrations/IFrameworkIntegration.test.js

import { IFrameworkIntegration } from '../../../../src/core/errors/integrations/IFrameworkIntegration.js';
import { CoreError } from '../../../../src/core/errors/Error.js';

// Mock framework for testing
class MockFramework {
  constructor() {
    this.errorHandler = null;
  }

  setErrorHandler(handler) {
    this.errorHandler = handler;
  }

  triggerError(error) {
    return this.errorHandler?.(error);
  }
}

describe('IFrameworkIntegration', () => {
  describe('Base Interface', () => {
    it('should throw errors for unimplemented methods', () => {
      const integration = new IFrameworkIntegration();

      expect(() => integration.initialize()).toThrow('initialize() must be implemented');
      expect(() => integration.serializeError()).toThrow('serializeError() must be implemented');
      expect(() => integration.mapError()).toThrow('mapError() must be implemented');
    });
  });

  describe('Framework Integration', () => {
    // Create a test implementation
    class TestIntegration extends IFrameworkIntegration {
      initialize(framework, options = {}) {
        this.framework = framework;
        this.options = options;
      }

      serializeError(error) {
        return {
          code: error.code || 'UNKNOWN',
          message: error.message,
          timestamp: new Date().toISOString()
        };
      }

      mapError(frameworkError) {
        if (frameworkError instanceof CoreError) {
          return frameworkError;
        }
        return new CoreError('TEST_ERROR', frameworkError.message);
      }
    }

    let integration;
    let mockFramework;

    beforeEach(() => {
      integration = new TestIntegration();
      mockFramework = new MockFramework();
    });

    it('should initialize with framework instance', () => {
      const options = { custom: 'option' };
      integration.initialize(mockFramework, options);

      expect(integration.framework).toBe(mockFramework);
      expect(integration.options).toEqual(options);
    });

    it('should serialize errors correctly', () => {
      const error = new Error('Test error');
      const serialized = integration.serializeError(error);

      expect(serialized).toHaveProperty('code', 'UNKNOWN');
      expect(serialized).toHaveProperty('message', 'Test error');
      expect(serialized).toHaveProperty('timestamp');
    });

    it('should map framework errors to CoreError', () => {
      const frameworkError = new Error('Framework error');
      const mappedError = integration.mapError(frameworkError);

      expect(mappedError).toBeInstanceOf(CoreError);
      expect(mappedError.code).toBe('TEST_ERROR');
      expect(mappedError.message).toBe('Framework error');
    });

    it('should pass through CoreError instances without mapping', () => {
      const coreError = new CoreError('ORIGINAL', 'Original error');
      const mappedError = integration.mapError(coreError);

      expect(mappedError).toBe(coreError);
    });

    it('should handle full error workflow', () => {
      const frameworkError = new Error('Framework test error');
      
      integration.initialize(mockFramework);
      
      const mappedError = integration.mapError(frameworkError);
      expect(mappedError).toBeInstanceOf(CoreError);
      
      const serialized = integration.serializeError(mappedError);
      expect(serialized).toEqual({
        code: 'TEST_ERROR',
        message: 'Framework test error',
        timestamp: expect.any(String)
      });
    });
  });
});


// tests/core/errors/integrations/fastify/FastifyIntegration.test.js

// tests/core/errors/integrations/fastify/FastifyIntegration.test.js

import { FastifyIntegration } from '../../../../../src/core/errors/integrations/fastify/FastifyIntegration.js';
import { CoreError, ValidationError, NetworkError } from '../../../../../src/core/errors/index.js';
import { ErrorCodes } from '../../../../../src/core/errors/index.js';

describe('FastifyIntegration', () => {
  let integration;
  let mockFastify;
  let mockRequest;
  let mockReply;

  function createMockFn() {
    const fn = (...args) => {
      fn.mock.calls.push(args);
      return fn.mockReturnValue;
    };
    fn.mock = { calls: [] };
    fn.mockReturnValue = fn;
    fn.mockReturnThis = () => {
      fn.mockReturnValue = mockReply;
      return fn;
    };
    fn.mockClear = () => {
      fn.mock.calls = [];
    };
    return fn;
  }

  beforeEach(() => {
    integration = new FastifyIntegration();
    
    mockRequest = {
      url: '/test',
      method: 'GET'
    };

    mockReply = {
      status: createMockFn(),
      send: createMockFn()
    };
    mockReply.status.mockReturnValue = mockReply;
    mockReply.send.mockReturnValue = mockReply;

    mockFastify = {
      addHook: createMockFn(),
      setErrorHandler: createMockFn()
    };
  });

  describe('initialize', () => {
    test('should handle early return if already initialized', () => {
      integration.initialized = true;
      integration.initialize(mockFastify);
      expect(mockFastify.addHook.mock.calls.length).toBe(0);
    });

    test('should set up request hook and error handler', () => {
      integration.initialize(mockFastify);
      expect(mockFastify.addHook.mock.calls.length).toBe(1);
      expect(mockFastify.setErrorHandler.mock.calls.length).toBe(1);
    });

    test('should handle undefined request properties in hook', async () => {
      integration.initialize(mockFastify);
      const hookFn = mockFastify.addHook.mock.calls[0][1];
      
      const undefinedRequest = {
        url: undefined,
        method: undefined,
        id: undefined
      };
      
      await hookFn(undefinedRequest);
      expect(undefinedRequest.errorContext).toBeDefined();
      expect(undefinedRequest.errorContext.url).toBe('');
      expect(undefinedRequest.errorContext.method).toBe('');
    });

    test('should handle null request in hook', async () => {
      integration.initialize(mockFastify);
      const hookFn = mockFastify.addHook.mock.calls[0][1];
      await hookFn(null);
      // Should not throw
      expect(true).toBe(true);
    });
  });

  describe('error handling', () => {
    test('should handle undefined error properties in mapError', async () => {
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const undefinedError = undefined;
      await errorHandler(undefinedError, mockRequest, mockReply);
      
      expect(mockReply.status.mock.calls[0][0]).toBe(500);
      expect(mockReply.send.mock.calls[0][0].code).toBe('UNKNOWN_ERROR');
    });

    test('should handle validation errors', async () => {
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const validationError = {
        validation: [{ message: 'Invalid input' }],
        statusCode: 400
      };
      
      await errorHandler(validationError, mockRequest, mockReply);
      
      expect(mockReply.status.mock.calls[0][0]).toBe(400);
      expect(mockReply.send.mock.calls[0][0].code).toBe('VALIDATION_FAILED');
    });

    test('should handle validation error without statusCode', async () => {
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const validationError = {
        validation: [{ message: 'Invalid input' }]
      };
      
      await errorHandler(validationError, mockRequest, mockReply);
      expect(mockReply.status.mock.calls[0][0]).toBe(400);
    });

    test('should handle 404 errors', async () => {
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const notFoundError = {
        statusCode: 404,
        method: 'GET',
        url: '/not-found'
      };
      
      await errorHandler(notFoundError, mockRequest, mockReply);
      
      expect(mockReply.status.mock.calls[0][0]).toBe(404);
      expect(mockReply.send.mock.calls[0][0].code).toBe('NETWORK_ROUTE_NOT_FOUND');
    });

    test('should handle 404 error without method and url', async () => {
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const notFoundError = {
        statusCode: 404
      };
      
      await errorHandler(notFoundError, mockRequest, mockReply);
      
      const response = mockReply.send.mock.calls[0][0];
      expect(response.message).toBe('Route : not found');
      expect(mockReply.status.mock.calls[0][0]).toBe(404);
    });

    test('should handle standard errors', async () => {
      process.env.NODE_ENV = 'development';
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const standardError = new Error('Standard error');
      await errorHandler(standardError, mockRequest, mockReply);
      
      const response = mockReply.send.mock.calls[0][0];
      expect(response.details.originalError).toBeDefined();
    });

    test('should handle errors with undefined context', async () => {
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      await errorHandler(new Error(), undefined, mockReply);
      
      const response = mockReply.send.mock.calls[0][0];
      expect(response.context.url).toBe('');
      expect(response.context.method).toBe('');
    });
  });

  describe('error serialization', () => {
    test('should handle CoreError instances', async () => {
      integration.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const error = new CoreError('TEST', 'Test error');
      await errorHandler(error, mockRequest, mockReply);
      
      expect(mockReply.send.mock.calls[0][0].code).toBe('TEST');
    });

    test('should handle all error serialization paths', () => {
      const serialized = integration.serializeError(undefined);
      expect(serialized.code).toBe('UNKNOWN_ERROR');
      expect(serialized.message).toBe('Unknown error occurred');
      
      const withContext = integration.serializeError(new Error(), null);
      expect(withContext.context).toEqual({});
    });
  });
});


// tests/core/errors/integrations/fastify/handler.test.js

// tests/core/errors/integrations/fastify/handler.test.js

import { FastifyErrorHandler } from '../../../../../src/core/errors/integrations/fastify/handler.js';
import { CoreError } from '../../../../../src/core/errors/Error.js';

describe('Fastify Error Handler', () => {
  let handler;
  let mockFastify;
  let mockRequest;
  let mockReply;

  function createMockFn() {
    const fn = (...args) => {
      fn.mock.calls.push(args);
      return fn.mockReturnValue;
    };
    fn.mock = { calls: [] };
    fn.mockReturnValue = fn;
    fn.mockReturnThis = () => {
      fn.mockReturnValue = mockReply;
      return fn;
    };
    fn.mockClear = () => {
      fn.mock.calls = [];
    };
    return fn;
  }

  beforeEach(() => {
    handler = new FastifyErrorHandler();
    
    mockRequest = {
      url: '/test',
      method: 'GET'
    };

    mockReply = {
      status: createMockFn(),
      send: createMockFn()
    };
    mockReply.status.mockReturnValue = mockReply;
    mockReply.send.mockReturnValue = mockReply;

    mockFastify = {
      addHook: createMockFn(),
      setErrorHandler: createMockFn()
    };
  });

  describe('Setup', () => {
    test('should handle early return if already initialized', () => {
      handler.initialized = true;
      handler.initialize(mockFastify);
      expect(mockFastify.addHook.mock.calls.length).toBe(0);
    });

    test('should set up request hook and error handler', () => {
      handler.initialize(mockFastify);
      expect(mockFastify.addHook.mock.calls.length).toBe(1);
      expect(mockFastify.setErrorHandler.mock.calls.length).toBe(1);
    });

    test('should handle invalid fastify instance', () => {
      expect(() => handler.initialize({})).toThrow('Invalid fastify instance');
    });
  });

  describe('Error Handling', () => {

    test('should handle undefined error properties in mapError', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const undefinedError = undefined;
      await errorHandler(undefinedError, mockRequest, mockReply);
      
      expect(mockReply.status.mock.calls[0][0]).toBe(500);
      expect(mockReply.send.mock.calls[0][0].code).toBe('UNKNOWN_ERROR');
    });

    test('should handle validation errors', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const validationError = {
        validation: [{ message: 'Invalid input' }],
        statusCode: 400
      };
      
      await errorHandler(validationError, mockRequest, mockReply);
      
      expect(mockReply.status.mock.calls[0][0]).toBe(400);
      expect(mockReply.send.mock.calls[0][0].code).toBe('VALIDATION_FAILED');
    });

    test('should handle 404 errors', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const notFoundError = {
        statusCode: 404,
        method: 'GET',
        url: '/not-found'
      };
      
      await errorHandler(notFoundError, mockRequest, mockReply);
      
      expect(mockReply.status.mock.calls[0][0]).toBe(404);
      expect(mockReply.send.mock.calls[0][0].code).toBe('NETWORK_ROUTE_NOT_FOUND');
    });

    test('should handle generic errors in development mode', async () => {
      process.env.NODE_ENV = 'development';
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const genericError = new Error('Generic error');
      await errorHandler(genericError, mockRequest, mockReply);
      
      const response = mockReply.send.mock.calls[0][0];
      expect(response.details.originalError).toBeDefined();
    });

    test('should handle errors with undefined context', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      await errorHandler(new Error(), undefined, mockReply);
      
      const response = mockReply.send.mock.calls[0][0];
      expect(response.context.url).toBe('');
      expect(response.context.method).toBe('');
    });

    test('should handle all error serialization paths', () => {
      const serialized = handler.serializeError(undefined);
      expect(serialized.code).toBe('UNKNOWN_ERROR');
      expect(serialized.message).toBe('Unknown error occurred');
      
      const withContext = handler.serializeError(new Error(), null);
      expect(withContext.context).toEqual({});
    });
    test('should handle missing reply methods', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const invalidReply = {};
      await expect(errorHandler(new Error(), mockRequest, invalidReply))
        .rejects.toThrow('Invalid reply object');
    });

    test('should handle null request', async () => {
      handler.initialize(mockFastify);
      const hookFn = mockFastify.addHook.mock.calls[0][1];
      await hookFn(null);
      expect(true).toBe(true); // Should not throw
    });

    test('should handle CoreError instances', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      const error = new CoreError('TEST', 'Test error');
      await errorHandler(error, mockRequest, mockReply);
      
      expect(mockReply.send.mock.calls[0][0].code).toBe('TEST');
    });
  });
  describe('Edge Cases', () => {
    test('should handle request hook with undefined values', async () => {
      handler.initialize(mockFastify);
      const hookFn = mockFastify.addHook.mock.calls[0][1];
      
      const undefinedRequest = {
        url: undefined,
        method: undefined,
        id: undefined
      };
      
      await hookFn(undefinedRequest);
      expect(undefinedRequest.errorContext).toBeDefined();
      expect(undefinedRequest.errorContext.url).toBe('');
      expect(undefinedRequest.errorContext.method).toBe('');
    });

    test('should handle validation error without statusCode', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      // Test line 68: validation error without statusCode
      const validationError = {
        validation: [{ message: 'Invalid input' }]
        // statusCode intentionally omitted
      };
      
      await errorHandler(validationError, mockRequest, mockReply);
      expect(mockReply.status.mock.calls[0][0]).toBe(400); // Default validation error status
    });

    test('should handle 404 error without method and url', async () => {
      handler.initialize(mockFastify);
      const errorHandler = mockFastify.setErrorHandler.mock.calls[0][0];
      
      // Test line 75: 404 error without method and url
      const notFoundError = {
        statusCode: 404
        // method and url intentionally omitted
      };
      
      await errorHandler(notFoundError, mockRequest, mockReply);
      
      const response = mockReply.send.mock.calls[0][0];
      expect(response.message).toBe('Route : not found'); // Empty method/url handling
      expect(mockReply.status.mock.calls[0][0]).toBe(404);
    });
  });

  describe('Singleton Instance', () => {
    test('should properly set up error handler through setupErrorHandler', async () => {
      const { setupErrorHandler } = await import('../../../../../src/core/errors/integrations/fastify/handler.js');
      
      const result = setupErrorHandler(mockFastify);
      expect(result.initialized).toBe(true);
    });
  });
});


// tests/core/errors/integrations/fastify/serializer.test.js

// tests/core/errors/integrations/fastify/serializer.test.js

import { errorSerializer } from '../../../../../src/core/errors/integrations/fastify/serializer.js';
import { CoreError, ErrorCodes } from '../../../../../src/core/errors/index.js';
import { ValidationError } from '../../../../../src/core/errors/types/ValidationError.js';

describe('Fastify Error Serializer', () => {
  it('should serialize CoreError correctly', () => {
    const error = new CoreError('TEST_ERROR', 'Test message', { detail: 'test' });
    const serialized = errorSerializer.serializer(error);

    expect(serialized).toMatchObject({
      code: 'TEST_ERROR',
      message: 'Test message',
      details: { detail: 'test' },
      timestamp: expect.any(String),
      context: {}
    });
  });

  it('should serialize ValidationError with validationErrors', () => {
    const error = new ValidationError(
      ErrorCodes.VALIDATION.FAILED,
      'Validation failed',
      {
        validationErrors: [{ field: 'test', message: 'required' }]
      }
    );
    const serialized = errorSerializer.serializer(error);

    expect(serialized).toMatchObject({
      code: `VALIDATION_${ErrorCodes.VALIDATION.FAILED}`,
      message: 'Validation failed',
      details: {
        validationErrors: [{ field: 'test', message: 'required' }]
      },
      timestamp: expect.any(String),
      context: {}
    });
  });

  it('should serialize standard Error objects', () => {
    const error = new Error('Standard error');
    const serialized = errorSerializer.serializer(error);

    expect(serialized).toEqual({
      code: ErrorCodes.CORE.UNKNOWN,
      message: 'Standard error',
      timestamp: expect.any(String),
      context: {}
    });
  });

  it('should handle errors with custom properties', () => {
    const error = new Error('Custom error');
    error.statusCode = 418;
    error.custom = 'value';
    
    const serialized = errorSerializer.serializer(error);

    expect(serialized).toEqual({
      code: ErrorCodes.CORE.UNKNOWN,
      message: 'Custom error',
      timestamp: expect.any(String),
      context: {}
    });
  });

  it('should handle null context', () => {
    const error = new Error('Test error');
    const serialized = errorSerializer.serializer(error, null);
    
    expect(serialized).toEqual({
      code: ErrorCodes.CORE.UNKNOWN,
      message: 'Test error',
      timestamp: expect.any(String),
      context: {}
    });
  });
});


// tests/core/errors/types/ErrorTypes.test.js

import {
  AccessError,
  AuthError,
  ConfigError,
  ModuleError,
  NetworkError,
  ServiceError,
  ValidationError,
} from "../../../../src/core/errors/types/index.js";
import * as ErrorTypes from "../../../../src/core/errors/types/index.js";

describe("Error Types", () => {
  describe("Error Type Exports", () => {
    it("should export all expected error classes", () => {
      expect(ErrorTypes).toHaveProperty("AccessError");
      expect(ErrorTypes).toHaveProperty("AuthError");
      expect(ErrorTypes).toHaveProperty("ConfigError");
      expect(ErrorTypes).toHaveProperty("ModuleError");
      expect(ErrorTypes).toHaveProperty("NetworkError");
      expect(ErrorTypes).toHaveProperty("ServiceError");
      expect(ErrorTypes).toHaveProperty("ValidationError");
    });
  });
  describe("ConfigError", () => {
    it("should create ConfigError with correct properties", () => {
      const error = new ConfigError("INVALID_CONFIG", "Invalid configuration", {
        key: "test",
      });
      expect(error.name).toBe("ConfigError");
      expect(error.code).toBe("CONFIG_INVALID_CONFIG");
      expect(error.statusCode).toBe(500);
      expect(error.details).toEqual({ key: "test" });
    });
  });

  describe("ModuleError", () => {
    it("should create ModuleError with correct properties", () => {
      const error = new ModuleError(
        "INIT_FAILED",
        "Module initialization failed",
        { module: "test" }
      );
      expect(error.name).toBe("ModuleError");
      expect(error.code).toBe("MODULE_INIT_FAILED");
      expect(error.statusCode).toBe(500);
      expect(error.details).toEqual({ module: "test" });
    });
  });

  describe("ServiceError", () => {
    it("should create ServiceError with correct properties", () => {
      const error = new ServiceError("SERVICE_DOWN", "Service unavailable", {
        service: "test",
      });
      expect(error.name).toBe("ServiceError");
      expect(error.code).toBe("SERVICE_SERVICE_DOWN");
      expect(error.statusCode).toBe(503);
      expect(error.details).toEqual({ service: "test" });
    });

    it("should handle error cause properly", () => {
      const cause = new Error("Original error");
      const error = new ServiceError("TEST", "Test error", {}, { cause });
      expect(error.cause).toBe(cause);
      const json = error.toJSON();
      expect(json.cause).toBeDefined();
      expect(json.cause.message).toBe("Original error");
    });
  });

  describe("ValidationError", () => {
    test("should handle non-array validation errors in constructor", () => {
      const error = new ValidationError("TEST", "message", {
        validationErrors: "invalid",
      });
      expect(error.validationErrors).toEqual([]);
    });

    test("should handle missing validation errors in fromJSON", () => {
      const error = ValidationError.fromJSON({
        code: "TEST",
        message: "message",
      });
      expect(error.validationErrors).toEqual([]);
    });
    it("should handle various types of validationErrors correctly", () => {
      const err1 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: "not an array",
      });
      expect(err1.validationErrors).toEqual([]);

      const err2 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: 42,
      });
      expect(err2.validationErrors).toEqual([]);

      const err3 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: {},
      });
      expect(err3.validationErrors).toEqual([]);

      const err4 = new ValidationError("INVALID_INPUT", "Invalid input", {});
      expect(err4.validationErrors).toEqual([]);

      const err5 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: null,
      });
      expect(err5.validationErrors).toEqual([]);

      const err6 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: [],
      });
      expect(err6.validationErrors).toEqual([]);

      const err7 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: ["error1", "error2"],
      });
      expect(err7.validationErrors).toEqual(["error1", "error2"]);
    });

    it("should store validation errors when provided", () => {
      const errors = [{ field: "email", message: "Invalid email" }];
      const err = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: errors,
      });
      expect(err.validationErrors).toEqual(errors);
    });

    it("should default to an empty array when validationErrors is not an array", () => {
      const err1 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: "not an array",
      });
      expect(err1.validationErrors).toEqual([]);

      const err2 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: 42,
      });
      expect(err2.validationErrors).toEqual([]);

      const err3 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: {},
      });
      expect(err3.validationErrors).toEqual([]);

      const err4 = new ValidationError("INVALID_INPUT", "Invalid input", {});
      expect(err4.validationErrors).toEqual([]);
    });

    it("should properly serialize and deserialize validation errors", () => {
      const errors = [{ field: "username", message: "Username is required" }];
      const originalError = new ValidationError(
        "MISSING_FIELD",
        "Username is missing",
        { validationErrors: errors }
      );

      const json = originalError.toJSON();
      expect(json.validationErrors).toEqual(errors);

      const recreatedError = ValidationError.fromJSON(json);
      expect(recreatedError.validationErrors).toEqual(errors);
    });
    it("should fallback to an empty array when validationErrors is missing or invalid", () => {
      const err1 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: undefined,
      });
      expect(err1.validationErrors).toEqual([]);

      const err2 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: 42,
      });
      expect(err2.validationErrors).toEqual([]);

      const err3 = new ValidationError("INVALID_INPUT", "Invalid input", {
        validationErrors: {},
      });
      expect(err3.validationErrors).toEqual([]);

      const err4 = new ValidationError("INVALID_INPUT", "Invalid input", {});
      expect(err4.validationErrors).toEqual([]);
    });
    it("should create ValidationError with correct properties", () => {
      const validationErrors = [{ field: "test", message: "Required" }];
      const error = new ValidationError("INVALID_INPUT", "Invalid input data", {
        validationErrors,
      });

      expect(error.name).toBe("ValidationError");
      expect(error.code).toBe("VALIDATION_INVALID_INPUT");
      expect(error.statusCode).toBe(400);
      expect(error.validationErrors).toEqual(validationErrors);
    });

    it("should handle empty validation errors", () => {
      const error = new ValidationError("TEST", "Test error");
      expect(error.validationErrors).toEqual([]);
    });

    it("should properly serialize and deserialize validation errors", () => {
      const validationErrors = [{ field: "test", message: "Required" }];
      const error = new ValidationError("TEST", "Test error", {
        validationErrors,
      });

      const json = error.toJSON();
      expect(json.validationErrors).toEqual(validationErrors);

      const restored = ValidationError.fromJSON(json);
      expect(restored.validationErrors).toEqual(validationErrors);
    });
  });

  describe("NetworkError", () => {
    it("should create NetworkError with correct properties", () => {
      const error = new NetworkError(
        "REQUEST_FAILED",
        "Network request failed",
        {
          url: "http://test.com",
          statusCode: 404,
        }
      );
      expect(error.name).toBe("NetworkError");
      expect(error.code).toBe("NETWORK_REQUEST_FAILED");
      expect(error.statusCode).toBe(404);
      expect(error.details).toEqual({
        url: "http://test.com",
        statusCode: 404,
      });
    });

    it("should use default status code if not provided", () => {
      const error = new NetworkError(
        "REQUEST_FAILED",
        "Network request failed"
      );
      expect(error.statusCode).toBe(503);
    });
  });

  describe("AuthError", () => {
    it("should create AuthError with correct properties", () => {
      const error = new AuthError(
        "INVALID_TOKEN",
        "Invalid authentication token",
        { token: "test" }
      );
      expect(error.name).toBe("AuthError");
      expect(error.code).toBe("AUTH_INVALID_TOKEN");
      expect(error.statusCode).toBe(401);
      expect(error.details).toEqual({ token: "test" });
    });
  });

  describe("AccessError", () => {
    it("should create AccessError with correct properties", () => {
      const error = new AccessError("FORBIDDEN", "Access denied", {
        resource: "test",
      });
      expect(error.name).toBe("AccessError");
      expect(error.code).toBe("ACCESS_FORBIDDEN");
      expect(error.statusCode).toBe(403);
      expect(error.details).toEqual({ resource: "test" });
    });
  });

  describe("Error Creation with Options", () => {
    const errorTypes = [
      { Type: AccessError, prefix: "ACCESS" },
      { Type: AuthError, prefix: "AUTH" },
      { Type: ConfigError, prefix: "CONFIG" },
      { Type: ModuleError, prefix: "MODULE" },
      { Type: NetworkError, prefix: "NETWORK" },
      { Type: ServiceError, prefix: "SERVICE" },
      { Type: ValidationError, prefix: "VALIDATION" },
    ];

    test.each(errorTypes)(
      "should create $Type.name with cause",
      ({ Type, prefix }) => {
        const cause = new Error("Cause error");
        const error = new Type("TEST", "Test message", {}, { cause });

        expect(error.code).toBe(`${prefix}_TEST`);
        expect(error.cause).toBe(cause);

        const json = error.toJSON();
        expect(json.cause).toBeDefined();
        expect(json.cause.message).toBe("Cause error");
      }
    );
  });
});


// tests/core/errors/types/index.test.js

import * as ErrorTypes from '../../../../src/core/errors/types/index.js';
import { 
  AccessError,
  AuthError,
  ConfigError,
  ModuleError,
  NetworkError,
  ServiceError,
  ValidationError
} from '../../../../src/core/errors/types/index.js';

describe('Error Types Index', () => {
  test('should export all error types both as namespace and individual exports', () => {
    // Test namespace exports
    expect(ErrorTypes.AccessError).toBeDefined();
    expect(ErrorTypes.AuthError).toBeDefined();
    expect(ErrorTypes.ConfigError).toBeDefined();
    expect(ErrorTypes.ModuleError).toBeDefined();
    expect(ErrorTypes.NetworkError).toBeDefined();
    expect(ErrorTypes.ServiceError).toBeDefined();
    expect(ErrorTypes.ValidationError).toBeDefined();

    // Test individual exports
    expect(AccessError).toBeDefined();
    expect(AuthError).toBeDefined();
    expect(ConfigError).toBeDefined();
    expect(ModuleError).toBeDefined();
    expect(NetworkError).toBeDefined();
    expect(ServiceError).toBeDefined();
    expect(ValidationError).toBeDefined();

    // Verify they are the same
    expect(AccessError).toBe(ErrorTypes.AccessError);
    expect(AuthError).toBe(ErrorTypes.AuthError);
    expect(ConfigError).toBe(ErrorTypes.ConfigError);
    expect(ModuleError).toBe(ErrorTypes.ModuleError);
    expect(NetworkError).toBe(ErrorTypes.NetworkError);
    expect(ServiceError).toBe(ErrorTypes.ServiceError);
    expect(ValidationError).toBe(ErrorTypes.ValidationError);
  });

  test('should create instances of each error type', () => {
    expect(new AccessError('TEST', 'message')).toBeInstanceOf(AccessError);
    expect(new AuthError('TEST', 'message')).toBeInstanceOf(AuthError);
    expect(new ConfigError('TEST', 'message')).toBeInstanceOf(ConfigError);
    expect(new ModuleError('TEST', 'message')).toBeInstanceOf(ModuleError);
    expect(new NetworkError('TEST', 'message')).toBeInstanceOf(NetworkError);
    expect(new ServiceError('TEST', 'message')).toBeInstanceOf(ServiceError);
    expect(new ValidationError('TEST', 'message')).toBeInstanceOf(ValidationError);
  });
});


// tests/index.test.js

// tests/index.test.js

import { ErrorTypes } from '../src/core/errors/types/index.js';
import { CoreError } from '../src/core/errors/Error.js';
import { ErrorCodes } from '../src/core/errors/index.js';

describe('Error System Integration', () => {
    describe('Error Types Export', () => {
        test('should export all error types', () => {
            expect(ErrorTypes.AccessError).toBeDefined();
            expect(ErrorTypes.AuthError).toBeDefined();
            expect(ErrorTypes.ConfigError).toBeDefined();
            expect(ErrorTypes.ModuleError).toBeDefined();
            expect(ErrorTypes.NetworkError).toBeDefined();
            expect(ErrorTypes.ServiceError).toBeDefined();
            expect(ErrorTypes.ValidationError).toBeDefined();
        });
    });

    describe('Error System Interaction', () => {
        test('all error types should extend CoreError', () => {
            Object.values(ErrorTypes).forEach(ErrorType => {
                const error = new ErrorType('TEST', 'Test message');
                expect(error).toBeInstanceOf(CoreError);
                expect(error).toBeInstanceOf(Error);
            });
        });

        test('error codes should be properly formatted', () => {
            Object.entries(ErrorTypes).forEach(([name, ErrorType]) => {
                const prefix = name.replace('Error', '').toUpperCase();
                const error = new ErrorType('TEST_CODE', 'Test message');
                expect(error.code).toBe(`${prefix}_TEST_CODE`);
            });
        });

        test('should handle error cause properly', () => {
            const cause = new Error('Original error');
            Object.values(ErrorTypes).forEach(ErrorType => {
                const error = new ErrorType('TEST', 'Test message', {}, { cause });
                expect(error.cause).toBe(cause);
                const json = error.toJSON();
                expect(json.cause).toBeDefined();
                expect(json.cause.message).toBe('Original error');
            });
        });
    });

    describe('Error Codes Integration', () => {
        test('should have valid error codes for each error type', () => {
            // Test that error codes exist for all error types
            Object.keys(ErrorTypes).forEach(type => {
                const baseType = type.replace('Error', '').toUpperCase();
                expect(ErrorCodes[baseType]).toBeDefined();
                expect(typeof ErrorCodes[baseType]).toBe('object');
            });
        });
    });
});


// server.js

import 'dotenv/config';

const { NODE_ENV = "development", PORT = 3000 } = process.env;
console.time("Start");

let address;

async function startServer() {
  if (NODE_ENV === "production") {
    const { buildApp } = await import("./dist/app.js");
    const app = await buildApp();
    address = await app.listen({ port: '3001', host: '0.0.0.0' });
  } else {
    const { once } = await import("events");
    const { createServer } = await import("vite");
    let appInstance;  // Store the built app instance

    const devServer = await createServer({
      appType: "custom",
      server: { middlewareMode: true },
    });

    const server = devServer.middlewares
      .use(async (req, res, next) => {
        try {
          if (!appInstance) {
            console.log('Building app for the first time.');
            const { buildApp } = await devServer.ssrLoadModule("./src/app.js");
            appInstance = await buildApp();
            await appInstance.ready();
          }

          console.log('Routing request:', req.url);
          appInstance.routing(req, res);
        } catch (err) {
          console.error('Error during request handling:', err);
          return next(err);
        }
      })
      .listen(PORT);

    await once(server, "listening");
    address = `http://localhost:${server.address().port}`;

    // Listen for file changes to trigger a rebuild
    devServer.watcher.on('change', (file) => {
      console.log(`File changed: ${file}. Rebuilding app...`);
      appInstance = null;  // This will trigger a rebuild on the next request
      console.log(`App rebuilt`);
    });
  }

  console.timeEnd("Start");
  console.log(`Env: ${NODE_ENV}`);
  console.log(`Address: ${address}`);
}

startServer().catch((err) => {
  console.error('Failed to start server:', err);
  process.exit(1);
});


// vite.config.js

import { defineConfig } from "vite";
import marko from "@marko/vite";
//import { resolve } from "path";

export default defineConfig({
  //root: resolve(__dirname, "src"),
  plugins: [marko()],
  build: {
    sourcemap: true, // Generate sourcemaps for all builds.
    emptyOutDir: false, // Avoid server & client deleting files from each other.
    outDir: "./dist",
  },
});


// .env

NODE_ENV="development"
PORT="3000"

DATABASE_URL='postgres://postgres:Magarao12@localhost:5432/tsmis_dev'
JWT_SECRET="hgtrh3rthhymn^^7(@jytj00*hh765y"

IPREGISTRY_API_KEY="zo2l5bcj3o5hp0"


MAIL_HOST="smtp.gmail.com"
MAIL_PORT="465"
MAIL_SECURE="true"
MAIL_USER="torosminfo@gmail.com"
MAIL_PASS="oaor cyav zijk nlqn"

HARDCODE_MODULES=false


// package.json

{
    "name": "tsmis",
    "type": "module",
    "description": "toro_sm information system",
    "version": "1.0.0",
    "dependencies": {
        "@fastify/compress": "^7.0.3",
        "@fastify/cookie": "^9.3.1",
        "@fastify/csrf-protection": "^6.4.1",
        "@fastify/formbody": "^7.4.0",
        "@fastify/helmet": "^11.1.1",
        "@fastify/jwt": "^8.0.1",
        "@fastify/postgres": "^5.2.2",
        "@fastify/rate-limit": "^9.1.0",
        "@fastify/static": "^7.0.4",
        "@ipregistry/client": "^6.0.0",
        "@marko/fastify": "^1.1.1",
        "@popperjs/core": "^2.11.8",
        "bcrypt": "^5.1.1",
        "bootstrap": "^5.3.3",
        "dotenv": "^16.4.5",
        "fastify": "^4.28.1",
        "marked": "^14.1.2",
        "marko": "^5.35.8",
        "nodemailer": "^6.9.15"
    },
    "devDependencies": {
        "@babel/core": "^7.26.7",
        "@babel/preset-env": "^7.26.7",
        "@marko/compiler": "^5.37.4",
        "@marko/vite": "^5.0.13",
        "babel-jest": "^29.7.0",
        "cross-env": "^7.0.3",
        "directory-tree-ascii": "^1.0.10",
        "jest": "^29.7.0",
        "postcss-preset-env": "^10.0.6",
        "rimraf": "^6.0.1",
        "sass": "^1.77.4",
        "vite": "^6.0.11"
    },
    "scripts": {
        "build": "rimraf dist && npm run build:server && npm run build:client",
        "build:client": "cross-env NODE_ENV=production vite build",
        "build:server": "cross-env NODE_ENV=production vite build --ssr src/app.js",
        "dev": "node --enable-source-maps server.js",
        "dev:inspect": "node --inspect --enable-source-maps server.js",
        "start": "cross-env NODE_ENV=production node --enable-source-maps server.js",
        "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
        "test:watch": "node --experimental-vm-modules node_modules/jest/bin/jest.js --watch",
        "test:coverage": "node --experimental-vm-modules node_modules/jest/bin/jest.js --coverage"
    }
}

