/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> tsmis@1.0.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ .env
   ├─ babel.config.js
   ├─ coverage
   │  ├─ clover.xml
   │  ├─ coverage-final.json
   │  ├─ lcov-report
   │  │  ├─ base.css
   │  │  ├─ block-navigation.js
   │  │  ├─ container
   │  │  │  ├─ Container.js.html
   │  │  │  └─ index.html
   │  │  ├─ core
   │  │  │  ├─ bootstrap.js.html
   │  │  │  ├─ container
   │  │  │  │  ├─ Container.js.html
   │  │  │  │  └─ index.html
   │  │  │  ├─ errors
   │  │  │  │  ├─ Error.js.html
   │  │  │  │  ├─ ErrorService.js.html
   │  │  │  │  ├─ index.html
   │  │  │  │  ├─ index.js.html
   │  │  │  │  ├─ integrations
   │  │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  │  ├─ fastify
   │  │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  │  ├─ index.html
   │  │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  │  └─ index.html
   │  │  │  │  ├─ manifest.js.html
   │  │  │  │  └─ types
   │  │  │  │     ├─ AccessError.js.html
   │  │  │  │     ├─ AuthError.js.html
   │  │  │  │     ├─ ConfigError.js.html
   │  │  │  │     ├─ ModuleError.js.html
   │  │  │  │     ├─ NetworkError.js.html
   │  │  │  │     ├─ ServiceError.js.html
   │  │  │  │     ├─ ValidationError.js.html
   │  │  │  │     ├─ index.html
   │  │  │  │     └─ index.js.html
   │  │  │  └─ index.html
   │  │  ├─ errors
   │  │  │  ├─ Error.js.html
   │  │  │  ├─ ErrorSystem.js.html
   │  │  │  ├─ index.html
   │  │  │  ├─ index.js.html
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  ├─ fastify
   │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  ├─ index.html
   │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  └─ index.html
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js.html
   │  │  │     ├─ AuthError.js.html
   │  │  │     ├─ ConfigError.js.html
   │  │  │     ├─ ModuleError.js.html
   │  │  │     ├─ NetworkError.js.html
   │  │  │     ├─ ServiceError.js.html
   │  │  │     ├─ ValidationError.js.html
   │  │  │     ├─ index.html
   │  │  │     └─ index.js.html
   │  │  ├─ event
   │  │  │  ├─ EventBus.js.html
   │  │  │  ├─ EventBusSystem.js.html
   │  │  │  └─ index.html
   │  │  ├─ favicon.png
   │  │  ├─ index.html
   │  │  ├─ module
   │  │  │  ├─ Module.js.html
   │  │  │  ├─ ModuleSystem.js.html
   │  │  │  └─ index.html
   │  │  ├─ prettify.css
   │  │  ├─ prettify.js
   │  │  ├─ sort-arrow-sprite.png
   │  │  └─ sorter.js
   │  └─ lcov.info
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ claude_prompt.md
   │  │  ├─ dev_manual.md
   │  │  ├─ dev_roadmap.md
   │  │  └─ technical.md
   │  └─ tools
   │     ├─ combined-files.js
   │     ├─ reverse-files.js
   │     └─ setup-project.js
   ├─ jest.config.mjs
   ├─ package-lock.json
   ├─ package.json
   ├─ server.js
   ├─ src
   │  ├─ app.js
   │  ├─ config
   │  ├─ core
   │  │  ├─ container
   │  │  │  ├─ Container.js
   │  │  │  └─ container-system-docs.md
   │  │  ├─ errors
   │  │  │  ├─ Error.js
   │  │  │  ├─ ErrorSystem.js
   │  │  │  ├─ error-system-docs.md
   │  │  │  ├─ index.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.js
   │  │  │  │     ├─ handler.js
   │  │  │  │     ├─ index.js
   │  │  │  │     └─ serializer.js
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js
   │  │  │     ├─ AuthError.js
   │  │  │     ├─ ConfigError.js
   │  │  │     ├─ ModuleError.js
   │  │  │     ├─ NetworkError.js
   │  │  │     ├─ ServiceError.js
   │  │  │     ├─ ValidationError.js
   │  │  │     └─ index.js
   │  │  ├─ event
   │  │  │  ├─ EventBus.js
   │  │  │  ├─ EventBusSystem.js
   │  │  │  └─ event-bus-docs.md
   │  │  ├─ module
   │  │  │  ├─ Module.js
   │  │  │  ├─ ModuleSystem.js
   │  │  │  └─ module-system-docs.md
   │  │  ├─ service
   │  │  └─ validation
   │  ├─ modules
   │  └─ services
   │     ├─ cache
   │     ├─ database
   │     ├─ email
   │     ├─ ip
   │     └─ logger
   ├─ tests
   │  ├─ core
   │  │  ├─ container
   │  │  │  └─ Container.test.js
   │  │  ├─ errors
   │  │  │  ├─ Error.test.js
   │  │  │  ├─ ErrorSystem.test.js
   │  │  │  ├─ integration.test.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.test.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.test.js
   │  │  │  │     ├─ handler.test.js
   │  │  │  │     └─ serializer.test.js
   │  │  │  └─ types
   │  │  │     ├─ ErrorTypes.test.js
   │  │  │     └─ index.test.js
   │  │  ├─ event
   │  │  │  ├─ EventBus.test.js
   │  │  │  └─ EventBusSystem.test.js
   │  │  └─ module
   │  │     ├─ Module.test.js
   │  │     └─ ModuleSystem.test.js
   │  └─ index.test.js
   └─ vite.config.js

```
*/


// src/app.js

// src/app.js

import 'dotenv/config';
import Fastify from 'fastify';

// Core System Imports
import { CoreContainer } from './core/container/Container.js';
import { createErrorSystem } from './core/errors/ErrorSystem.js';
import { setupErrorHandler } from './core/errors/integrations/fastify/handler.js';
import { createModuleSystem } from './core/module/ModuleSystem.js';
import { createEventBusSystem } from './core/event/EventBusSystem.js';

export async function buildApp() {
  // Create the core container
  const container = new CoreContainer();

  // Register core systems in proper order
  container.register('errorSystem', createErrorSystem);
  container.register('config', () => ({}));
  container.register('eventBusSystem', createEventBusSystem);
  container.register('moduleSystem', createModuleSystem);

  // Create Fastify instance with error serialization
  const fastify = Fastify({
    logger: {
      level: process.env.LOG_LEVEL || 'info',
      serializers: {
        error: (error) => {
          const errorSystem = container.resolve('errorSystem');
          return errorSystem.serializeError(error);
        }
      }
    }
  });

  // Setup Fastify error handling - THIS LINE IS PRESENT
  setupErrorHandler(fastify);

  // Initialize the container
  try {
    await container.initialize();
  } catch (error) {
    console.error('Container initialization error:', error);
    throw error;
  }

  // Basic route as a health check
  fastify.get('/', async (request, reply) => {
    return { 
      status: 'ok', 
      timestamp: new Date().toISOString() 
    };
  });

  // Graceful shutdown handling
  const closeHandler = async () => {
    try {
      await fastify.close();
      await container.shutdown();
    } catch (error) {
      console.error('Shutdown error:', error);
    }
  };

  // Handle shutdown signals
  process.on('SIGINT', closeHandler);
  process.on('SIGTERM', closeHandler);
  fastify.addHook('onClose', async () => {
    await container.shutdown();
  });

  return fastify;
}


// src/core/container/Container.js

// src/core/container/Container.js

import { EventEmitter } from 'events';
import { CoreError, ConfigError, ServiceError } from '../errors/index.js';
// import { ValidationService } from '../validation/ValidationService.js';

export class CoreContainer extends EventEmitter {
  constructor() {
    super();
    this.components = new Map();
    this.instances = new Map();
    this.dependencies = new Map();
    this.manifests = new Map();
    this.initialized = false;
  }

  /**
   * Register a component manifest
   * @param {string} type - Component type
   * @param {object} manifest - Component manifest
   */
  registerManifest(type, manifest) {
    if (this.manifests.has(type)) {
      throw new ConfigError(
        'DUPLICATE_MANIFEST',
        `Manifest already registered for type: ${type}`
      );
    }
    this.manifests.set(type, manifest);
    this.emit('manifest:registered', { type, manifest });
  }

  /**
   * Register a component with the container
   * @param {string} name - Component name
   * @param {Class} Component - Component constructor
   * @param {object} options - Registration options
   */
  register(name, Component, options = {}) {
    if (this.components.has(name)) {
      throw new ConfigError(
        'DUPLICATE_COMPONENT',
        `Component ${name} is already registered`
      );
    }

    // Store component definition
    this.components.set(name, {
      Component,
      options: {
        singleton: true,
        ...options
      }
    });

    // Store dependencies
    this.dependencies.set(name, Component.dependencies || []);

    this.emit('component:registered', { name, Component });
    return this;
  }

  /**
   * Discover components in a directory
   * @param {string} type - Component type
   * @param {string} basePath - Base directory path
   */
  async discover(type, basePath) {
    if (!this.manifests.has(type)) {
      throw new ConfigError(
        'INVALID_TYPE',
        `No manifest registered for type: ${type}`
      );
    }

    try {
      const manifest = this.manifests.get(type);
      const componentPaths = await this.scanDirectory(basePath);
      const discoveredComponents = new Map();

      for (const path of componentPaths) {
        try {
          const component = await this.loadComponent(path, manifest);
          if (component) {
            discoveredComponents.set(component.name, component);
          }
        } catch (error) {
          this.emit('discovery:error', { path, error });
        }
      }

      this.emit('discovery:completed', { type, components: discoveredComponents });
      return discoveredComponents;
    } catch (error) {
      throw new ServiceError(
        'DISCOVERY_FAILED',
        `Failed to discover ${type} components`,
        { originalError: error }
      );
    }
  }

  /**
   * Load a component from a path
   * @private
   */
  async loadComponent(path, manifest) {
    try {
      const config = await this.loadConfig(path);
      if (config.enabled === false) return null;

      await this.validateConfig(config, manifest.configSchema);
      const implementation = await this.loadImplementation(path);

      return {
        name: config.name,
        config,
        implementation
      };
    } catch (error) {
      throw new ConfigError(
        'LOAD_FAILED',
        `Failed to load component from ${path}`,
        { originalError: error }
      );
    }
  }

  /**
   * Get an instance of a component
   * @param {string} name - Component name
   */
  async resolve(name) {
    if (!this.components.has(name)) {
      throw new ServiceError(
        'UNKNOWN_COMPONENT',
        `Component ${name} is not registered`
      );
    }
  
    const { Component, options } = this.components.get(name);
  
    // Return existing instance for singletons
    if (options.singleton && this.instances.has(name)) {
      return this.instances.get(name);
    }
  
    // Resolve dependencies first
    const deps = this.dependencies.get(name) || [];
    const resolvedDeps = {};
  
    for (const dep of deps) {
      resolvedDeps[dep] = await this.resolve(dep);
    }
  
    // Handle different component types
    let instance;
    if (typeof Component === 'function') {
      if (Component.prototype) {
        // Class constructor
        instance = new Component(resolvedDeps);
      } else {
        // Factory function - handle both sync and async
        instance = await Promise.resolve(Component(resolvedDeps));
      }
    } else {
      instance = Component;
    }
  
    // Initialize if container is initialized
    if (this.initialized && typeof instance.initialize === 'function') {
      await instance.initialize();
    }
  
    // Cache singleton instance
    if (options.singleton) {
      this.instances.set(name, instance);
    }
  
    this.emit('component:resolved', { name, instance });
    return instance;
  }
  /**
   * Initialize all registered components
   */
  async initialize() {
    if (this.initialized) {
      throw new ServiceError(
        'ALREADY_INITIALIZED',
        'Container is already initialized'
      );
    }
    //console.log('Initializing Container...');
    const order = this.resolveDependencyOrder();

    for (const name of order) {
      //console.log(`Resolving component: ${name}`);
      const instance = await this.resolve(name);
      if (typeof instance.initialize === 'function') {
        //console.log(`Initializing component: ${name}`);
        await instance.initialize();
      }
    }

    this.initialized = true;
    this.emit('initialized');

    
  }

  /**
   * Resolve dependency order for initialization
   * @private
   */
  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ConfigError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected: ${name}`
        );
      }

      visiting.add(name);
      
      const component = this.components.get(name);
      const deps = this.dependencies.get(name) || [];
      
      for (const dep of deps) {
        if (!this.components.has(dep)) {
          throw new ConfigError(
            'MISSING_DEPENDENCY',
            `Dependency ${dep} required by ${name} is not registered`
          );
        }
        visit(dep);
      }
      
      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    // Ensure core systems are initialized first
    const initOrder = [
      'errorSystem',
      'config',
      'eventBusSystem',
      'moduleSystem'
    ];

    for (const name of initOrder) {
      if (this.components.has(name)) {
        visit(name);
      }
    }

    // Then handle any remaining components
    for (const name of this.components.keys()) {
      if (!order.includes(name)) {
        visit(name);
      }
    }

    return order;
  }

async shutdown() {
    // Shutdown in reverse dependency order
    const order = this.resolveDependencyOrder().reverse();
  
    for (const name of order) {
      const instance = this.instances.get(name);
      if (instance && typeof instance.shutdown === 'function') {
        try {
          await instance.shutdown();
        } catch (error) {
          // Log error but continue shutdown process
          this.emit('shutdown:error', { 
            component: name, 
            error 
          });
        }
      }
    }
  
    this.instances.clear();
    this.initialized = false;
    this.emit('shutdown');
  }
}


// src/core/container/container-system-docs.md

# CoreContainer System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Core Concepts](#core-concepts)
5. [Installation](#installation)
6. [Usage](#usage)
7. [Advanced Features](#advanced-features)
8. [Best Practices](#best-practices)
9. [Extending the System](#extending-the-system)
10. [Troubleshooting](#troubleshooting)

## Overview

The CoreContainer System is a sophisticated Dependency Injection (DI) and Inversion of Control (IoC) container designed to manage component lifecycles, dependencies, and system initialization. It is responsible for managing the lifecycle and dependencies of the core systems and components in the application, including the ErrorSystem, ModuleSystem, and other registered components.


## Purpose

The primary goals of the CoreContainer System are to:
- Manage component dependencies
- Facilitate loose coupling between system components
- Automate component initialization and shutdown
- Provide a centralized component registry
- Support complex dependency graphs

## System Architecture

### Core Components

1. **CoreContainer** (`src/core/container/Container.js`)
   - Central component management system
   - Handles component registration
   - Manages dependency resolution
   - Controls component lifecycle

### Architecture Diagram

```mermaid
graph TD
    A[CoreContainer] --> B[Component Registration]
    A --> C[Dependency Resolution]
    A --> D[Lifecycle Management]
    
    B --> E[Singleton/Transient Components]
    B --> F[Dependency Tracking]
    
    C --> G[Topological Sorting]
    C --> H[Circular Dependency Detection]
    
    D --> I[Initialization]
    D --> J[Shutdown]
    D --> K[Event Emission]
```

## Core Concepts

### Component Registration

- Components can be registered with optional configuration
- Supports singleton and transient component modes
- Tracks component dependencies
- Supports class and factory function registration

### Dependency Resolution

- Automatically resolves and injects dependencies
- Supports complex dependency graphs
- Prevents circular dependencies
- Ensures correct initialization order

### Lifecycle Management

- Provides `initialize()` and `shutdown()` methods
- Supports component-specific initialization logic
- Graceful shutdown with error handling

### Component Discovery

- Supports component discovery through manifest registration
- Allows for dynamic component loading based on manifests

## Installation

```bash
npm install @your-org/core-container-system
```

## Usage

### Basic Component Registration

```javascript
import { CoreContainer } from '@your-org/core-container-system';

// Class registration
class LoggerService {}

container.register('logger', LoggerService);

// Factory function registration
const createDatabaseService = (deps) => {
  return {
    query: () => { /* ... */ }
  };
};

container.register('database', createDatabaseService);
```

### Singleton vs Transient Components

```javascript
// Singleton registration (default)
container.register('service', ServiceClass);

// Transient registration
container.register('repository', RepositoryClass, { singleton: false });
```

### Advanced Dependency Injection

```javascript
class AuthService {
  constructor(deps) {
    this.database = deps.database;
    this.logger = deps.logger;
  }
}

container.register('auth', AuthService);
```

### Component Discovery with Manifests

```javascript
// Register a component manifest
container.registerManifest('service', {
  configSchema: {
    /* ... */
  }
});

// Discover components based on the manifest
await container.discover('service', './services');
```

### Initialization Process

The `CoreContainer.initialize` method is responsible for initializing the registered components in the correct dependency order. It performs the following steps:

1. Resolves the dependency order of the registered components.
2. Iterates over the components in the resolved order.
3. Resolves each component using the `CoreContainer.resolve` method.
4. If the resolved component has an `initialize` method, it calls component.initialize() to initialize the component.

During this process, the `ErrorSystem`, `ModuleSystem`, and any other registered components that have an initialize method are initialized

### Shutdown Process

The `CoreContainer.shutdown` method is responsible for shutting down the initialized components in the reverse dependency order. It performs the following steps:

1. Resolves the dependency order of the initialized components.
2. Iterates over the components in the reverse order.
3. If the component has a `shutdown` method, it calls component.shutdown() to shut down the component.

During this process, the `ErrorSystem`, `ModuleSystem`, and any other initialized components with a shutdown method are properly shut down.

### Component Registration

Components, including the core systems like `ErrorSystem` and `ModuleSystem`, are registered with the `CoreContainer` using the `CoreContainer.register` method. The registration process involves providing a unique name for the component and either a constructor function or a factory function that creates an instance of the component.

The `ErrorSystem` and `ModuleSystem` are typically registered as factory functions in the buildApp function of src/app.js

```javascript
const errorSystemFactory = () => {
  return createErrorSystem({
    logger: console
  });
};
container.register('errorSystem', errorSystemFactory);

const moduleSystemFactory = (deps) => {
  return createModuleSystem(deps);
};
container.register('moduleSystem', moduleSystemFactory);
```

## Advanced Features

### Event Handling

```javascript
container.on('component:registered', ({ name, component }) => {
  console.log(`Component ${name} registered`);
});
```

### Dependency Injection Modes

- Constructor injection
- Factory function injection

## Best Practices

1. Declare component dependencies explicitly
2. Use interfaces for dependency contracts
3. Register components with clear names
4. Use singleton components judiciously
5. Handle initialization and shutdown properly

## Extending the System

### Custom Component Lifecycle

```javascript
class CustomComponent {
  async initialize() {
    // Custom initialization
  }

  async shutdown() {
    // Custom cleanup
  }
}
```

### Custom Component Discovery

```javascript
container.registerManifest('repository', {
  configSchema: {
    /* ... */
  },
  async discover(container) {
    // Custom discovery logic
  }
});
```

## Troubleshooting

### Common Issues

- Circular dependencies
- Incorrect component registration
- Missing dependencies during resolution

### Debugging Tips

- Use `container.on('error', ...)` to catch container errors
- Inspect the container's `components` and `dependencies` maps
- Use `container.resolve(name)` to manually resolve components

## Limitations

- No support for dynamic component replacement
- Limited support for async factory functions
- No built-in support for scoped containers

## Future Roadmap

- [ ] Async component initialization
- [ ] Scoped container support
- [ ] Dynamic component replacement
- [ ] Improved error handling and diagnostics

## Contributing

Contributions are welcome! Please follow the guidelines in CONTRIBUTING.md.

## License

[Your License Information]


// src/core/errors/Error.js

/**
 * Universal base error class for both client and server environments
 * @extends Error
 */
export class CoreError extends Error {
  /**
   * Create a new CoreError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(message);
    
    // Basic properties
    this.name = this.constructor.name;
    this.code = code;
    this.details = this.sanitizeDetails(details);
    this.timestamp = new Date().toISOString();

      //Debug line 29
      // console.log('Line 29 debug:', {
      //   hasOptions: options !== undefined,
      //   hasCause: options?.cause !== undefined,
      //   causeValue: options?.cause
      // });

    // Handle error cause
    this.initCause(options?.cause);
    
    // Ensure instanceof works correctly
    Object.setPrototypeOf(this, new.target.prototype);
    
    // Capture stack trace if available
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Format stack for browser environment
    if (this.isClientEnvironment()) {
      this.stack = this.formatStackTrace(this.stack);
    }
  }

  /**
   * Initialize error cause with proper error instance
   * @private
   */
  initCause(cause) {
    const ensureValidName = (error) => {
      // Reset to 'Error' if name is empty or only whitespace
      if (!error.name || !error.name.trim()) {
        error.name = 'Error';
      }
      return error;
    };
  
    if (cause instanceof Error) {
      this.cause = ensureValidName(cause);
    } else if (cause && typeof cause === 'object') {
      const error = new Error(cause.message || JSON.stringify(cause));
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        error.name = cause.name;
      }
      this.cause = error;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause);
    }
  }

  /**
   * Sanitize error details for safe serialization
   * @private
   */
  sanitizeDetails(details) {
    try {
      // Test if details can be safely serialized
      JSON.stringify(details);
      return details;
    } catch (error) {
      // If serialization fails, return safe version
      return { 
        error: 'Details contained non-serializable values',
        safeDetails: String(details)
      };
    }
  }

  /**
   * Format stack trace for better readability
   * @private
   */
  formatStackTrace(stack) {
    if (!stack) return stack;
    
    return stack
      .split('\n')
      .filter(line => line.trim())
      .map(line => line.replace(/^ {4}at /, ''))
      .join('\n');
  }

  /**
   * Check if running in client environment
   * @private
   */
  isClientEnvironment() {
    return typeof window !== 'undefined';
  }

  /**
   * Check if running in development environment
   * @private
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';
    }
    return this.isClientEnvironment() && window.ENV === 'development';
  }

  /**
   * Convert error to JSON format
   */
  toJSON() {
    const json = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp
    };
  
    // Only include stack if it exists AND we're in dev
    if (this.isDevEnvironment() && this.stack) {
      json.stack = this.stack;
    }
  
    // Include cause if present
    if (this.cause) {
      json.cause = {
        message: this.cause.message,
        name: this.cause.name || 'Error'
      };
      
      // Only include cause stack if it exists AND we're in dev
      if (this.isDevEnvironment() && this.cause.stack) {
        json.cause.stack = this.cause.stack;
      }
    }
  
    return json;
  }

  /**
   * Create error instance from JSON data
   * @static
   */
  static fromJSON(data) {
    const options = {};
    
    if (data.cause) {
      if (typeof data.cause === 'string') {
        options.cause = data.cause;
      } else {
        options.cause = {
          message: data.cause.message,
          name: data.cause.name
        };
      }
    }

    return new this(
      data.code,
      data.message,
      data.details || {},
      options
    );
  }
}


// src/core/errors/ErrorSystem.js

// src/core/errors/ErrorSystem.js

import { EventEmitter } from 'events';
import { CoreError } from './Error.js';
import { ErrorTypes } from './types/index.js';
import { FastifyIntegration } from './integrations/fastify/FastifyIntegration.js';

export class ErrorSystem extends EventEmitter {
  static dependencies = ['logger'];

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.logger = deps.logger || console;
    this.integrations = new Map();
    this.handlers = new Map();
    this.errorTypes = new Map(Object.entries(ErrorTypes));
    this.initialized = false;

      // Ensure a default handler is always present
  this.registerHandler('*', this.defaultErrorHandler.bind(this));
  }

  async initialize() {
    if (this.initialized) {
      throw new Error('Already initialized');
    }

    // Register default handler
    this.registerHandler('*', this.defaultErrorHandler.bind(this));
    
    // Validate error types
    for (const [name, ErrorType] of this.errorTypes) {
      if (!(ErrorType.prototype instanceof CoreError)) {
        throw new CoreError('INVALID_ERROR_TYPE', `Error type ${name} must extend CoreError`);
      }
    }

    this.initialized = true;
    this.emit('initialized');
  }

  registerIntegration(framework, options = {}) {
    if (!framework) {
      throw new CoreError('INVALID_FRAMEWORK', 'Framework is required');
    }

    const integration = new FastifyIntegration();
    integration.initialize(framework, options);
    
    this.integrations.set(framework, integration);
    return integration;
  }

  registerHandler(errorType, handler) {
    if (typeof handler !== 'function') {
      throw new CoreError('INVALID_HANDLER', 'Handler must be a function');
    }
    this.handlers.set(errorType, handler);
  }

  async handleError(error, context = {}) {
    // Ensure we always have a handler
    const handler = this.handlers.get(error.constructor.name) || this.handlers.get('*') || this.defaultErrorHandler;
  
    try {
      await handler(error, context);
      this.emit('error:handled', { error, context });
    } catch (handlerError) {
      this.logger.error('Error handler failed:', handlerError);
      this.emit('error:handler:failed', { error: handlerError, originalError: error });
      throw handlerError;
    }
  }

// Ensure defaultErrorHandler is always a function
defaultErrorHandler(error, context = {}) {
  this.logger.error('Unhandled error:', {
    type: error.constructor.name,
    code: error.code,
    message: error.message,
    details: error.details,
    context
  });
}

  createError(type, code, message, details = {}, options = {}) {
    const ErrorType = this.errorTypes.get(type) || CoreError;
    return new ErrorType(code, message, details, options);
  }

  async shutdown() {
    if (!this.initialized) return;
    
    this.handlers.clear();
    this.integrations.clear();
    this.errorTypes.clear();
    this.removeAllListeners();
    this.initialized = false;
    this.emit('shutdown');
  }
}

// Factory function for container
export function createErrorSystem(deps) {
  return new ErrorSystem(deps);
}


// src/core/errors/error-system-docs.md

# Error System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Error Types](#error-types)
5. [Installation](#installation)
6. [Usage](#usage)
7. [Advanced Features](#advanced-features)
8. [Best Practices](#best-practices)
9. [Extending the System](#extending-the-system)
10. [Troubleshooting](#troubleshooting)

## Overview

The Error System is a comprehensive, extensible error handling framework designed to provide robust, consistent error management across the application.

## Purpose

The primary goals of the Error System are to:
- Standardize error representation
- Provide detailed error context
- Enable flexible error handling
- Support comprehensive error logging and tracking
- Facilitate easier debugging and system observability

## System Architecture

### Core Components

1. **CoreError** (`src/core/errors/Error.js`)
   - Base error class for all custom errors
   - Provides advanced error serialization
   - Handles error cause tracking
   - Supports environment-specific error formatting

2. **ErrorSystem** (`src/core/errors/ErrorSystem.js`)
   - Manages error types and integrations
   - Provides dynamic error handler registration
   - Implements event-driven error handling

3. **Error Types** (`src/core/errors/types/`)
   - Specialized error classes for different domains:
     * AccessError
     * AuthError
     * ConfigError
     * ModuleError
     * NetworkError
     * ServiceError
     * ValidationError

### Architecture Diagram

```mermaid
graph TD
    A[CoreError] --> B[Specialized Error Types]
    A --> C[Error Serialization]
    A --> D[Environment Handling]
    
    E[ErrorSystem] --> F[Error Handler Management]
    E --> G[Integration Registry]
    E --> H[Event Emission]
    
    B --> I[Domain-Specific Errors]
    I --> J[Access Errors]
    I --> K[Authentication Errors]
    I --> L[Configuration Errors]
```

## Error Codes

### Error Code Structure

Error codes are structured to provide clear, hierarchical categorization:

```javascript
ErrorCodes = {
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR'
  },
  // ... other error code categories
}
```

### Using Error Codes

```javascript
import { ErrorCodes, ValidationError } from '@your-org/error-system';

// Using predefined error codes
const validationError = new ValidationError(
  ErrorCodes.VALIDATION.FAILED, 
  'Validation failed',
  { details: 'Specific validation error' }
);
```

## Framework Integration

## Framework Integration

### Fastify Error Handling

The error system provides deep integration with Fastify, automatically handling various error scenarios:

```javascript
// Automatic error mapping
fastify.get('/route', async (request, reply) => {
  // Throws a 404 if route not found
  // Automatically converted to NetworkError
});

// Custom error types are preserved
throw new ValidationError('INVALID_INPUT', 'Validation failed');
```

### Error Mapping Examples

```javascript
// 404 Route Not Found
// Automatically converted to:
NetworkError {
  code: 'NETWORK_ROUTE_NOT_FOUND',
  message: 'Route GET:/test not found',
  statusCode: 404
}

// Validation Error
ValidationError {
  code: 'VALIDATION_FAILED',
  message: 'Invalid input',
  statusCode: 400,
  validationErrors: [...]
}
```

### Error Serialization

- Consistent JSON error format
- Environment-aware error details
- Preserves error context
- Supports custom error types

### Default Error Handling

```javascript
// Fallback error handler always exists
errorSystem.handleError(error, context);
```


## Error Types

### Available Error Types

1. **AccessError**
   - Used for authorization and access control issues
   - Default status code: 403 (Forbidden)

2. **AuthError**
   - Used for authentication-related errors
   - Default status code: 401 (Unauthorized)

3. **ConfigError**
   - Used for configuration and setup errors
   - Default status code: 500 (Internal Server Error)

4. **ModuleError**
   - Used for module system and initialization errors
   - Default status code: 500 (Internal Server Error)

5. **NetworkError**
   - Used for network-related errors
   - Default status code: 503 (Service Unavailable)

6. **ServiceError**
   - Used for service-level errors
   - Default status code: 503 (Service Unavailable)

7. **ValidationError**
   - Used for input validation errors
   - Default status code: 400 (Bad Request)

## Installation

```bash
npm install @your-org/error-system
```

## Usage

### Basic Error Creation

```javascript
import { 
  ValidationError, 
  ErrorCodes 
} from '@your-org/error-system';

// Create a validation error
const validationError = new ValidationError(
  ErrorCodes.VALIDATION.FAILED, 
  'Invalid user input', 
  { 
    validationErrors: [
      { field: 'email', message: 'Invalid email format' }
    ]
  }
);
```

### Error Handling with ErrorSystem

```javascript
import { ErrorSystem } from '@your-org/error-system';

// Create error system
const errorSystem = new ErrorSystem({ logger: customLogger });

// Register a custom error handler
errorSystem.registerHandler('ValidationError', (error, context) => {
  // Custom handling logic
  logger.warn(`Validation failed: ${error.message}`, {
    errors: error.validationErrors,
    context
  });
});

// Handle an error
try {
  // Some operation that might throw an error
} catch (error) {
  await errorSystem.handleError(error);
}
```

## Advanced Features

### Error Cause Tracking

```javascript
const originalError = new Error('Database connection failed');
const wrappedError = new ServiceError(
  'DB_CONNECTION', 
  'Could not connect to database', 
  {}, 
  { cause: originalError }
);
```

### JSON Serialization

```javascript
const error = new ValidationError('INVALID_INPUT', 'Validation failed');
const serializedError = error.toJSON();
// Can be sent over network, logged, etc.
```

## Best Practices

1. Always use specific error types
2. Include detailed context in error details
3. Use error codes for consistent error identification
4. Log errors with sufficient context
5. Handle errors at appropriate levels

## Extending the System

### Creating a Custom Error Type

```javascript
import { CoreError } from '@your-org/error-system';

class CustomDomainError extends CoreError {
  constructor(code, message, details = {}, options = {}) {
    super(`CUSTOM_${code}`, message, details, options);
    this.statusCode = 422; // Custom status code
  }
}
```

## Troubleshooting

### Common Issues

- **Circular Error Handling**: Avoid recursive error handling
- **Over-logging**: Be cautious about logging sensitive information
- **Error Serialization**: Ensure error details are JSON-serializable

## Future Roadmap

- [ ] Enhanced error tracking
- [ ] Distributed tracing support
- [ ] More granular error categorization
- [ ] Performance optimizations

## Contributing

Guidelines for contributing to the Error System will be added in future versions.

## License

[Your License Information]


// src/core/errors/index.js

// src/core/errors/index.js

import { CoreError } from './Error.js';
import { ErrorTypes as TypedErrors, 
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
} from './types/index.js';

// Create complete ErrorTypes including CoreError
export const ErrorTypes = {
    CoreError,
    ...TypedErrors
};

// Export individual error classes
export {
    CoreError,
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

/**
 * Standard error codes
 */
export const ErrorCodes = {
  // Core errors
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },

  // Module related
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    ROUTE: 'ROUTE_ERROR'
  },

  // Service related
  SERVICE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    CONFIGURATION: 'CONFIGURATION_ERROR',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    RUNTIME: 'RUNTIME_ERROR'
  },

  // Configuration related
  CONFIG: {
    VALIDATION: 'VALIDATION_FAILED',
    MISSING: 'MISSING_REQUIRED',
    INVALID: 'INVALID_VALUE'
  },

  // Validation related
  VALIDATION: {
    SCHEMA: 'SCHEMA_VALIDATION_FAILED',
    TYPE: 'INVALID_TYPE',
    REQUIRED: 'REQUIRED_FIELD_MISSING',
    FAILED: 'VALIDATION_FAILED'  // Added for validation errors
  },

  // Network related
  NETWORK: {
    REQUEST: 'REQUEST_FAILED',
    RESPONSE: 'RESPONSE_ERROR',
    TIMEOUT: 'REQUEST_TIMEOUT',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND'  // Added for 404 errors
  },

  // Authentication related
  AUTH: {
    UNAUTHORIZED: 'UNAUTHORIZED',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    INVALID_TOKEN: 'INVALID_TOKEN'
  },

  // Authorization related
  ACCESS: {
    FORBIDDEN: 'FORBIDDEN',
    INSUFFICIENT_RIGHTS: 'INSUFFICIENT_RIGHTS',
    RESOURCE_ACCESS_DENIED: 'RESOURCE_ACCESS_DENIED'
  }
};

export function createErrorFromResponse(response, defaultMessage = 'Unknown error occurred') {
  const errorData = response.data || response;
  
  // Map error names to constructors from ErrorTypes
  const ErrorConstructor = ErrorTypes[errorData.name] || CoreError;

  return new ErrorConstructor(
      errorData.code || ErrorCodes.CORE.UNKNOWN,
      errorData.message || defaultMessage,
      errorData.details || {},
      { cause: response }
  );
}

export default ErrorTypes;


// src/core/errors/integrations/IFrameworkIntegration.js

// src/core/errors/integrations/IFrameworkIntegration.js

/**
 * Interface for framework error integration
 * @interface
 */
export class IFrameworkIntegration {
  /**
   * Initialize error handling for framework
   * @param {any} framework - Framework instance
   * @param {Object} options - Integration options
   */
  initialize(framework, options = {}) {
    throw new Error('initialize() must be implemented');
  }

  /**
   * Serialize error for framework response
   * @param {Error} error - Error to serialize
   * @returns {Object} Serialized error
   */
  serializeError(error) {
    throw new Error('serializeError() must be implemented');
  }

  /**
   * Map framework error to core error
   * @param {Error} frameworkError - Framework-specific error
   * @returns {CoreError} Mapped core error
   */
  mapError(frameworkError) {
    throw new Error('mapError() must be implemented');
  }
}


// src/core/errors/integrations/fastify/FastifyIntegration.js

// src/core/errors/integrations/fastify/FastifyIntegration.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

export class FastifyIntegration extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  async initialize(fastify, options = {}) {
    if (this.initialized) {
      return;
    }

    // Add error context to request
    fastify.addHook('onRequest', async (request) => {
      if (!request) {
        return;
      }
      
      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    // Set error handler
    fastify.setErrorHandler(async (error, request, reply) => {
      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
  }

  mapError(error) {
    // Already our custom error
    if (error instanceof CoreError) {
      return error;
    }

    // Fastify validation errors
    // TODO: Need a network error
    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    // Route not found
    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    // Generic error
    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}


// src/core/errors/integrations/fastify/handler.js

// src/core/errors/integrations/fastify/handler.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

class FastifyErrorHandler extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  initialize(fastify, options = {}) {
    if (this.initialized) {
      return this;
    }

    if (!fastify || typeof fastify.addHook !== 'function') {
      throw new Error('Invalid fastify instance');
    }

    fastify.addHook('onRequest', async (request) => {
      if (!request) return;

      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    fastify.setErrorHandler(async (error, request, reply) => {
      if (!reply || typeof reply.status !== 'function') {
        throw new Error('Invalid reply object');
      }

      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
    return this;
  }

  mapError(error) {
    if (error instanceof CoreError) {
      return error;
    }

    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}

// Create singleton instance
const fastifyErrorHandler = new FastifyErrorHandler();

export function setupErrorHandler(fastify, options = {}) {
  return fastifyErrorHandler.initialize(fastify, options);
}

export { fastifyErrorHandler, FastifyErrorHandler };


// src/core/errors/integrations/fastify/index.js

export { setupErrorHandler } from './handler.js';
export { errorSerializer } from './serializer.js';


// src/core/errors/integrations/fastify/serializer.js

import { fastifyErrorHandler } from './handler.js';

export const errorSerializer = {
  serializer: (error) => fastifyErrorHandler.serializeError(error)
};


// src/core/errors/types/AccessError.js

import { CoreError } from '../Error.js';

/**
 * Authorization and access control related errors
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Create a new AccessError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options);
    this.statusCode = 403;
  }
}


// src/core/errors/types/AuthError.js

import { CoreError } from '../Error.js';

/**
 * Authentication related errors
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Create a new AuthError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options);
    this.statusCode = 401;
  }
}


// src/core/errors/types/ConfigError.js

import { CoreError } from '../Error.js';

/**
 * Configuration related errors
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Create a new ConfigError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/ModuleError.js

import { CoreError } from '../Error.js';

/**
 * Module system related errors
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Create a new ModuleError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/NetworkError.js

import { CoreError } from '../Error.js';

/**
 * Network related errors
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Create a new NetworkError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options);
    // Use provided status code or default to 503
    this.statusCode = details.statusCode || 503;
  }
}


// src/core/errors/types/ServiceError.js

import { CoreError } from '../Error.js';

/**
 * Service related errors
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Create a new ServiceError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options);
    this.statusCode = 503;
  }
}


// src/core/errors/types/ValidationError.js

import { CoreError } from '../Error.js';

/**
 * Validation related errors
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Create a new ValidationError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details with validation errors
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options);
    this.statusCode = 400;
    this.validationErrors = this.validationErrors = Array.isArray(details.validationErrors) ? details.validationErrors : [];
  }

  /**
   * Convert to JSON format with validation errors
   */
  toJSON() {
    const json = super.toJSON();
    json.validationErrors = this.validationErrors;
    return json;
  }

  /**
   * Create from JSON with validation errors
   * @param {Object} data - JSON data
   */
  static fromJSON(data) {
    const error = super.fromJSON(data);
    error.validationErrors = Array.isArray(data.validationErrors) ? data.validationErrors : [];
    return error;
  }
}


// src/core/errors/types/index.js

// src/core/errors/types/index.js

import { AccessError } from './AccessError.js';
import { AuthError } from './AuthError.js';
import { ConfigError } from './ConfigError.js';
import { ModuleError } from './ModuleError.js';
import { NetworkError } from './NetworkError.js';
import { ServiceError } from './ServiceError.js';
import { ValidationError } from './ValidationError.js';

// Export individual error types
export {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Create the ErrorTypes namespace
const ErrorTypes = {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Export ErrorTypes as both named and default export
export { ErrorTypes };
export default ErrorTypes;


// src/core/event/EventBus.js

// src/core/event/EventBus.js

import { EventEmitter } from 'events';
import { CoreError } from '../errors/Error.js';

export class CoreEventBus extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];
  static version = '1.0.0'; // Add version to align with other components

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.queues = new Map();
    this.subscriptions = new Map();
    this.history = new Map();
    this.maxHistorySize = deps.config?.eventHistory?.maxSize || 1000;
    this.initialized = false;
    
    // Enhanced state tracking aligned with other components
    this.state = {
      status: 'created',
      startTime: null,
      metrics: new Map(),
      errors: [],
      healthChecks: new Map()
    };
    
    // Set up health check function map
    this.setupDefaultHealthChecks();
  }

  /**
   * Set up default health checks
   * @private
   */
  setupDefaultHealthChecks() {
    // Register default health check for state
    this.registerHealthCheck('state', async () => {
      return {
        status: this.initialized ? 'healthy' : 'unhealthy',
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        errorCount: this.state.errors.length
      };
    });

    // Register health check for event queues
    this.registerHealthCheck('queues', async () => {
      const queueCounts = {};
      let totalQueuedEvents = 0;
      
      this.queues.forEach((queue, key) => {
        queueCounts[key] = queue.length;
        totalQueuedEvents += queue.length;
      });
      
      return {
        status: 'healthy',
        queueCount: this.queues.size,
        totalQueuedEvents,
        queues: queueCounts
      };
    });

    // Register health check for subscriptions
    this.registerHealthCheck('subscriptions', async () => {
      return {
        status: 'healthy',
        count: this.subscriptions.size,
        patterns: Array.from(this.subscriptions.values()).map(s => s.pattern)
      };
    });
  }

  /**
   * Register a health check function
   * @param {string} name - Health check name
   * @param {Function} checkFn - Health check function
   */
  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
      throw new CoreError(
        'INVALID_HEALTH_CHECK',
        `Health check ${name} must be a function`
      );
    }
    this.state.healthChecks.set(name, checkFn);
  }

  /**
   * Perform health checks
   * @returns {Object} Health check results
   */
  async checkHealth() {
    const results = {};
    let overallStatus = 'healthy';

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        results[name] = await checkFn();
        if (results[name].status !== 'healthy') {
          overallStatus = 'unhealthy';
        }
      } catch (error) {
        results[name] = {
          status: 'error',
          error: error.message
        };
        overallStatus = 'unhealthy';
      }
    }

    return {
      name: 'CoreEventBus',
      version: CoreEventBus.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks: results
    };
  }

  /**
   * Record a metric
   * @param {string} name - Metric name
   * @param {*} value - Metric value
   * @param {Object} tags - Metric tags
   */
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, {
      value,
      timestamp: Date.now(),
      tags
    });
  }

  async initialize() {
    if (this.initialized) {
      throw new CoreError('ALREADY_INITIALIZED', 'EventBus is already initialized');
    }

    try {
      // Initialize event tracking
      this.state.status = 'initializing';
      this.state.startTime = Date.now();

      // Wildcard event support - special handler for '*' pattern
      this.on('newListener', (event) => {
        if (event === '*' && this.listenerCount('*') === 0) {
          const wildcardHandler = (eventName, ...args) => {
            if (eventName !== '*') {
              this.emit('*', eventName, ...args);
            }
          };
          
          // Store the handler to be able to remove it later
          this._wildcardHandler = wildcardHandler;
          
          // Dynamically listen to all events
          this._originalEmit = this.emit;
          this.emit = function(eventName, ...args) {
            const result = this._originalEmit.call(this, eventName, ...args);
            if (eventName !== '*') {
              this._originalEmit.call(this, '*', eventName, ...args);
            }
            return result;
          };
        }
      });

      this.on('removeListener', (event) => {
        if (event === '*' && this.listenerCount('*') === 0) {
          // Restore original emit when no more wildcard listeners
          if (this._originalEmit) {
            this.emit = this._originalEmit;
            this._originalEmit = null;
          }
        }
      });

      this.initialized = true;
      this.state.status = 'running';
      this.emit('system:initialized', {
        timestamp: new Date().toISOString()
      });
      
      // Record initialization metric
      this.recordMetric('eventbus.initialized', 1);
    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message
      });
      await this.handleError(error);
      throw error;
    }
  }

  async handleError(error, context = {}) {
    // Add error to state
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: context || {}
    });
    
    // Trim error history if needed
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }
    
    // Record metric
    this.recordMetric('eventbus.errors', 1, {
      errorType: error.constructor.name,
      errorCode: error.code
    });
    
    // Forward to error system if available
    if (this.deps.errorSystem) {
      await this.deps.errorSystem.handleError(error, {
        source: 'CoreEventBus',
        ...context
      });
    }
  }

  /**
   * Enhanced emit with queuing, history, and pattern matching
   * @param {string} eventName - Event name
   * @param {*} data - Event data
   * @param {Object} options - Emission options
   * @returns {boolean} - Whether the event had listeners
   */
  async emit(eventName, data, options = {}) {
    try {
      const event = {
        id: crypto.randomUUID(),
        name: eventName,
        data,
        timestamp: new Date().toISOString(),
        metadata: options.metadata || {}
      };

      // Store in history
      this.trackEvent(event);

      // Record metric
      this.recordMetric('eventbus.events.emitted', 1, {
        eventName,
        queued: Boolean(options.queue)
      });

      // Handle queuing if needed
      if (options.queue) {
        return this.queueEvent(event, options);
      }

      // Normal event emission
      return super.emit(eventName, event);
    } catch (error) {
      await this.handleError(error, {
        eventName,
        data,
        options
      });
      throw error;
    }
  }

  /**
   * Enhanced subscription with pattern matching support
   * @param {string} pattern - Event pattern (supports * wildcard)
   * @param {Function} handler - Event handler
   * @param {Object} options - Subscription options
   * @returns {string} - Subscription ID
   */
  subscribe(pattern, handler, options = {}) {
    try {
      const subscription = {
        id: crypto.randomUUID(),
        pattern,
        handler,
        options,
        created: new Date().toISOString()
      };

      this.subscriptions.set(subscription.id, subscription);
      
      // Direct pattern match (no wildcards)
      if (!pattern.includes('*')) {
        this.on(pattern, handler);
      } 
      // Wildcard pattern
      else if (pattern === '*') {
        this.on('*', handler);
      }
      // Segment wildcard patterns
      else {
        // For patterns like 'user.*' or '*.created', create a regex matcher
        const regexPattern = new RegExp('^' + pattern.replace(/\./g, '\\.').replace(/\*/g, '.*') + '$');
        
        // Create a handler that checks the pattern
        const patternHandler = (eventName, ...args) => {
          if (regexPattern.test(eventName)) {
            handler(...args);
          }
        };
        
        // Store the reference to the pattern handler
        subscription.patternHandler = patternHandler;
        this.on('*', patternHandler);
      }

      // Record metric
      this.recordMetric('eventbus.subscriptions', 1, {
        pattern
      });

      return subscription.id;
    } catch (error) {
      this.handleError(error, {
        method: 'subscribe',
        pattern,
        options
      });
      throw error;
    }
  }

  /**
   * Unsubscribe from events
   * @param {string} subscriptionId - Subscription ID
   * @returns {boolean} - Whether the subscription was removed
   */
  unsubscribe(subscriptionId) {
    try {
      const subscription = this.subscriptions.get(subscriptionId);
      if (!subscription) {
        return false;
      }

      const { pattern, handler, patternHandler } = subscription;

      // Remove the appropriate handler
      if (!pattern.includes('*')) {
        this.removeListener(pattern, handler);
      } else if (pattern === '*') {
        this.removeListener('*', handler);
      } else if (patternHandler) {
        this.removeListener('*', patternHandler);
      }

      // Remove from subscriptions map
      this.subscriptions.delete(subscriptionId);

      // Record metric
      this.recordMetric('eventbus.unsubscriptions', 1, {
        pattern
      });

      return true;
    } catch (error) {
      this.handleError(error, {
        method: 'unsubscribe',
        subscriptionId
      });
      throw error;
    }
  }

  /**
   * Queue events for delayed processing
   * @param {Object} event - Event object
   * @param {Object} options - Queue options
   * @returns {Promise<boolean>} - Whether the event was queued
   */
  async queueEvent(event, options = {}) {
    try {
      const queue = this.queues.get(event.name) || [];
      const queueItem = {
        event,
        options,
        timestamp: new Date().toISOString()
      };
      
      queue.push(queueItem);
      this.queues.set(event.name, queue);

      // Record metric
      this.recordMetric('eventbus.queued', 1, {
        eventName: event.name,
        queueSize: queue.length
      });

      // Process queue if immediate
      if (options.immediate) {
        await this.processQueue(event.name);
      }
      
      return true;
    } catch (error) {
      await this.handleError(error, {
        method: 'queueEvent',
        event,
        options
      });
      throw error;
    }
  }

  /**
   * Process queued events
   * @param {string} queueName - Queue name
   * @returns {Promise<number>} - Number of processed events
   */
  async processQueue(queueName) {
    try {
      const queue = this.queues.get(queueName) || [];
      let processedCount = 0;
      
      const startTime = Date.now();
      
      while (queue.length > 0) {
        const { event } = queue.shift();
        await super.emit(event.name, event);
        processedCount++;
      }

      this.queues.set(queueName, queue);

      // Record metrics
      this.recordMetric('eventbus.queue.processed', processedCount, {
        queueName,
        processingTime: Date.now() - startTime
      });

      return processedCount;
    } catch (error) {
      await this.handleError(error, {
        method: 'processQueue',
        queueName
      });
      throw error;
    }
  }

  /**
   * Process all queued events
   * @returns {Promise<Object>} - Processing results
   */
  async processAllQueues() {
    try {
      const results = {};
      const queueNames = Array.from(this.queues.keys());
      
      for (const queueName of queueNames) {
        results[queueName] = await this.processQueue(queueName);
      }
      
      return results;
    } catch (error) {
      await this.handleError(error, {
        method: 'processAllQueues'
      });
      throw error;
    }
  }

  /**
   * Track events in history
   * @param {Object} event - Event object
   */
  trackEvent(event) {
    const history = this.history.get(event.name) || [];
    history.unshift(event);

    // Trim history if needed
    if (history.length > this.maxHistorySize) {
      history.pop();
    }

    this.history.set(event.name, history);
    
    // Record metric
    this.recordMetric('eventbus.history.size', history.length, {
      eventName: event.name
    });
  }

  /**
   * Get event history
   * @param {string} eventName - Event name
   * @param {Object} options - History options
   * @returns {Array} - Event history
   */
  getHistory(eventName, options = {}) {
    const history = this.history.get(eventName) || [];
    
    if (options.limit && options.limit > 0) {
      return history.slice(0, options.limit);
    }
    
    return history;
  }

  /**
   * Get all event history
   * @param {Object} options - History options
   * @returns {Object} - All event history
   */
  getAllHistory(options = {}) {
    const result = {};
    
    for (const [eventName, history] of this.history) {
      result[eventName] = options.limit ? history.slice(0, options.limit) : history;
    }
    
    return result;
  }

  /**
   * Clear history and queues
   * @returns {Promise<void>}
   */
  async reset() {
    this.queues.clear();
    this.history.clear();
    
    // Only remove event listeners, keep system listeners
    const eventNames = this.eventNames().filter(name => !name.startsWith('system:'));
    for (const eventName of eventNames) {
      this.removeAllListeners(eventName);
    }
    
    // Record metric
    this.recordMetric('eventbus.reset', 1);
  }

  /**
   * Shutdown the event bus
   * @returns {Promise<void>}
   */
  async shutdown() {
    if (!this.initialized) return;

    try {
      this.state.status = 'shutting_down';
      await this.reset();
      this.initialized = false;
      this.state.status = 'shutdown';
      
      // Final shutdown event
      this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });
      
      // Remove all remaining listeners
      this.removeAllListeners();
      
      // Record metric
      this.recordMetric('eventbus.shutdown', 1);
    } catch (error) {
      this.state.status = 'error';
      await this.handleError(error, { phase: 'shutdown' });
      throw error;
    }
  }
}

// Factory function for container
export function createEventBus(deps = {}) {
  return new CoreEventBus(deps);
}


// src/core/event/EventBusSystem.js

// src/core/event/EventBusSystem.js

import { EventEmitter } from 'events';
import { CoreEventBus } from './EventBus.js';
import { CoreError } from '../errors/Error.js';

export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];

  constructor(deps) {
    super();
    this.deps = deps;
    this.eventBus = null;
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) {
      throw new CoreError('ALREADY_INITIALIZED', 'EventBusSystem is already initialized');
    }

    try {
      // Create and initialize event bus
      this.eventBus = new CoreEventBus(this.deps);
      await this.eventBus.initialize();

      this.initialized = true;
      this.emit('system:initialized', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error);
      throw error;
    }
  }

  async handleError(error, context = {}) {
    if (this.deps.errorSystem) {
      await this.deps.errorSystem.handleError(error, {
        source: 'EventBusSystem',
        ...context
      });
    }
  }

  getEventBus() {
    if (!this.initialized) {
      throw new CoreError('NOT_INITIALIZED', 'EventBusSystem is not initialized');
    }
    return this.eventBus;
  }

  async shutdown() {
    if (!this.initialized) return;

    try {
      await this.eventBus.shutdown();
      this.initialized = false;
      this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error, { phase: 'shutdown' });
      throw error;
    }
  }
}

// Factory function for container
export function createEventBusSystem(deps = {}) {
  return new EventBusSystem(deps);
}


// src/core/event/event-bus-docs.md

# Event Bus System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Core Concepts](#core-concepts)
3. [System Architecture](#system-architecture)
4. [Core Components](#core-components)
5. [State Management](#state-management)
6. [Error Handling](#error-handling)
7. [Event Management](#event-management)
8. [Health Monitoring](#health-monitoring)
9. [System Lifecycle](#system-lifecycle)
10. [Testing Strategy](#testing-strategy)
11. [Best Practices](#best-practices)
12. [Using EventBus in Modules](#using-eventbus-in-modules)
13. [Troubleshooting](#troubleshooting)

## Overview

The EventBus system provides centralized event management and message broker functionality for the TSMIS architecture. It serves as the communication backbone between modules while maintaining system boundaries and proper dependency management. The EventBus enables loose coupling between modules through an event-driven architecture pattern.

### Core Dependencies
```javascript
static dependencies = ['errorSystem', 'config'];
```

### Key Features
- Centralized event management
- Module-to-module communication
- Event history tracking
- Message queuing
- Pattern-based event subscription
- Error handling integration
- Health monitoring
- Metrics tracking

## Core Concepts

### Event-Driven Communication

The EventBus system implements the publish-subscribe pattern (pub/sub) where:
- Publishers emit events without knowledge of subscribers
- Subscribers listen for events without knowledge of publishers
- Events carry data and metadata
- Communication is asynchronous and decoupled

### Core Dependencies

The EventBus system requires two essential dependencies:

```javascript
static dependencies = ['errorSystem', 'config'];
```

#### Dependency Resolution

Dependencies are resolved through one of these methods:

1. **Container Resolution** (primary method)
   - Dependencies are automatically injected by the Container
   - Container manages lifecycle and dependencies

2. **Default Fallbacks** (development/testing)
   - Default implementations for easier testing and development

3. **Explicit Injection**
   - Manual dependency injection for specialized cases

#### Default Fallbacks

```javascript
const defaultDeps = {
  errorSystem: {
    handleError: async () => {} // No-op handler
  },
  config: {
    eventHistory: {
      maxSize: 1000 // Default event history size
    }
  }
};
```

### Event Structure

Events in the system follow a standardized structure:

```javascript
const event = {
  id: crypto.randomUUID(),      // Unique event identifier
  name: eventName,              // Event name (e.g., 'user.created')
  data: payload,                // Event payload
  timestamp: new Date().toISOString(), // Event creation time
  metadata: options.metadata || {}    // Additional metadata
};
```

### Subscription Types

The EventBus supports several types of subscriptions:

1. **Direct Subscriptions**
   - Exact event name match
   ```javascript
   eventBus.subscribe('user.created', handler);
   ```

2. **Wildcard Subscriptions**
   - Match all events
   ```javascript
   eventBus.subscribe('*', handler);
   ```

3. **Pattern-Based Subscriptions**
   - Match events based on patterns
   ```javascript
   eventBus.subscribe('user.*', handler); // All user events
   eventBus.subscribe('*.created', handler); // All creation events
   ```

### Event Queuing

Events can be queued for delayed processing:

```javascript
// Queue event
await eventBus.emit('user.created', userData, { queue: true });

// Process all queued 'user.created' events
await eventBus.processQueue('user.created');

// Process all queued events
await eventBus.processAllQueues();
```

## System Architecture

### Architecture Flow
```mermaid
graph TB
    Container --> EventBusSystem
    EventBusSystem --> CoreEventBus
    
    CoreEventBus --> |Events| ModuleA[Module A]
    CoreEventBus --> |Events| ModuleB[Module B]
    
    ModuleA --> |Emit| CoreEventBus
    ModuleB --> |Emit| CoreEventBus
    
    ErrorSystem --> |Error Handling| CoreEventBus
```

### Integration with Other Systems

The EventBus system integrates with:

1. **ErrorSystem**
   - Error handling and forwarding
   - Error context enrichment
   - Error history management

2. **ModuleSystem**
   - Inter-module communication
   - Module lifecycle events
   - Module health monitoring

3. **CoreContainer**
   - Dependency injection
   - Lifecycle management

## Core Components

### CoreEventBus

The CoreEventBus is the fundamental event handling component:

```javascript
export class CoreEventBus extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];
  static version = '1.0.0';

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.queues = new Map();
    this.subscriptions = new Map();
    this.history = new Map();
    this.maxHistorySize = deps.config?.eventHistory?.maxSize || 1000;
    this.initialized = false;
    this.state = {
      status: 'created',
      startTime: null,
      metrics: new Map(),
      errors: [],
      healthChecks: new Map()
    };
  }

  // Core methods
  async initialize() { /* ... */ }
  async emit(eventName, data, options = {}) { /* ... */ }
  subscribe(pattern, handler, options = {}) { /* ... */ }
  unsubscribe(subscriptionId) { /* ... */ }
  async queueEvent(event, options = {}) { /* ... */ }
  async processQueue(queueName) { /* ... */ }
  async processAllQueues() { /* ... */ }
  async reset() { /* ... */ }
  async shutdown() { /* ... */ }
  
  // Health monitoring
  async checkHealth() { /* ... */ }
  registerHealthCheck(name, checkFn) { /* ... */ }
  
  // History and metrics
  trackEvent(event) { /* ... */ }
  getHistory(eventName, options = {}) { /* ... */ }
  getAllHistory(options = {}) { /* ... */ }
  recordMetric(name, value, tags = {}) { /* ... */ }
}
```

### EventBusSystem

The EventBusSystem manages the CoreEventBus and provides system-level functionality:

```javascript
export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];
  static version = '1.0.0';

  constructor(deps) {
    super();
    this.deps = deps;
    this.eventBus = null;
    this.initialized = false;
    this.state = {
      status: 'created',
      startTime: null,
      metrics: new Map(),
      errors: [],
      healthChecks: new Map()
    };
  }

  // Core methods
  async initialize() { /* ... */ }
  getEventBus() { /* ... */ }
  async shutdown() { /* ... */ }
  
  // Health monitoring
  async checkHealth() { /* ... */ }
  registerHealthCheck(name, checkFn) { /* ... */ }
  
  // Status and metrics
  getStatus() { /* ... */ }
  getMetrics() { /* ... */ }
  recordMetric(name, value, tags = {}) { /* ... */ }
}
```

## State Management

### EventBus States

Both CoreEventBus and EventBusSystem transition through the following states during their lifecycle:

- **created**: Initial state after instantiation
- **initializing**: During initialization process
- **running**: System is active and operational
- **shutting_down**: During shutdown process
- **shutdown**: System is inactive
- **error**: Error state when something fails

### State Tracking

The state object stores comprehensive system metadata:

```javascript
this.state = {
  status: 'created',          // Current system state
  startTime: null,            // When system was started
  errors: [],                 // Error history
  metrics: new Map(),         // Performance metrics
  healthChecks: new Map()     // Health check functions
};
```

### Metrics Tracking

The EventBus system tracks various metrics:

```javascript
// Record a metric
eventBus.recordMetric('events.processed', 42, { 
  eventType: 'user.created',
  source: 'userModule'
});

// Get metrics
const metrics = eventBusSystem.getMetrics();
```

Key metrics include:
- Event emission counts
- Subscription counts
- Queue sizes
- Processing times
- Error counts

## Error Handling

### Error Management

Both CoreEventBus and EventBusSystem include robust error handling:

```javascript
async handleError(error, context = {}) {
  // Add error to state
  this.state.errors.push({
    timestamp: new Date().toISOString(),
    error: error.message,
    context: context || {}
  });
  
  // Trim error history if needed
  if (this.state.errors.length > 100) {
    this.state.errors.shift();
  }
  
  // Record metric
  this.recordMetric('eventbus.errors', 1, {
    errorType: error.constructor.name,
    errorCode: error.code
  });
  
  // Forward to error system if available
  if (this.deps.errorSystem) {
    await this.deps.errorSystem.handleError(error, {
      source: 'CoreEventBus', // or 'EventBusSystem'
      ...context
    });
  }
}
```

### Error Propagation

Errors during event emission are handled gracefully:

```javascript
async emit(eventName, data, options = {}) {
  try {
    // Event emission logic
    // ...
  } catch (error) {
    await this.handleError(error, {
      eventName,
      data,
      options
    });
    throw error;
  }
}
```

### Error Handling in Event Handlers

When implementing event handlers, always use try/catch:

```javascript
eventBus.subscribe('user.created', async (event) => {
  try {
    // Handle event
    await processUser(event.data);
  } catch (error) {
    // Forward to error system
    await module.handleError(error, { 
      event, 
      handler: 'processNewUser' 
    });
  }
});
```

## Event Management

### Event Emission

Events can be emitted with various options:

```javascript
// Basic event emission
await eventBus.emit('user.created', {
  id: 'user-123',
  name: 'John Doe',
  email: 'john@example.com'
});

// Event with metadata
await eventBus.emit('user.created', userData, {
  metadata: {
    source: 'registration-form',
    ip: '192.168.1.1'
  }
});

// Queued event
await eventBus.emit('bulk.process', largeDataset, {
  queue: true
});

// Immediate queue processing
await eventBus.emit('notification.send', notification, {
  queue: true,
  immediate: true
});
```

### Event Subscription

Modules can subscribe to events in several ways:

```javascript
// Direct subscription
const subId = eventBus.subscribe('user.created', handleUserCreated);

// Wildcard subscription (all events)
eventBus.subscribe('*', logAllEvents);

// Pattern subscription (all user events)
eventBus.subscribe('user.*', handleUserEvents);

// Pattern subscription (all creation events)
eventBus.subscribe('*.created', handleCreationEvents);

// Unsubscribe
eventBus.unsubscribe(subId);
```

### Event History

The EventBus maintains a history of emitted events:

```javascript
// Get history for a specific event
const userCreatedEvents = eventBus.getHistory('user.created');

// Limit history results
const recentUserEvents = eventBus.getHistory('user.created', { limit: 10 });

// Get all event history
const allHistory = eventBus.getAllHistory();
```

### Queue Management

Events can be queued and processed in batches:

```javascript
// Process a specific queue
await eventBus.processQueue('email.send');

// Process all queues
await eventBus.processAllQueues();
```

## Health Monitoring

### Health Check Implementation

The EventBus system includes comprehensive health monitoring:

```javascript
// Register a custom health check
eventBus.registerHealthCheck('connection', async () => {
  const connected = await checkConnection();
  return {
    status: connected ? 'healthy' : 'unhealthy',
    details: { connected }
  };
});

// Get health status
const health = await eventBus.checkHealth();
```

### Default Health Checks

CoreEventBus includes these default health checks:

1. **state**: System state check
   - Checks if the system is initialized and running
   - Reports uptime and error count

2. **queues**: Queue health check
   - Reports queue sizes and total queued events
   - Monitors for queue buildup

3. **subscriptions**: Subscription check
   - Reports subscription count and patterns
   - Ensures event handlers are registered

### Health Check Results

Health check results follow a consistent format:

```javascript
{
  name: 'CoreEventBus',
  version: '1.0.0',
  status: 'healthy', // or 'unhealthy', 'error'
  timestamp: '2024-03-27T12:34:56.789Z',
  checks: {
    state: {
      status: 'healthy',
      uptime: 3600000, // ms
      errorCount: 0
    },
    queues: {
      status: 'healthy',
      queueCount: 2,
      totalQueuedEvents: 10,
      queues: {
        'email.send': 8,
        'notification.push': 2
      }
    },
    subscriptions: {
      status: 'healthy',
      count: 5,
      patterns: ['user.created', 'user.updated', 'system.*', '*', 'email.*']
    }
  }
}
```

## System Lifecycle

### Initialization

The EventBusSystem initialization process:

```javascript
async initialize() {
  if (this.initialized) {
    throw new CoreError('ALREADY_INITIALIZED', 'EventBusSystem is already initialized');
  }

  try {
    // Validate dependencies
    this.validateDependencies();
    
    // Update state
    this.state.status = 'initializing';
    this.state.startTime = Date.now();

    // Create and initialize event bus
    this.eventBus = new CoreEventBus(this.deps);
    await this.eventBus.initialize();

    // Forward eventBus events to the system
    this.eventBus.on('system:*', (event) => {
      this.emit(event.name, event);
    });

    this.initialized = true;
    this.state.status = 'running';
    
    // Emit initialization event
    this.emit('system:initialized', {
      timestamp: new Date().toISOString()
    });
    
    // Record metric
    this.recordMetric('eventbussystem.initialized', 1);
    
    return this;
  } catch (error) {
    this.state.status = 'error';
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message
    });
    await this.handleError(error);
    throw error;
  }
}
```

### Shutdown

The EventBusSystem shutdown process:

```javascript
async shutdown() {
  if (!this.initialized) return;

  try {
    this.state.status = 'shutting_down';
    
    // Shutdown eventBus
    if (this.eventBus) {
      await this.eventBus.shutdown();
    }
    
    this.initialized = false;
    this.eventBus = null;
    this.state.status = 'shutdown';
    
    // Emit shutdown event
    this.emit('system:shutdown', {
      timestamp: new Date().toISOString()
    });
    
    // Record metric
    this.recordMetric('eventbussystem.shutdown', 1);
    
    return this;
  } catch (error) {
    this.state.status = 'error';
    await this.handleError(error, { phase: 'shutdown' });
    throw error;
  }
}
```

### Container Registration

Register the EventBusSystem with the container in your application:

```javascript
// src/app.js
import { createEventBusSystem } from './core/event/EventBusSystem.js';

// Register with container
container.register('eventBusSystem', createEventBusSystem);

// Registration order
container.register('errorSystem', createErrorSystem);
container.register('config', () => ({}));
container.register('eventBusSystem', createEventBusSystem);
container.register('moduleSystem', createModuleSystem);
```

## Testing Strategy

### EventBus Testing

Example of testing the CoreEventBus:

```javascript
describe('CoreEventBus', () => {
  let eventBus;
  let mockErrorSystem;
  
  beforeEach(() => {
    // Create mock dependencies
    mockErrorSystem = {
      handleError: jest.fn()
    };
    
    // Create EventBus instance
    eventBus = new CoreEventBus({
      errorSystem: mockErrorSystem,
      config: {
        eventHistory: {
          maxSize: 5
        }
      }
    });
  });
  
  afterEach(() => {
    // Clean up
    if (eventBus.initialized) {
      eventBus.shutdown();
    }
  });
  
  test('should emit events', async () => {
    await eventBus.initialize();
    
    const handler = jest.fn();
    eventBus.on('test.event', handler);
    
    await eventBus.emit('test.event', { message: 'Hello' });
    
    expect(handler).toHaveBeenCalled();
    expect(handler.mock.calls[0][0]).toHaveProperty('name', 'test.event');
    expect(handler.mock.calls[0][0]).toHaveProperty('data', { message: 'Hello' });
  });
  
  // More tests...
});
```

### EventBusSystem Testing

Example of testing the EventBusSystem:

```javascript
describe('EventBusSystem', () => {
  let eventBusSystem;
  let mockErrorSystem;
  
  beforeEach(() => {
    mockErrorSystem = {
      handleError: jest.fn()
    };
    
    eventBusSystem = new EventBusSystem({
      errorSystem: mockErrorSystem,
      config: {}
    });
  });
  
  afterEach(async () => {
    if (eventBusSystem.initialized) {
      await eventBusSystem.shutdown();
    }
  });
  
  test('should initialize correctly', async () => {
    await eventBusSystem.initialize();
    
    expect(eventBusSystem.initialized).toBe(true);
    expect(eventBusSystem.state.status).toBe('running');
    expect(eventBusSystem.eventBus).toBeInstanceOf(CoreEventBus);
  });
  
  // More tests...
});
```

### Testing Event Handlers

Example of testing a module's event handlers:

```javascript
describe('UserModule event handlers', () => {
  let userModule;
  let mockEventBus;
  
  beforeEach(() => {
    // Create mock event bus
    mockEventBus = {
      subscribe: jest.fn(),
      emit: jest.fn()
    };
    
    // Create mock event bus system
    const mockEventBusSystem = {
      getEventBus: () => mockEventBus
    };
    
    // Create module with mocked dependencies
    userModule = new UserModule({
      eventBusSystem: mockEventBusSystem,
      // Other dependencies...
    });
  });
  
  test('should handle user.created events', async () => {
    // Extract the handler function
    await userModule.setupEventHandlers();
    const [[eventName, handler]] = mockEventBus.subscribe.mock.calls;
    
    expect(eventName).toBe('user.created');
    
    // Create a mock event
    const mockEvent = {
      id: 'event-123',
      name: 'user.created',
      data: { id: 'user-123', name: 'John Doe' },
      timestamp: new Date().toISOString()
    };
    
    // Call the handler directly
    await handler(mockEvent);
    
    // Assert expected behavior
    // ...
  });
});
```

## Best Practices

### 1. Event Naming

Follow these event naming conventions:

- Use domain-driven event names: `domain.action`
- Include version for breaking changes: `user.created.v2`
- Use past tense for state changes: `user.created`, `order.completed`
- Use present tense for commands: `notification.send`, `email.process`
- Be specific and descriptive

Examples:
```javascript
// Good
eventBus.emit('user.registered', userData);
eventBus.emit('order.completed', orderData);
eventBus.emit('payment.failed', paymentError);

// Bad - too generic
eventBus.emit('created', userData);
eventBus.emit('process', orderData);
```

### 2. Event Data Structure

Follow these guidelines for event data:

- Keep event data serializable (JSON-compatible)
- Include all necessary context in the data
- Avoid circular references
- Use consistent data structures for similar events
- Don't include sensitive information

Example:
```javascript
// Good
await eventBus.emit('user.created', {
  id: 'user-123',
  name: 'John Doe',
  email: 'john@example.com',
  createdAt: new Date().toISOString(),
  roles: ['user'],
  settings: {
    notifications: true,
    theme: 'dark'
  }
});

// Bad - includes DB model, sensitive data
await eventBus.emit('user.created', userDbModel);
```

### 3. Event Handling

Implement robust event handlers:

- Always use try/catch in handlers
- Validate event data before processing
- Keep handlers focused on a single responsibility
- Use proper error context
- Make handlers idempotent when possible

Example:
```javascript
eventBus.subscribe('order.created', async (event) => {
  try {
    // Validate event data
    if (!event.data || !event.data.id) {
      throw new ValidationError('INVALID_ORDER_DATA', 'Order data is missing required fields');
    }
    
    // Process event
    await processOrder(event.data);
    
    // Record metric
    this.recordMetric('orders.processed', 1, {
      orderId: event.data.id
    });
  } catch (error) {
    // Handle error
    await this.handleError(error, {
      event,
      handler: 'processOrderCreated'
    });
  }
});
```

### 4. Subscription Management

Manage subscriptions properly:

- Set up handlers in module initialization
- Clean up subscriptions on shutdown
- Store subscription IDs for later cleanup
- Use appropriate pattern matching
- Avoid wildcard subscriptions for performance-critical code

Example:
```javascript
class OrderModule extends CoreModule {
  constructor(deps) {
    super(deps);
    this.subscriptions = [];
  }
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    // Store subscription IDs
    this.subscriptions.push(
      eventBus.subscribe('order.created', this.handleOrderCreated.bind(this)),
      eventBus.subscribe('payment.completed', this.handlePaymentCompleted.bind(this)),
      eventBus.subscribe('shipping.status.*', this.handleShippingUpdates.bind(this))
    );
  }
  
  async onShutdown() {
    // Clean up subscriptions
    const eventBus = this.deps.eventBusSystem.getEventBus();
    for (const subId of this.subscriptions) {
      eventBus.unsubscribe(subId);
    }
    this.subscriptions = [];
  }
}
```

## Using EventBus in Modules

### Module Access to EventBus

Modules should access the EventBus through the EventBusSystem:

```javascript
class BusinessModule extends CoreModule {
  constructor(deps) {
    super(deps);
    // Get eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem.getEventBus();
  }
}
```

### Setting Up Event Handlers

Implement the `setupEventHandlers` method to set up event handlers:

```javascript
class UserModule extends CoreModule {
  async setupEventHandlers() {
    // Get eventBus from eventBusSystem
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    // Store subscription IDs for cleanup
    this.subscriptions = [
      // Handle user events
      eventBus.subscribe('user.created', this.handleUserCreated.bind(this)),
      eventBus.subscribe('user.updated', this.handleUserUpdated.bind(this)),
      eventBus.subscribe('user.deleted', this.handleUserDeleted.bind(this)),
      
      // Handle related events
      eventBus.subscribe('auth.login', this.handleUserLogin.bind(this)),
      eventBus.subscribe('auth.logout', this.handleUserLogout.bind(this))
    ];
  }
  
  // Event handlers
  async handleUserCreated(event) {
    try {
      const userData = event.data;
      // Process the user creation...
      await this.db.createUserProfile(userData);
      
      // Emit consequent events
      await this.eventBus.emit('profile.created', {
        userId: userData.id,
        profile: { /* profile data */ }
      });
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserCreated'
      });
    }
  }
  
  // More handlers...
}
```

### Cleaning Up Subscriptions

Clean up subscriptions in the `onShutdown` method:

```javascript
class UserModule extends CoreModule {
  // Other methods...
  
  async onShutdown() {
    // Clean up subscriptions
    if (this.eventBus) {
      for (const subId of this.subscriptions) {
        this.eventBus.unsubscribe(subId);
      }
    }
    this.subscriptions = [];
  }
}
```

### Complete Module Example

A complete example of a module using the EventBus:

```javascript
import { CoreModule } from '../core/module/Module.js';
import { ValidationError } from '../core/errors/index.js';

export class UserModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'database'];
  static version = '1.0.0';
  
  constructor(deps) {
    super(deps);
    this.db = deps.database;
    this.subscriptions = [];
    this.userCache = new Map();
  }
  
  async onConfigure() {
    // Initialize cache settings
    this.cacheEnabled = this.config.userCache?.enabled || true;
    this.cacheTTL = this.config.userCache?.ttl || 3600000; // 1 hour
  }
  
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    this.subscriptions = [
      eventBus.subscribe('user.created', this.handleUserCreated.bind(this)),
      eventBus.subscribe('user.updated', this.handleUserUpdated.bind(this)),
      eventBus.subscribe('user.deleted', this.handleUserDeleted.bind(this)),
      eventBus.subscribe('cache.clear', this.handleCacheClear.bind(this))
    ];
  }
  
  async onSetupHealthChecks() {
    // Register user cache health check
    this.registerHealthCheck('userCache', async () => {
      return {
        status: 'healthy',
        size: this.userCache.size,
        enabled: this.cacheEnabled
      };
    });
  }
  
  // Business methods
  async createUser(userData) {
    try {
      // Validate user data
      if (!userData.email) {
        throw new ValidationError('MISSING_EMAIL', 'Email is required');
      }
      
      // Create user in database
      const user = await this.db.users.create(userData);
      
      // Update cache
      if (this.cacheEnabled) {
        this.userCache.set(user.id, {
          data: user,
          expires: Date.now() + this.cacheTTL
        });
      }
      
      // Emit event
      await this.eventBus.emit('user.created', user);
      
      // Record metric
      this.recordMetric('users.created', 1);
      
      return user;
    } catch (error) {
      await this.handleError(error, {
        method: 'createUser',
        userData
      });
      throw error;
    }
  }
  
  // Event handlers
  async handleUserCreated(event) {
    try {
      const user = event.data;
      
      // Update cache if event came from another instance
      if (this.cacheEnabled && event.metadata?.source !== this.instanceId) {
        this.userCache.set(user.id, {
          data: user,
          expires: Date.now() + this.cacheTTL
        });
      }
      
      // Perform additional processing
      await this.sendWelcomeEmail(user);
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserCreated'
      });
    }
  }
  
  async handleUserUpdated(event) {
    try {
      const user = event.data;
      
      // Update cache
      if (this.cacheEnabled) {
        this.userCache.set(user.id, {
          data: user,
          expires: Date.now() + this.cacheTTL
        });
      }
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserUpdated'
      });
    }
  }
  
  async handleUserDeleted(event) {
    try {
      const { userId } = event.data;
      
      // Remove from cache
      if (this.cacheEnabled) {
        this.userCache.delete(userId);
      }
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleUserDeleted'
      });
    }
  }
  
  async handleCacheClear(event) {
    try {
      if (event.data.target === 'all' || event.data.target === 'users') {
        this.userCache.clear();
        this.recordMetric('cache.cleared', 1, { target: 'users' });
      }
    } catch (error) {
      await this.handleError(error, {
        event,
        handler: 'handleCacheClear'
      });
    }
  }
  
  async onShutdown() {
    // Clean up subscriptions
    if (this.eventBus) {
      for (const subId of this.subscriptions) {
        this.eventBus.unsubscribe(subId);
      }
    }
    
    // Clear cache
    this.userCache.clear();
  }
}
```

## Troubleshooting

### Common Issues

1. **Event Bus Not Initialized**
   - **Symptom**: `NOT_INITIALIZED` error when trying to get or use EventBus
   - **Solution**: Ensure EventBusSystem is initialized before use
   ```javascript
   // Check initialization
   if (!this.initialized) {
     throw new CoreError('NOT_INITIALIZED', 'EventBusSystem is not initialized');
   }
   ```

2. **Missing Dependencies**
   - **Symptom**: `MISSING_DEPENDENCIES` error during initialization
   - **Solution**: Ensure all required dependencies are provided
   ```javascript
   // Validate dependencies
   const missing = this.constructor.dependencies.filter(
     dep => !this.deps[dep]
   );

   if (missing.length > 0) {
     throw new CoreError(
       'MISSING_DEPENDENCIES',
       `Missing required dependencies: ${missing.join(', ')}`
     );
   }
   ```

3. **Event Handler Errors**
   - **Symptom**: Unhandled errors in event handlers
   - **Solution**: Always use try/catch in handlers
   ```javascript
   try {
     await handler(event);
   } catch (error) {
     await this.handleError(error, {
       event,
       handler: handler.name
     });
   }
   ```

4. **Events Not Received**
   - **Symptom**: Event handlers not being triggered
   - **Solution**: Check event names, patterns, and subscription setup
   ```javascript
   // Debug event subscriptions
   console.log('Subscriptions:', Array.from(eventBus.subscriptions.values()));
   
   // Add debug listener
   eventBus.subscribe('*', (event) => {
     console.log('Event received:', event.name, event);
   });
   ```

5. **Memory Leaks**
   - **Symptom**: Increasing memory usage over time
   - **Solution**: Ensure proper cleanup of subscriptions and event history
   ```javascript
   // Clean up subscriptions
   for (const subId of this.subscriptions) {
     eventBus.unsubscribe(subId);
   }
   
   // Limit event history size
   if (history.length > this.maxHistorySize) {
     history.pop(); // Remove oldest events
   }
   ```

### Debugging Techniques

1. **Enable Event Logging**
   ```javascript
   // Add a global event listener
   eventBus.subscribe('*', (event) => {
     console.log(`[${new Date().toISOString()}] Event:`, event.name, event);
   });
   ```

2. **Check Event History**
   ```javascript
   // Check history for a specific event
   const history = eventBus.getHistory('user.created');
   console.log('Event history:', history);
   
   // Check all event history
   const allHistory = eventBus.getAllHistory();
   console.log('All event history:', allHistory);
   ```

3. **Monitor Health**
   ```javascript
   // Check health status
   const health = await eventBus.checkHealth();
   console.log('EventBus health:', JSON.stringify(health, null, 2));
   ```

4. **Inspect Subscriptions**
   ```javascript
   // Log all subscriptions
   const subscriptions = Array.from(eventBus.subscriptions.values());
   console.log('Active subscriptions:', subscriptions);
   ```

5. **Check Queues**
   ```javascript
   // Check queue sizes
   const queueSizes = {};
   for (const [name, queue] of eventBus.queues.entries()) {
     queueSizes[name] = queue.length;
   }
   console.log('Queue sizes:', queueSizes);
   ```

### Common Error Codes

- `NOT_INITIALIZED`: EventBus or EventBusSystem is not initialized
- `ALREADY_INITIALIZED`: EventBus or EventBusSystem is already initialized
- `MISSING_DEPENDENCIES`: Required dependencies are missing
- `INVALID_HEALTH_CHECK`: Invalid health check function
- `INVALID_ERROR_SYSTEM`: ErrorSystem is missing required methods
- `SHUTDOWN_FAILED`: Failed to shutdown EventBus or EventBusSystem

### Performance Tuning

1. **Optimize Event Handlers**
   - Keep handlers focused and efficient
   - Avoid blocking operations
   - Consider using queues for heavy processing

2. **Limit Event History**
   - Set appropriate history size limits
   - Consider disabling history for high-frequency events

3. **Use Specific Subscriptions**
   - Avoid wildcard subscriptions for high-frequency events
   - Use direct subscriptions when possible

4. **Process Queues Efficiently**
   - Schedule queue processing at appropriate intervals
   - Monitor queue sizes and adjust processing frequency


// src/core/module/Module.js

// src/core/module/Module.js
import { EventEmitter } from 'events';
import { CoreEventBus } from '../event/EventBus.js';
import { ModuleError, ValidationError } from '../errors/index.js';

export class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];
  static version = '1.0.0';
  
  constructor(deps = {}) {
    super();
    this.deps = deps;
    // Get the eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.initialized = false;
    this.config = deps.config || {};
    
    // Enhanced state tracking
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
      lastHealthCheck: null
    };

    // Validate dependencies immediately
    this.validateDependencies();
    
    // Set up health check interval
    this.healthCheckInterval = null;
  }

  validateDependencies() {
    // Check required dependencies
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new ModuleError(
        'MISSING_DEPENDENCIES',
        `Missing required dependencies: ${missing.join(', ')}`
      );
    }

    // Validate eventBusSystem dependency
    if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus !== 'function') {
      throw new ModuleError(
        'INVALID_EVENTBUS_SYSTEM',
        'EventBusSystem missing required method: getEventBus'
      );
    }

    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') {
      throw new ModuleError(
        'INVALID_ERROR_SYSTEM',
        'ErrorSystem missing required methods'
      );
    }
  }

  async validateConfig() {
    try {
      // Basic config validation
      if (this.config === null || typeof this.config !== 'object') {
        throw new ValidationError(
          'INVALID_CONFIG',
          'Configuration must be an object'
        );
      }

      // Module-specific validation
      await this.onValidateConfig();
      
      return true;
    } catch (error) {
      throw new ModuleError(
        'CONFIG_VALIDATION_FAILED',
        'Failed to validate configuration',
        { originalError: error }
      );
    }
  }

  async initialize() {
    if (this.initialized) {
      throw new ModuleError(
        'ALREADY_INITIALIZED',
        'Module is already initialized'
      );
    }

    try {
      this.state.startTime = Date.now();
      this.state.status = 'initializing';

      // Configuration phase
      await this.validateConfig();
      await this.onConfigure();

      // Setup phase
      await this.setupEventHandlers();
      await this.setupHealthChecks();

      // Initialize phase
      await this.onInitialize();

      // Start health check monitoring
      this.startHealthChecks();
      
      this.initialized = true;
      this.state.status = 'running';

      await this.emit('module:initialized', {
        name: this.constructor.name,
        timestamp: new Date().toISOString()
      });

      return this;

    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message
      });

      throw new ModuleError(
        'INITIALIZATION_FAILED',
        'Failed to initialize module',
        { originalError: error }
      );
    }
  }

  async setupHealthChecks() {
    // Register default health checks
    this.registerHealthCheck('state', async () => {
      return {
        status: this.state.status === 'running' ? 'healthy' : 'unhealthy',
        uptime: Date.now() - this.state.startTime,
        errorCount: this.state.errors.length
      };
    });

    // Allow modules to add their own health checks
    await this.onSetupHealthChecks();
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
      throw new ModuleError(
        'INVALID_HEALTH_CHECK',
        `Health check ${name} must be a function`
      );
    }
    this.state.healthChecks.set(name, checkFn);
  }

  startHealthChecks() {
    // Run health checks every 30 seconds by default
    this.healthCheckInterval = setInterval(async () => {
      try {
        const health = await this.checkHealth();
        this.state.lastHealthCheck = health;
        
        if (health.status !== 'healthy') {
          await this.handleError(new ModuleError(
            'HEALTH_CHECK_FAILED',
            'Module health check failed',
            { health }
          ));
        }
      } catch (error) {
        await this.handleError(error);
      }
    }, 30000);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = 'healthy';

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        results[name] = await checkFn();
        if (results[name].status !== 'healthy') {
          overallStatus = 'unhealthy';
        }
      } catch (error) {
        results[name] = {
          status: 'error',
          error: error.message
        };
        overallStatus = 'unhealthy';
      }
    }

    return {
      name: this.constructor.name,
      version: this.constructor.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks: results
    };
  }

  async handleError(error, context = {}) {
    const safeContext = context || {};

    // Add error to state
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: safeContext
    });

    // Trim error history
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }

    // Forward to error system
    if (this.deps.errorSystem) {
      try {
        await this.deps.errorSystem.handleError(error, {
          module: this.constructor.name,
          ...safeContext
        });
      } catch (handlerError) {
        // Log error handling failure
        console.error('Error in error handling:', handlerError);
      }
    }

    // Emit error event
    await this.emit('module:error', {
      module: this.constructor.name,
      error,
      context: safeContext
    });

    return this;
  }

  async emit(eventName, ...args) {
    // Emit through local EventEmitter
    const localEmitResult = super.emit(eventName, ...args);

    // Broadcast through eventBus if available
    if (this.eventBus?.emit) {
      try {
        await this.eventBus.emit(eventName, ...args);
      } catch (error) {
        await this.handleError(error, {
          event: eventName,
          args
        });
      }
    }

    return localEmitResult;
  }

  async shutdown() {
    try {
      if (!this.initialized) {
        return this;
      }

      this.state.status = 'shutting_down';
      
      // Stop health checks
      if (this.healthCheckInterval) {
        clearInterval(this.healthCheckInterval);
        this.healthCheckInterval = null;
      }

      // Custom shutdown logic
      await this.onShutdown();
      
      // Reset state
      this.initialized = false;
      this.state.status = 'shutdown';
      this.state.startTime = null;
      
      await this.emit('module:shutdown', {
        name: this.constructor.name,
        timestamp: new Date().toISOString()
      });

      return this;
    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message,
        context: { phase: 'shutdown' }
      });

      throw new ModuleError(
        'SHUTDOWN_FAILED',
        'Failed to shutdown module',
        { originalError: error }
      );
    }
  }

  // Lifecycle hooks for derived classes
  async onValidateConfig() {
    // Override in derived classes
    return true;
  }

  async onConfigure() {
    // Override in derived classes
    return Promise.resolve();
  }

  async setupEventHandlers() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onSetupHealthChecks() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onInitialize() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onShutdown() {
    // Override in derived classes
    return Promise.resolve();
  }

  // Metrics tracking
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, {
      value,
      timestamp: Date.now(),
      tags
    });
  }
}

export function createModule(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {} // No-op error handler
    },
    eventBusSystem: {
      getEventBus: () => new CoreEventBus({ // Use CoreEventBus instead of EventEmitter
        errorSystem: deps.errorSystem,
        config: deps.config
      })
    },
    config: {} // Empty configuration object
  };

  const mergedDeps = {
    ...defaultDeps,
    ...deps
  };

  return new CoreModule(mergedDeps);
}

export default {
  CoreModule,
  createModule
};


// src/core/module/ModuleSystem.js

// src/core/module/ModuleSystem.js
import { EventEmitter } from 'events';
import { CoreModule } from './Module.js';
import { ModuleError, ValidationError } from '../errors/index.js';

export class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];

  constructor(deps) {
    super();
    this.deps = deps;
    this.modules = new Map();
    this.initialized = false;
    // Get eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      moduleHealth: new Map(),
      healthCheckIntervals: new Map() // Track intervals for proper cleanup
    };

    // Validate dependencies
    this.validateDependencies();
  }

  validateDependencies() {
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new ModuleError(
        'MISSING_DEPENDENCIES',
        `Missing required dependencies: ${missing.join(', ')}`
      );
    }

    // Validate eventBusSystem
    if (!this.deps.eventBusSystem?.getEventBus) {
      throw new ModuleError(
        'INVALID_EVENTBUS_SYSTEM',
        'EventBusSystem missing required methods'
      );
    }

    if (!this.deps.errorSystem?.handleError) {
      throw new ModuleError(
        'INVALID_ERROR_SYSTEM',
        'ErrorSystem missing required methods'
      );
    }
  }

  async emit(eventName, ...args) {
    // Local EventEmitter emission
    const localEmitResult = super.emit(eventName, ...args);
    
    // Use eventBus for global events if available
    if (this.eventBus?.emit) {
      try {
        await this.eventBus.emit(eventName, ...args);
      } catch (error) {
        await this.handleModuleError('ModuleSystem', error);
      }
    }
    
    return localEmitResult;
  }

  async register(name, ModuleClass, config = {}) {
    if (!(ModuleClass.prototype instanceof CoreModule)) {
      throw new ValidationError(
        'INVALID_MODULE',
        'Module must extend CoreModule'
      );
    }

    if (this.modules.has(name)) {
      throw new ModuleError(
        'DUPLICATE_MODULE',
        `Module ${name} is already registered`
      );
    }

    try {
      // Create module instance with dependencies
      const module = new ModuleClass({
        ...this.deps,
        config: {
          ...this.deps.config?.[name],
          ...config
        }
      });

      this.modules.set(name, module);

      // Setup health check listener
      module.on('module:error', async (error) => {
        await this.handleModuleError(name, error);
      });

      await this.emit('module:registered', {
        name,
        timestamp: new Date().toISOString()
      });

      return module;
    } catch (error) {
      throw new ModuleError(
        'REGISTRATION_FAILED',
        `Failed to register module ${name}`,
        { originalError: error }
      );
    }
  }

  async unregister(name) {
    const module = this.modules.get(name);
    if (!module) return;

    try {
      if (module.initialized) {
        await module.shutdown();
      }
      
      this.modules.delete(name);
      
      await this.emit('module:unregistered', {
        name,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      throw new ModuleError(
        'UNREGISTER_FAILED',
        `Failed to unregister module ${name}`,
        { originalError: error }
      );
    }
  }

  async resolve(name) {
    const module = this.modules.get(name);
    if (!module) {
      throw new ModuleError(
        'MODULE_NOT_FOUND',
        `Module ${name} is not registered`
      );
    }
    return module;
  }

  async initialize() {
    if (this.initialized) {
      throw new ModuleError(
        'ALREADY_INITIALIZED',
        'ModuleSystem is already initialized'
      );
    }

    try {
      this.state.startTime = Date.now();
      this.state.status = 'initializing';

      // Initialize modules in dependency order
      const initOrder = this.resolveDependencyOrder();
      
      for (const name of initOrder) {
        const module = this.modules.get(name);
        await module.initialize();
        
        // Start monitoring module health
        await this.startModuleHealthMonitoring(name);
      }

      this.initialized = true;
      this.state.status = 'running';

      await this.emit('system:initialized', {
        timestamp: new Date().toISOString(),
        modules: Array.from(this.modules.keys())
      });

    } catch (error) {
      this.state.status = 'error';
      throw new ModuleError(
        'INITIALIZATION_FAILED',
        'Failed to initialize module system',
        { originalError: error }
      );
    }
  }

  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ModuleError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected for module: ${name}`
        );
      }

      visiting.add(name);

      const module = this.modules.get(name);
      const deps = module.constructor.dependencies || [];

      for (const dep of deps) {
        if (!this.modules.has(dep)) {
          throw new ModuleError(
            'MISSING_DEPENDENCY',
            `Module ${name} requires missing module: ${dep}`
          );
        }
        visit(dep);
      }

      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    for (const name of this.modules.keys()) {
      visit(name);
    }

    return order;
  }

  async startModuleHealthMonitoring(name) {
    const module = this.modules.get(name);
    if (!module) return;

    // Clear any existing interval
    if (this.state.healthCheckIntervals.has(name)) {
      clearInterval(this.state.healthCheckIntervals.get(name));
    }

    // Monitor module health status
    const intervalId = setInterval(async () => {
      try {
        const health = await module.checkHealth();
        this.state.moduleHealth.set(name, health);

        if (health.status !== 'healthy') {
          await this.handleModuleError(name, new ModuleError(
            'UNHEALTHY_MODULE',
            `Module ${name} is unhealthy`,
            { health }
          ));
        }
      } catch (error) {
        await this.handleModuleError(name, error);
      }
    }, 60000); // Check every minute

    // Track the interval for proper cleanup
    this.state.healthCheckIntervals.set(name, intervalId);
  }

  // async handleModuleError(moduleName, error) {
  //   this.state.errors.push({
  //     timestamp: new Date().toISOString(),
  //     module: moduleName,
  //     error: error.message
  //   });

  //   // Trim error history
  //   if (this.state.errors.length > 100) {
  //     this.state.errors.shift();
  //   }

  //   // Forward to error system
  //   try {
  //     if (this.deps.errorSystem?.handleError) {
  //       await this.deps.errorSystem.handleError(error, {
  //         source: 'ModuleSystem',
  //         module: moduleName
  //       });
  //     }
  //   } catch (handlerError) {
  //     // Log the error from the error system but don't rethrow
  //     console.error('Error in error handling:', handlerError);
  //   }
  //   await this.emit('module:error', {
  //     module: moduleName,
  //     error,
  //     timestamp: new Date().toISOString()
  //   });
  // }

  async handleModuleError(moduleName, error) {
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      module: moduleName,
      error: error.message
    });
  
    // Trim error history
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }
  
    // Defensive error handling for error system
    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError === 'function') {
      try {
        // Carefully forward error to error system with context
        await this.deps.errorSystem.handleError(error, {
          source: 'ModuleSystem',
          module: moduleName,
          timestamp: new Date().toISOString()
        });
      } catch (handlerError) {
        // Fallback logging mechanism
        const fallbackErrorLog = {
          timestamp: new Date().toISOString(),
          source: 'ModuleSystem',
          originalError: error.message,
          handlerError: handlerError.message,
          module: moduleName
        };
  
        // Use a robust logging mechanism
        if (typeof console.error === 'function') {
          console.error('Error System Failure:', JSON.stringify(fallbackErrorLog, null, 2));
        }
  
        // Optional: Add to local error tracking if error system fails
        this.state.errors.push({
          ...fallbackErrorLog,
          type: 'HANDLER_FAILURE'
        });
      }
    }
  
    // Emit error event regardless of error system status
    await this.emit('module:error', {
      module: moduleName,
      error,
      timestamp: new Date().toISOString()
    });
  }

  async getSystemHealth() {
    const moduleHealth = {};
    let systemStatus = 'healthy';

    for (const [name, module] of this.modules) {
      try {
        const health = await module.checkHealth();
        moduleHealth[name] = health;
        
        if (health.status !== 'healthy') {
          systemStatus = 'degraded';
        }
      } catch (error) {
        moduleHealth[name] = {
          status: 'error',
          error: error.message
        };
        systemStatus = 'unhealthy';
      }
    }

    return {
      status: systemStatus,
      timestamp: new Date().toISOString(),
      uptime: Date.now() - this.state.startTime,
      modules: moduleHealth,
      errorCount: this.state.errors.length
    };
  }

  async shutdown() {
    if (!this.initialized) return;

    try {
      this.state.status = 'shutting_down';

      // Clear all health check intervals
      for (const [name, intervalId] of this.state.healthCheckIntervals) {
        clearInterval(intervalId);
      }
      this.state.healthCheckIntervals.clear();

      // Shutdown modules in reverse dependency order
      const shutdownOrder = this.resolveDependencyOrder().reverse();

      for (const name of shutdownOrder) {
        const module = this.modules.get(name);
        await module.shutdown();
      }

      this.modules.clear();
      this.initialized = false;
      this.state.status = 'shutdown';

      await this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      this.state.status = 'error';
      throw new ModuleError(
        'SHUTDOWN_FAILED',
        'Failed to shutdown module system',
        { originalError: error }
      );
    }
  }
}

export function createModuleSystem(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {} // No-op error handler
    },
    eventBusSystem: {
      getEventBus: () => new EventEmitter() // Default eventBus provider
    },
    config: {} // Empty configuration object
  };

  return new ModuleSystem({
    ...defaultDeps,
    ...deps
  });
}

export default {
  ModuleSystem,
  createModuleSystem
};


// src/core/module/module-system-docs.md

# Module System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Core Concepts](#core-concepts)
3. [System Architecture](#system-architecture)
4. [Core Systems](#core-systems)
5. [Service Systems](#service-systems)
6. [Business Modules](#business-modules)
7. [Integration Patterns](#integration-patterns)
8. [State Management](#state-management)
9. [Error Handling](#error-handling)
10. [Event System](#event-system)
11. [Health Monitoring](#health-monitoring)
12. [Testing Strategy](#testing-strategy)
13. [Best Practices](#best-practices)
14. [Creating Custom Modules](#creating-custom-modules)
15. [Troubleshooting](#troubleshooting)

## Overview

The TSMIS architecture is built on three main layers:
1. **Core Systems** - Fundamental infrastructure (Container, ErrorSystem, EventBusSystem, ModuleSystem)
2. **Service Systems** - Common service functionality
3. **Business Modules** - Business domain logic

The Module System provides a standardized approach to creating, managing, and connecting application components. It enforces consistent module lifecycle management, dependency injection, health monitoring, event communication, and error handling.

## Core Concepts

### Core Dependencies

The module system requires three essential dependencies:

```javascript
static dependencies = ['errorSystem', 'eventBusSystem', 'config'];
```

#### Dependency Resolution

Dependencies are resolved through one of these methods:

1. **Container Resolution** (primary method)
   - Dependencies are automatically injected by the Container
   - Container manages lifecycle and dependencies

2. **Default Fallbacks** (development/testing)
   - Default implementations for easier testing and development

3. **Explicit Injection**
   - Manual dependency injection for specialized cases

#### Default Fallbacks

```javascript
const defaultDeps = {
  errorSystem: {
    handleError: async () => {} // No-op handler
  },
  eventBusSystem: {
    getEventBus: () => new CoreEventBus({ // Use CoreEventBus 
      errorSystem: deps.errorSystem,
      config: deps.config
    })
  },
  config: {} // Empty config
};
```

#### Component Registration

Components can be registered in two ways:

1. **As Singleton Instances:**

```javascript
// In app.js
const eventBusSystem = createEventBusSystem();
container.register('eventBusSystem', () => eventBusSystem);
```

2. **As Factory Functions:**

```javascript
container.register('moduleSystem', (deps) => {
  return createModuleSystem(deps);
});
```

#### Event System Integration

Modules communicate through the EventBus in two ways:

1. **Direct Events (local):**

```javascript
// Within a module
this.emit('localEvent', data);
```

2. **System Events (global):**

```javascript
// Broadcast to all modules
this.eventBus.emit('globalEvent', data);
```

### Architectural Principles
- Clear separation of concerns
- Infrastructure/business logic separation
- Event-driven communication
- Dependency injection
- State management
- Health monitoring

### Key Features
- Core dependencies management
- Module lifecycle control
- Standardized error handling
- Dual event emission (local + bus)
- Health monitoring with automatic checks
- Metrics tracking
- Graceful initialization and shutdown

## System Architecture

```mermaid
graph TB
    Container --> ErrorSystem
    Container --> EventBusSystem
    Container --> ModuleSystem
    
    ModuleSystem --> BusinessModules
    
    ErrorSystem --> |Error Handling| BusinessModules
    EventBusSystem --> |Event Flow| BusinessModules
```

## Core Systems

### ModuleSystem
The ModuleSystem manages the registration, initialization, and lifecycle of all modules:

```javascript
class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];

  async register(name, ModuleClass, config = {}) {
    // Module registration logic
    const module = new ModuleClass({
      ...this.deps,
      config: {
        ...this.deps.config?.[name],
        ...config
      }
    });
    this.modules.set(name, module);
    return module;
  }

  async resolve(name) {
    // Module resolution logic
    const module = this.modules.get(name);
    if (!module) {
      throw new ModuleError(
        'MODULE_NOT_FOUND',
        `Module ${name} is not registered`
      );
    }
    return module;
  }
  
  async initialize() {
    // Initialize modules in dependency order
    const initOrder = this.resolveDependencyOrder();
    
    for (const name of initOrder) {
      const module = this.modules.get(name);
      await module.initialize();
      
      // Start monitoring module health
      await this.startModuleHealthMonitoring(name);
    }
  }
  
  async shutdown() {
    // Shutdown modules in reverse dependency order
    const shutdownOrder = this.resolveDependencyOrder().reverse();

    for (const name of shutdownOrder) {
      const module = this.modules.get(name);
      await module.shutdown();
    }
  }
}
```

### CoreModule Base Class
The `CoreModule` serves as the base class for all modules in the system:

```javascript
class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];
  static version = '1.0.0';

  constructor(deps = {}) {
    super();
    this.deps = deps;
    // Get the eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.initialized = false;
    this.config = deps.config || {};
    
    // Enhanced state tracking
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
      lastHealthCheck: null
    };

    // Validate dependencies immediately
    this.validateDependencies();
  }
  
  // Lifecycle hooks for derived classes
  async validateConfig() {/* ... */}
  async onValidateConfig() {/* ... */}
  async initialize() {/* ... */}
  async onConfigure() {/* ... */}
  async setupEventHandlers() {/* ... */}
  async setupHealthChecks() {/* ... */}
  async onSetupHealthChecks() {/* ... */}
  async onInitialize() {/* ... */}
  async shutdown() {/* ... */}
  async onShutdown() {/* ... */}
}
```

## State Management

### Module States
Modules transition through the following states during their lifecycle:

- **created**: Initial module state after instantiation
- **initializing**: During initialization process
- **running**: Module is active and operational
- **shutting_down**: During shutdown process
- **shutdown**: Module is inactive
- **error**: Error state when something fails

### State Tracking
The state object stores comprehensive module metadata:

```javascript
this.state = {
  status: 'created',          // Current module state
  startTime: null,            // When module was started
  errors: [],                 // Error history
  metrics: new Map(),         // Performance metrics
  healthChecks: new Map(),    // Health check functions 
  lastHealthCheck: null       // Last health check result
};
```

## Error Handling

### Error Management
Each module includes robust error handling:

```javascript
async handleError(error, context = {}) {
  const safeContext = context || {};

  // Add error to state
  this.state.errors.push({
    timestamp: new Date().toISOString(),
    error: error.message,
    context: safeContext
  });

  // Trim error history
  if (this.state.errors.length > 100) {
    this.state.errors.shift();
  }

  // Forward to error system
  if (this.deps.errorSystem) {
    try {
      await this.deps.errorSystem.handleError(error, {
        module: this.constructor.name,
        ...safeContext
      });
    } catch (handlerError) {
      // Log error handling failure
      console.error('Error in error handling:', handlerError);
    }
  }

  // Emit error event
  await this.emit('module:error', {
    module: this.constructor.name,
    error,
    context: safeContext
  });

  return this;
}
```

### ModuleSystem Error Handling

The ModuleSystem includes specialized error handling for modules:

```javascript
async handleModuleError(moduleName, error) {
  this.state.errors.push({
    timestamp: new Date().toISOString(),
    module: moduleName,
    error: error.message
  });

  // Trim error history
  if (this.state.errors.length > 100) {
    this.state.errors.shift();
  }

  // Defensive error handling for error system
  if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError === 'function') {
    try {
      // Forward error to error system with context
      await this.deps.errorSystem.handleError(error, {
        source: 'ModuleSystem',
        module: moduleName,
        timestamp: new Date().toISOString()
      });
    } catch (handlerError) {
      // Fallback logging mechanism
      const fallbackErrorLog = {
        timestamp: new Date().toISOString(),
        source: 'ModuleSystem',
        originalError: error.message,
        handlerError: handlerError.message,
        module: moduleName
      };

      // Use robust logging mechanism
      if (typeof console.error === 'function') {
        console.error('Error System Failure:', JSON.stringify(fallbackErrorLog, null, 2));
      }

      // Add to local error tracking
      this.state.errors.push({
        ...fallbackErrorLog,
        type: 'HANDLER_FAILURE'
      });
    }
  }

  // Emit error event regardless of error system status
  await this.emit('module:error', {
    module: moduleName,
    error,
    timestamp: new Date().toISOString()
  });
}
```

## Event System

### Dual Event Emission
The CoreModule includes a specialized `emit` method that handles both local and global events:

```javascript
async emit(eventName, ...args) {
  // Emit through local EventEmitter
  const localEmitResult = super.emit(eventName, ...args);

  // Broadcast through eventBus if available
  if (this.eventBus?.emit) {
    try {
      await this.eventBus.emit(eventName, ...args);
    } catch (error) {
      await this.handleError(error, {
        event: eventName,
        args
      });
    }
  }

  return localEmitResult;
}
```

### ModuleSystem Event Emission

The ModuleSystem also has dual event emission:

```javascript
async emit(eventName, ...args) {
  // Local EventEmitter emission
  const localEmitResult = super.emit(eventName, ...args);
  
  // Use eventBus for global events if available
  if (this.eventBus?.emit) {
    try {
      await this.eventBus.emit(eventName, ...args);
    } catch (error) {
      await this.handleModuleError('ModuleSystem', error);
    }
  }
  
  return localEmitResult;
}
```

## Health Monitoring

### Health Check Implementation

The system includes comprehensive health monitoring:

- Component status tracking
- Error history collection
- Metrics gathering
- Automatic health checks
- Customizable health check functions

```javascript
async setupHealthChecks() {
  // Register default health checks
  this.registerHealthCheck('state', async () => {
    return {
      status: this.state.status === 'running' ? 'healthy' : 'unhealthy',
      uptime: Date.now() - this.state.startTime,
      errorCount: this.state.errors.length
    };
  });

  // Allow modules to add their own health checks
  await this.onSetupHealthChecks();
}

registerHealthCheck(name, checkFn) {
  if (typeof checkFn !== 'function') {
    throw new ModuleError(
      'INVALID_HEALTH_CHECK',
      `Health check ${name} must be a function`
    );
  }
  this.state.healthChecks.set(name, checkFn);
}

startHealthChecks() {
  // Run health checks every 30 seconds by default
  this.healthCheckInterval = setInterval(async () => {
    try {
      const health = await this.checkHealth();
      this.state.lastHealthCheck = health;
      
      if (health.status !== 'healthy') {
        await this.handleError(new ModuleError(
          'HEALTH_CHECK_FAILED',
          'Module health check failed',
          { health }
        ));
      }
    } catch (error) {
      await this.handleError(error);
    }
  }, 30000);
}

async checkHealth() {
  const results = {};
  let overallStatus = 'healthy';

  for (const [name, checkFn] of this.state.healthChecks) {
    try {
      results[name] = await checkFn();
      if (results[name].status !== 'healthy') {
        overallStatus = 'unhealthy';
      }
    } catch (error) {
      results[name] = {
        status: 'error',
        error: error.message
      };
      overallStatus = 'unhealthy';
    }
  }

  return {
    name: this.constructor.name,
    version: this.constructor.version,
    status: overallStatus,
    timestamp: new Date().toISOString(),
    checks: results
  };
}
```

### Metrics Recording
```javascript
recordMetric(name, value, tags = {}) {
  this.state.metrics.set(name, {
    value,
    timestamp: Date.now(),
    tags
  });
}
```

### System Health Monitoring

The ModuleSystem monitors health of all registered modules:

```javascript
async startModuleHealthMonitoring(name) {
  const module = this.modules.get(name);
  if (!module) return;

  // Clear any existing interval
  if (this.state.healthCheckIntervals.has(name)) {
    clearInterval(this.state.healthCheckIntervals.get(name));
  }

  // Monitor module health status
  const intervalId = setInterval(async () => {
    try {
      const health = await module.checkHealth();
      this.state.moduleHealth.set(name, health);

      if (health.status !== 'healthy') {
        await this.handleModuleError(name, new ModuleError(
          'UNHEALTHY_MODULE',
          `Module ${name} is unhealthy`,
          { health }
        ));
      }
    } catch (error) {
      await this.handleModuleError(name, error);
    }
  }, 60000); // Check every minute

  // Track the interval for proper cleanup
  this.state.healthCheckIntervals.set(name, intervalId);
}

async getSystemHealth() {
  const moduleHealth = {};
  let systemStatus = 'healthy';

  for (const [name, module] of this.modules) {
    try {
      const health = await module.checkHealth();
      moduleHealth[name] = health;
      
      if (health.status !== 'healthy') {
        systemStatus = 'degraded';
      }
    } catch (error) {
      moduleHealth[name] = {
        status: 'error',
        error: error.message
      };
      systemStatus = 'unhealthy';
    }
  }

  return {
    status: systemStatus,
    timestamp: new Date().toISOString(),
    uptime: Date.now() - this.state.startTime,
    modules: moduleHealth,
    errorCount: this.state.errors.length
  };
}
```

## Module Lifecycle

### Initialization
The CoreModule initialization process involves multiple phases:

```javascript
async initialize() {
  if (this.initialized) {
    throw new ModuleError(
      'ALREADY_INITIALIZED',
      'Module is already initialized'
    );
  }

  try {
    this.state.startTime = Date.now();
    this.state.status = 'initializing';

    // Configuration phase
    await this.validateConfig();
    await this.onConfigure();

    // Setup phase
    await this.setupEventHandlers();
    await this.setupHealthChecks();

    // Initialize phase
    await this.onInitialize();

    // Start health check monitoring
    this.startHealthChecks();
    
    this.initialized = true;
    this.state.status = 'running';

    await this.emit('module:initialized', {
      name: this.constructor.name,
      timestamp: new Date().toISOString()
    });

    return this;

  } catch (error) {
    this.state.status = 'error';
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message
    });

    throw new ModuleError(
      'INITIALIZATION_FAILED',
      'Failed to initialize module',
      { originalError: error }
    );
  }
}
```

### Shutdown
The CoreModule shutdown process ensures graceful termination:

```javascript
async shutdown() {
  try {
    if (!this.initialized) {
      return this;
    }

    this.state.status = 'shutting_down';
    
    // Stop health checks
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }

    // Custom shutdown logic
    await this.onShutdown();
    
    // Reset state
    this.initialized = false;
    this.state.status = 'shutdown';
    this.state.startTime = null;
    
    await this.emit('module:shutdown', {
      name: this.constructor.name,
      timestamp: new Date().toISOString()
    });

    return this;
  } catch (error) {
    this.state.status = 'error';
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: { phase: 'shutdown' }
    });

    throw new ModuleError(
      'SHUTDOWN_FAILED',
      'Failed to shutdown module',
      { originalError: error }
    );
  }
}
```

### Dependency Resolution

The ModuleSystem resolves module dependencies in the correct order:

```javascript
resolveDependencyOrder() {
  const visited = new Set();
  const visiting = new Set();
  const order = [];

  const visit = (name) => {
    if (visited.has(name)) return;
    if (visiting.has(name)) {
      throw new ModuleError(
        'CIRCULAR_DEPENDENCY',
        `Circular dependency detected for module: ${name}`
      );
    }

    visiting.add(name);

    const module = this.modules.get(name);
    const deps = module.constructor.dependencies || [];

    for (const dep of deps) {
      if (!this.modules.has(dep)) {
        throw new ModuleError(
          'MISSING_DEPENDENCY',
          `Module ${name} requires missing module: ${dep}`
        );
      }
      visit(dep);
    }

    visiting.delete(name);
    visited.add(name);
    order.push(name);
  };

  for (const name of this.modules.keys()) {
    visit(name);
  }

  return order;
}
```

## Testing Strategy

### Module Testing
Here's an example of how to test a CoreModule:

```javascript
describe('CoreModule', () => {
  let module;
  let mockDeps;

  beforeEach(() => {
    mockDeps = {
      errorSystem: {
        handleError: jest.fn()
      },
      eventBusSystem: {
        getEventBus: () => new EventEmitter()
      },
      config: {}
    };
    module = new CoreModule(mockDeps);
  });

  test('should handle initialization', async () => {
    await module.initialize();
    expect(module.initialized).toBe(true);
    expect(module.state.status).toBe('running');
  });
  
  test('should register health checks', async () => {
    await module.initialize();

    // Core module always has a state health check
    expect(module.state.healthChecks.has("state")).toBe(true);

    // Add a custom health check
    module.registerHealthCheck("custom", async () => {
      return { status: "healthy" };
    });

    expect(module.state.healthChecks.has("custom")).toBe(true);

    const health = await module.checkHealth();
    expect(health.status).toBe("healthy");
  });
});
```

### ModuleSystem Testing

Here's an example of how to test the ModuleSystem:

```javascript
describe('ModuleSystem', () => {
  let moduleSystem;
  let errorSystem;
  let eventBusSystem;

  beforeEach(() => {
    errorSystem = {
      handleError: jest.fn()
    };
    
    const eventBus = new EventEmitter();
    
    eventBusSystem = {
      getEventBus: () => eventBus
    };
    
    moduleSystem = new ModuleSystem({
      errorSystem,
      eventBusSystem,
      config: {}
    });
  });

  test('should register a module', async () => {
    class SimpleModule extends CoreModule {}
    
    const module = await moduleSystem.register('simple', SimpleModule);
    
    expect(module instanceof SimpleModule).toBe(true);
    expect(moduleSystem.modules.has('simple')).toBe(true);
  });
  
  test('should resolve dependencies in correct order', () => {
    // Add modules with dependencies
    moduleSystem.modules.set('a', { constructor: { dependencies: [] } });
    moduleSystem.modules.set('b', { constructor: { dependencies: ['a'] } });
    moduleSystem.modules.set('c', { constructor: { dependencies: ['a', 'b'] } });
    
    const order = moduleSystem.resolveDependencyOrder();
    
    expect(order).toEqual(['a', 'b', 'c']);
  });
});
```

## Best Practices

1. Always use Container for dependency injection
2. Utilize event system for module communication
3. Implement custom health checks for modules
4. Handle errors with proper context
5. Use singleton components judiciously

### 1. Module Implementation
- Validate dependencies in constructor
- Implement lifecycle hooks (onConfigure, onInitialize, onShutdown)
- Set up event handlers in setupEventHandlers
- Create health checks in onSetupHealthChecks
- Handle errors through errorSystem
- Record meaningful metrics
- Maintain clean state transitions

### 2. Error Handling
- Use ModuleError for module-specific errors
- Provide meaningful error contexts
- Limit error history to prevent memory issues
- Forward errors to errorSystem when available
- Gracefully handle error system failures

### 3. Event Handling
- Use setupEventHandlers for event subscription
- Leverage dual event emission appropriately
- Handle event errors properly
- Provide clear event payloads

### 4. Health Monitoring
- Implement meaningful health checks
- Record relevant metrics
- Maintain accurate state information
- Track error history
- Use correct status values ('healthy', 'unhealthy', 'error')

## Creating Custom Modules

### Basic Module Template

To create a new module, extend the CoreModule class and implement the necessary lifecycle methods:

```javascript
import { CoreModule } from '../core/module/Module.js';

export class CustomBusinessModule extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'databaseService'];
  static version = '1.0.0';
  
  constructor(deps = {}) {
    super(deps);
    
    // Store specific dependencies
    this.db = deps.databaseService;
    
    // Module-specific state
    this.resources = new Map();
  }
  
  // Configuration validation
  async onValidateConfig() {
    // Validate required configuration
    if (!this.config.resourceType) {
      throw new ValidationError(
        'MISSING_RESOURCE_TYPE',
        'Resource type must be specified in configuration'
      );
    }
    return true;
  }
  
  // Setup phase
  async onConfigure() {
    // Initialize module-specific properties
    this.resourceType = this.config.resourceType;
    
    // Record metrics
    this.recordMetric('module.configuration', 1, { type: this.resourceType });
  }
  
  // Set up event handlers
  async setupEventHandlers() {
    // Listen for events from other modules
    this.eventBus.on('resource:created', this.handleResourceCreated.bind(this));
    this.eventBus.on('resource:deleted', this.handleResourceDeleted.bind(this));
    
    // Internal event handling (local)
    this.on('local:resourceUpdated', this.handleLocalUpdate.bind(this));
  }
  
  // Set up health checks
  async onSetupHealthChecks() {
    // Add custom health check
    this.registerHealthCheck('database', async () => {
      try {
        const connected = await this.db.checkConnection();
        return {
          status: connected ? 'healthy' : 'unhealthy',
          details: { connected }
        };
      } catch (error) {
        return {
          status: 'error',
          error: error.message
        };
      }
    });
    
    // Add resource health check
    this.registerHealthCheck('resources', async () => {
      return {
        status: 'healthy',
        count: this.resources.size
      };
    });
  }
  
  // Initialize business logic
  async onInitialize() {
    try {
      // Load initial data
      const items = await this.db.getResources(this.resourceType);
      
      // Store in module state
      for (const item of items) {
        this.resources.set(item.id, item);
      }
      
      // Record metric
      this.recordMetric('resources.loaded', items.length);
    } catch (error) {
      await this.handleError(error, { phase: 'initialization' });
      throw error;
    }
  }
  
  // Clean shutdown
  async onShutdown() {
    // Clean up resources
    this.resources.clear();
    
    // Clean up event listeners
    this.eventBus.removeAllListeners('resource:created');
    this.eventBus.removeAllListeners('resource:deleted');
    this.removeAllListeners('local:resourceUpdated');
  }
  
  // Business methods
  async getResource(id) {
    try {
      // Check cache first
      if (this.resources.has(id)) {
        return this.resources.get(id);
      }
      
      // Get from database
      const resource = await this.db.getResourceById(this.resourceType, id);
      
      if (resource) {
        // Update cache
        this.resources.set(id, resource);
      }
      
      return resource;
    } catch (error) {
      await this.handleError(error, { method: 'getResource', resourceId: id });
      throw error;
    }
  }
  
  async createResource(data) {
    try {
      // Validate data
      if (!data.name) {
        throw new ValidationError('MISSING_NAME', 'Resource name is required');
      }
      
      // Create in database
      const resource = await this.db.createResource(this.resourceType, data);
      
      // Update cache
      this.resources.set(resource.id, resource);
      
      // Emit events (both local and global)
      await this.emit('resource:created', { resource });
      
      return resource;
    } catch (error) {
      await this.handleError(error, { method: 'createResource', data });
      throw error;
    }
  }
  
  // Event handlers
  async handleResourceCreated(event) {
    const { resource } = event;
    if (resource.type === this.resourceType) {
      this.resources.set(resource.id, resource);
      this.recordMetric('resources.created', 1);
    }
  }
  
  async handleResourceDeleted(event) {
    const { resourceId, type } = event;
    if (type === this.resourceType && this.resources.has(resourceId)) {
      this.resources.delete(resourceId);
      this.recordMetric('resources.deleted', 1);
    }
  }
  
  async handleLocalUpdate(data) {
    // Handle local events
    console.log('Local resource update:', data);
  }
}

// Factory function for container registration
export function createCustomBusinessModule(deps = {}) {
  return new CustomBusinessModule(deps);
}
```

### Module Registration

Register your custom module with the ModuleSystem:

```javascript
// In your application initialization
import { createCustomBusinessModule } from './modules/CustomBusinessModule.js';

// Configuration for the module
const moduleConfig = {
  resourceType: 'users',
  cacheTTL: 3600
};

// Register with the ModuleSystem
const moduleSystem = container.resolve('moduleSystem');
await moduleSystem.register('userModule', createCustomBusinessModule, moduleConfig);

// Initialize the module along with others
await moduleSystem.initialize();
```

### Accessing Other Modules

Modules can depend on and access other modules:

```javascript
class BusinessModuleA extends CoreModule {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config', 'moduleB'];
  
  constructor(deps) {
    super(deps);
    this.moduleB = deps.moduleB;
  }
  
  async doSomething() {
    // Use functionality from moduleB
    const result = await this.moduleB.getSomeData();
    return result;
  }
}
```

## Troubleshooting

### Common Issues

1. **Initialization Failures**
   - Check dependency validation
   - Verify configuration
   - Review initialization hooks
   - Ensure all dependencies are registered

2. **State Management**
   - Verify state transitions
   - Check metric recording
   - Monitor error history
   - Validate state status changes

3. **Event Handling**
   - Debug local event emission
   - Verify eventBus connectivity
   - Check event handler registration
   - Confirm correct event handler binding

4. **Circular Dependencies**
   - Review module dependency graph
   - Restructure dependencies if needed
   - Consider using events for loose coupling
   - Extract shared functionality to separate modules

5. **Health Check Issues**
   - Verify health check registration
   - Ensure health check functions return correct format
   - Check interval operation
   - Validate error handling

### Debugging Techniques

1. **Trace Module Lifecycle**
   - Add listeners to initialization events
   ```javascript
   moduleSystem.on('module:initialized', (data) => {
     console.log(`Module initialized: ${data.name}`);
   });
   ```
   
2. **Monitor Health Status**
   ```javascript
   const health = await moduleSystem.getSystemHealth();
   console.log(JSON.stringify(health, null, 2));
   ```
   
3. **Track Error History**
   ```javascript
   // Check module error history
   const moduleErrors = module.state.errors;
   console.log('Module errors:', moduleErrors);
   
   // Check system error history
   const systemErrors = moduleSystem.state.errors;
   console.log('System errors:', systemErrors);
   ```
   
4. **Monitor Events**
   ```javascript
   // Add a listener to monitor all events
   eventBus.on('*', (eventName, data) => {
     console.log(`Event: ${eventName}`, data);
   });
   ```

### Common Error Codes

- `MODULE_ALREADY_INITIALIZED`: Module is already initialized
- `MODULE_INITIALIZATION_FAILED`: Failed to initialize module
- `MODULE_CONFIG_VALIDATION_FAILED`: Configuration validation failed
- `MODULE_INVALID_HEALTH_CHECK`: Invalid health check function
- `MODULE_HEALTH_CHECK_FAILED`: Module health check failed
- `MODULE_MISSING_DEPENDENCIES`: Missing required dependencies
- `MODULE_INVALID_EVENTBUS_SYSTEM`: EventBusSystem missing required methods
- `MODULE_INVALID_ERROR_SYSTEM`: ErrorSystem missing required methods
- `MODULE_SHUTDOWN_FAILED`: Failed to shutdown module
- `MODULE_DUPLICATE_MODULE`: Module is already registered
- `MODULE_MISSING_DEPENDENCY`: Module requires missing module
- `MODULE_CIRCULAR_DEPENDENCY`: Circular dependency detected
- `MODULE_MODULE_NOT_FOUND`: Module is not registered
- `MODULE_REGISTRATION_FAILED`: Failed to register module
- `MODULE_UNREGISTER_FAILED`: Failed to unregister module
- `MODULE_UNHEALTHY_MODULE`: Module is unhealthy


// server.js

import 'dotenv/config';

const { NODE_ENV = "development", PORT = 3000 } = process.env;
console.time("Start");

let address;

async function startServer() {
  if (NODE_ENV === "production") {
    const { buildApp } = await import("./dist/app.js");
    const app = await buildApp();
    address = await app.listen({ port: '3001', host: '0.0.0.0' });
  } else {
    const { once } = await import("events");
    const { createServer } = await import("vite");
    let appInstance;  // Store the built app instance

    const devServer = await createServer({
      appType: "custom",
      server: { middlewareMode: true },
    });

    const server = devServer.middlewares
      .use(async (req, res, next) => {
        try {
          if (!appInstance) {
            console.log('Building app for the first time.');
            const { buildApp } = await devServer.ssrLoadModule("./src/app.js");
            appInstance = await buildApp();
            await appInstance.ready();
          }

          console.log('Routing request:', req.url);
          appInstance.routing(req, res);
        } catch (err) {
          console.error('Error during request handling:', err);
          return next(err);
        }
      })
      .listen(PORT);

    await once(server, "listening");
    address = `http://localhost:${server.address().port}`;

    // Listen for file changes to trigger a rebuild
    devServer.watcher.on('change', (file) => {
      console.log(`File changed: ${file}. Rebuilding app...`);
      appInstance = null;  // This will trigger a rebuild on the next request
      console.log(`App rebuilt`);
    });
  }

  console.timeEnd("Start");
  console.log(`Env: ${NODE_ENV}`);
  console.log(`Address: ${address}`);
}

startServer().catch((err) => {
  console.error('Failed to start server:', err);
  process.exit(1);
});


// vite.config.js

import { defineConfig } from "vite";
import marko from "@marko/vite";
//import { resolve } from "path";

export default defineConfig({
  //root: resolve(__dirname, "src"),
  plugins: [marko()],
  build: {
    sourcemap: true, // Generate sourcemaps for all builds.
    emptyOutDir: false, // Avoid server & client deleting files from each other.
    outDir: "./dist",
  },
});


// .env

NODE_ENV="development"
PORT="3000"

DATABASE_URL='postgres://postgres:Magarao12@localhost:5432/tsmis_dev'
JWT_SECRET="hgtrh3rthhymn^^7(@jytj00*hh765y"

IPREGISTRY_API_KEY="zo2l5bcj3o5hp0"


MAIL_HOST="smtp.gmail.com"
MAIL_PORT="465"
MAIL_SECURE="true"
MAIL_USER="torosminfo@gmail.com"
MAIL_PASS="oaor cyav zijk nlqn"

HARDCODE_MODULES=false


// package.json

{
    "name": "tsmis",
    "type": "module",
    "description": "toro_sm information system",
    "version": "1.0.0",
    "dependencies": {
        "@fastify/compress": "^7.0.3",
        "@fastify/cookie": "^9.3.1",
        "@fastify/csrf-protection": "^6.4.1",
        "@fastify/formbody": "^7.4.0",
        "@fastify/helmet": "^11.1.1",
        "@fastify/jwt": "^8.0.1",
        "@fastify/postgres": "^5.2.2",
        "@fastify/rate-limit": "^9.1.0",
        "@fastify/static": "^7.0.4",
        "@ipregistry/client": "^6.0.0",
        "@marko/fastify": "^1.1.1",
        "@popperjs/core": "^2.11.8",
        "bcrypt": "^5.1.1",
        "bootstrap": "^5.3.3",
        "dotenv": "^16.4.5",
        "fastify": "^4.28.1",
        "marked": "^14.1.2",
        "marko": "^5.35.8",
        "nodemailer": "^6.9.15"
    },
    "devDependencies": {
        "@babel/core": "^7.26.7",
        "@babel/preset-env": "^7.26.7",
        "@marko/compiler": "^5.37.4",
        "@marko/vite": "^5.0.13",
        "babel-jest": "^29.7.0",
        "cross-env": "^7.0.3",
        "directory-tree-ascii": "^1.0.10",
        "jest": "^29.7.0",
        "postcss-preset-env": "^10.0.6",
        "rimraf": "^6.0.1",
        "sass": "^1.77.4",
        "vite": "^6.0.11"
    },
    "scripts": {
        "build": "rimraf dist && npm run build:server && npm run build:client",
        "build:client": "cross-env NODE_ENV=production vite build",
        "build:server": "cross-env NODE_ENV=production vite build --ssr src/app.js",
        "dev": "node --enable-source-maps server.js",
        "dev:inspect": "node --inspect --enable-source-maps server.js",
        "start": "cross-env NODE_ENV=production node --enable-source-maps server.js",
        "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
        "test:watch": "node --experimental-vm-modules node_modules/jest/bin/jest.js --watch",
        "test:coverage": "node --experimental-vm-modules node_modules/jest/bin/jest.js --coverage"
    }
}

