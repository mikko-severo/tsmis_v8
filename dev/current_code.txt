/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> tsmis@1.0.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ .env
   ├─ babel.config.js
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ dev_manual.md
   │  │  ├─ dev_roadmap.md
   │  │  └─ technical.md
   │  └─ tools
   │     ├─ combined-files.js
   │     ├─ reverse-files.js
   │     └─ setup-project.js
   ├─ jest.config.mjs
   ├─ package-lock.json
   ├─ package.json
   ├─ server.js
   ├─ src
   │  ├─ config
   │  ├─ core
   │  │  ├─ errors
   │  │  │  ├─ Error.js
   │  │  │  ├─ index.js
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js
   │  │  │     ├─ AuthError.js
   │  │  │     ├─ ConfigError.js
   │  │  │     ├─ ModuleError.js
   │  │  │     ├─ NetworkError.js
   │  │  │     ├─ ServiceError.js
   │  │  │     ├─ ValidationError.js
   │  │  │     └─ index.js
   │  │  ├─ module
   │  │  ├─ registry
   │  │  ├─ service
   │  │  └─ validation
   │  ├─ modules
   │  └─ services
   │     ├─ cache
   │     ├─ database
   │     ├─ email
   │     ├─ ip
   │     └─ logger
   ├─ tests
   │  ├─ core
   │  │  └─ errors
   │  │     ├─ Error.test.js
   │  │     ├─ integration.test.js
   │  │     └─ types
   │  │        ├─ ErrorTypes.test.js
   │  │        └─ index.test.js
   │  └─ index.test.js
   └─ vite.config.js

```
*/


// src/core/errors/Error.js

/**
 * Universal base error class for both client and server environments
 * @extends Error
 */
export class CoreError extends Error {
  /**
   * Create a new CoreError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(message);
    
    // Basic properties
    this.name = this.constructor.name;
    this.code = code;
    this.details = this.sanitizeDetails(details);
    this.timestamp = new Date().toISOString();

      //Debug line 29
      // console.log('Line 29 debug:', {
      //   hasOptions: options !== undefined,
      //   hasCause: options?.cause !== undefined,
      //   causeValue: options?.cause
      // });

    // Handle error cause
    this.initCause(options?.cause);
    
    // Ensure instanceof works correctly
    Object.setPrototypeOf(this, new.target.prototype);
    
    // Capture stack trace if available
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Format stack for browser environment
    if (this.isClientEnvironment()) {
      this.stack = this.formatStackTrace(this.stack);
    }
  }

  /**
   * Initialize error cause with proper error instance
   * @private
   */
  initCause(cause) {
    const ensureValidName = (error) => {
      // Reset to 'Error' if name is empty or only whitespace
      if (!error.name || !error.name.trim()) {
        error.name = 'Error';
      }
      return error;
    };
  
    if (cause instanceof Error) {
      this.cause = ensureValidName(cause);
    } else if (cause && typeof cause === 'object') {
      const error = new Error(cause.message || JSON.stringify(cause));
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        error.name = cause.name;
      }
      this.cause = error;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause);
    }
  }

  /**
   * Sanitize error details for safe serialization
   * @private
   */
  sanitizeDetails(details) {
    try {
      // Test if details can be safely serialized
      JSON.stringify(details);
      return details;
    } catch (error) {
      // If serialization fails, return safe version
      return { 
        error: 'Details contained non-serializable values',
        safeDetails: String(details)
      };
    }
  }

  /**
   * Format stack trace for better readability
   * @private
   */
  formatStackTrace(stack) {
    if (!stack) return stack;
    
    return stack
      .split('\n')
      .filter(line => line.trim())
      .map(line => line.replace(/^ {4}at /, ''))
      .join('\n');
  }

  /**
   * Check if running in client environment
   * @private
   */
  isClientEnvironment() {
    return typeof window !== 'undefined';
  }

  /**
   * Check if running in development environment
   * @private
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';
    }
    return this.isClientEnvironment() && window.ENV === 'development';
  }

  /**
   * Convert error to JSON format
   */
  toJSON() {
    const json = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp
    };
  
    // Only include stack if it exists AND we're in dev
    if (this.isDevEnvironment() && this.stack) {
      json.stack = this.stack;
    }
  
    // Include cause if present
    if (this.cause) {
      json.cause = {
        message: this.cause.message,
        name: this.cause.name || 'Error'
      };
      
      // Only include cause stack if it exists AND we're in dev
      if (this.isDevEnvironment() && this.cause.stack) {
        json.cause.stack = this.cause.stack;
      }
    }
  
    return json;
  }

  /**
   * Create error instance from JSON data
   * @static
   */
  static fromJSON(data) {
    const options = {};
    
    if (data.cause) {
      if (typeof data.cause === 'string') {
        options.cause = data.cause;
      } else {
        options.cause = {
          message: data.cause.message,
          name: data.cause.name
        };
      }
    }

    return new this(
      data.code,
      data.message,
      data.details || {},
      options
    );
  }
}


// src/core/errors/index.js

import { CoreError } from './Error.js';
import {
  AccessError,
  AuthError,
  ConfigError,
  ModuleError,
  NetworkError,
  ServiceError,
  ValidationError
} from './types/index.js';

// Export all error classes
export {
  CoreError,
  AccessError,
  AuthError,
  ConfigError,
  ModuleError,
  NetworkError,
  ServiceError,
  ValidationError
};

/**
 * Standard error codes
 */
export const ErrorCodes = {
  // Core errors
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },

  // Module related
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    ROUTE: 'ROUTE_ERROR'
  },

  // Service related
  SERVICE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    CONFIGURATION: 'CONFIGURATION_ERROR',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    RUNTIME: 'RUNTIME_ERROR'
  },

  // Configuration related
  CONFIG: {
    VALIDATION: 'VALIDATION_FAILED',
    MISSING: 'MISSING_REQUIRED',
    INVALID: 'INVALID_VALUE'
  },

  // Validation related
  VALIDATION: {
    SCHEMA: 'SCHEMA_VALIDATION_FAILED',
    TYPE: 'INVALID_TYPE',
    REQUIRED: 'REQUIRED_FIELD_MISSING'
  },

  // Network related
  NETWORK: {
    REQUEST: 'REQUEST_FAILED',
    RESPONSE: 'RESPONSE_ERROR',
    TIMEOUT: 'REQUEST_TIMEOUT'
  },

  // Authentication related
  AUTH: {
    UNAUTHORIZED: 'UNAUTHORIZED',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    INVALID_TOKEN: 'INVALID_TOKEN'
  },

  // Authorization related
  ACCESS: {
    FORBIDDEN: 'FORBIDDEN',
    INSUFFICIENT_RIGHTS: 'INSUFFICIENT_RIGHTS',
    RESOURCE_ACCESS_DENIED: 'RESOURCE_ACCESS_DENIED'
  }
};

/**
 * Create error instance from error response data
 * @param {Object} response - Error response data
 * @param {string} [defaultMessage] - Default error message
 * @returns {CoreError} Error instance
 */
export function createErrorFromResponse(response, defaultMessage = 'Unknown error occurred') {
  const errorData = response.data || response;
  
  // Map error names to constructors
  const errorTypes = {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError,
    CoreError
  };

  // Get appropriate error constructor
  const ErrorConstructor = errorTypes[errorData.name] || CoreError;

  return new ErrorConstructor(
    errorData.code || ErrorCodes.CORE.UNKNOWN,
    errorData.message || defaultMessage,
    errorData.details || {},
    { cause: response }
  );
}


// src/core/errors/types/AccessError.js

import { CoreError } from '../Error.js';

/**
 * Authorization and access control related errors
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Create a new AccessError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options);
    this.statusCode = 403;
  }
}


// src/core/errors/types/AuthError.js

import { CoreError } from '../Error.js';

/**
 * Authentication related errors
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Create a new AuthError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options);
    this.statusCode = 401;
  }
}


// src/core/errors/types/ConfigError.js

import { CoreError } from '../Error.js';

/**
 * Configuration related errors
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Create a new ConfigError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/ModuleError.js

import { CoreError } from '../Error.js';

/**
 * Module system related errors
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Create a new ModuleError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/NetworkError.js

import { CoreError } from '../Error.js';

/**
 * Network related errors
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Create a new NetworkError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options);
    // Use provided status code or default to 503
    this.statusCode = details.statusCode || 503;
  }
}


// src/core/errors/types/ServiceError.js

import { CoreError } from '../Error.js';

/**
 * Service related errors
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Create a new ServiceError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options);
    this.statusCode = 503;
  }
}


// src/core/errors/types/ValidationError.js

import { CoreError } from '../Error.js';

/**
 * Validation related errors
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Create a new ValidationError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details with validation errors
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options);
    this.statusCode = 400;
    this.validationErrors = this.validationErrors = Array.isArray(details.validationErrors) ? details.validationErrors : [];
  }

  /**
   * Convert to JSON format with validation errors
   */
  toJSON() {
    const json = super.toJSON();
    json.validationErrors = this.validationErrors;
    return json;
  }

  /**
   * Create from JSON with validation errors
   * @param {Object} data - JSON data
   */
  static fromJSON(data) {
    const error = super.fromJSON(data);
    error.validationErrors = Array.isArray(data.validationErrors) ? data.validationErrors : [];
    return error;
  }
}


// src/core/errors/types/index.js

export { AccessError } from './AccessError.js';
export { AuthError } from './AuthError.js';
export { ConfigError } from './ConfigError.js';
export { ModuleError } from './ModuleError.js';
export { NetworkError } from './NetworkError.js';
export { ServiceError } from './ServiceError.js';
export { ValidationError } from './ValidationError.js';


// server.js

import 'dotenv/config';

const { NODE_ENV = "development", PORT = 3000 } = process.env;
console.time("Start");

let address;

async function startServer() {
  if (NODE_ENV === "production") {
    const { buildApp } = await import("./dist/app.js");
    const app = await buildApp();
    address = await app.listen({ port: '3001', host: '0.0.0.0' });
  } else {
    const { once } = await import("events");
    const { createServer } = await import("vite");
    let appInstance;  // Store the built app instance

    const devServer = await createServer({
      appType: "custom",
      server: { middlewareMode: true },
    });

    const server = devServer.middlewares
      .use(async (req, res, next) => {
        try {
          if (!appInstance) {
            console.log('Building app for the first time.');
            const { buildApp } = await devServer.ssrLoadModule("./src/app.js");
            appInstance = await buildApp();
            await appInstance.ready();
          }

          console.log('Routing request:', req.url);
          appInstance.routing(req, res);
        } catch (err) {
          console.error('Error during request handling:', err);
          return next(err);
        }
      })
      .listen(PORT);

    await once(server, "listening");
    address = `http://localhost:${server.address().port}`;

    // Listen for file changes to trigger a rebuild
    devServer.watcher.on('change', (file) => {
      console.log(`File changed: ${file}. Rebuilding app...`);
      appInstance = null;  // This will trigger a rebuild on the next request
      console.log(`App rebuilt`);
    });
  }

  console.timeEnd("Start");
  console.log(`Env: ${NODE_ENV}`);
  console.log(`Address: ${address}`);
}

startServer().catch((err) => {
  console.error('Failed to start server:', err);
  process.exit(1);
});


// vite.config.js

import { defineConfig } from "vite";
import marko from "@marko/vite";
//import { resolve } from "path";

export default defineConfig({
  //root: resolve(__dirname, "src"),
  plugins: [marko()],
  build: {
    sourcemap: true, // Generate sourcemaps for all builds.
    emptyOutDir: false, // Avoid server & client deleting files from each other.
    outDir: "./dist",
  },
});


// .env

NODE_ENV="development"
PORT="3000"

DATABASE_URL='postgres://postgres:Magarao12@localhost:5432/tsmis_dev'
JWT_SECRET="hgtrh3rthhymn^^7(@jytj00*hh765y"

IPREGISTRY_API_KEY="zo2l5bcj3o5hp0"


MAIL_HOST="smtp.gmail.com"
MAIL_PORT="465"
MAIL_SECURE="true"
MAIL_USER="torosminfo@gmail.com"
MAIL_PASS="oaor cyav zijk nlqn"

HARDCODE_MODULES=false


// package.json

{
    "name": "tsmis",
    "type": "module",
    "description": "toro_sm information system",
    "version": "1.0.0",
    "dependencies": {
        "@fastify/compress": "^7.0.3",
        "@fastify/cookie": "^9.3.1",
        "@fastify/csrf-protection": "^6.4.1",
        "@fastify/formbody": "^7.4.0",
        "@fastify/helmet": "^11.1.1",
        "@fastify/jwt": "^8.0.1",
        "@fastify/postgres": "^5.2.2",
        "@fastify/rate-limit": "^9.1.0",
        "@fastify/static": "^7.0.4",
        "@ipregistry/client": "^6.0.0",
        "@marko/fastify": "^1.1.1",
        "@popperjs/core": "^2.11.8",
        "bcrypt": "^5.1.1",
        "bootstrap": "^5.3.3",
        "dotenv": "^16.4.5",
        "fastify": "^4.28.1",
        "marked": "^14.1.2",
        "marko": "^5.35.8",
        "nodemailer": "^6.9.15"
    },
    "devDependencies": {
        "@babel/core": "^7.26.7",
        "@babel/preset-env": "^7.26.7",
        "@marko/compiler": "^5.37.4",
        "@marko/vite": "^5.0.13",
        "babel-jest": "^29.7.0",
        "cross-env": "^7.0.3",
        "directory-tree-ascii": "^1.0.10",
        "jest": "^29.7.0",
        "postcss-preset-env": "^10.0.6",
        "rimraf": "^6.0.1",
        "sass": "^1.77.4",
        "vite": "^6.0.11"
    },
    "scripts": {
        "build": "rimraf dist && npm run build:server && npm run build:client",
        "build:client": "cross-env NODE_ENV=production vite build",
        "build:server": "cross-env NODE_ENV=production vite build --ssr src/app.js",
        "dev": "node --enable-source-maps server.js",
        "dev:inspect": "node --inspect --enable-source-maps server.js",
        "start": "cross-env NODE_ENV=production node --enable-source-maps server.js",
        "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
        "test:watch": "node --experimental-vm-modules node_modules/jest/bin/jest.js --watch",
        "test:coverage": "node --experimental-vm-modules node_modules/jest/bin/jest.js --coverage"
    }
}

