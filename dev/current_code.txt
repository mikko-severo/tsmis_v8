/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> tsmis@1.0.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ .env
   ├─ babel.config.js
   ├─ coverage
   │  ├─ clover.xml
   │  ├─ coverage-final.json
   │  ├─ lcov-report
   │  │  ├─ base.css
   │  │  ├─ block-navigation.js
   │  │  ├─ container
   │  │  │  ├─ Container.js.html
   │  │  │  └─ index.html
   │  │  ├─ core
   │  │  │  ├─ bootstrap.js.html
   │  │  │  ├─ container
   │  │  │  │  ├─ Container.js.html
   │  │  │  │  └─ index.html
   │  │  │  ├─ errors
   │  │  │  │  ├─ Error.js.html
   │  │  │  │  ├─ ErrorService.js.html
   │  │  │  │  ├─ index.html
   │  │  │  │  ├─ index.js.html
   │  │  │  │  ├─ integrations
   │  │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  │  ├─ fastify
   │  │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  │  ├─ index.html
   │  │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  │  └─ index.html
   │  │  │  │  ├─ manifest.js.html
   │  │  │  │  └─ types
   │  │  │  │     ├─ AccessError.js.html
   │  │  │  │     ├─ AuthError.js.html
   │  │  │  │     ├─ ConfigError.js.html
   │  │  │  │     ├─ ModuleError.js.html
   │  │  │  │     ├─ NetworkError.js.html
   │  │  │  │     ├─ ServiceError.js.html
   │  │  │  │     ├─ ValidationError.js.html
   │  │  │  │     ├─ index.html
   │  │  │  │     └─ index.js.html
   │  │  │  └─ index.html
   │  │  ├─ errors
   │  │  │  ├─ Error.js.html
   │  │  │  ├─ ErrorSystem.js.html
   │  │  │  ├─ index.html
   │  │  │  ├─ index.js.html
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  ├─ fastify
   │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  ├─ index.html
   │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  └─ index.html
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js.html
   │  │  │     ├─ AuthError.js.html
   │  │  │     ├─ ConfigError.js.html
   │  │  │     ├─ ModuleError.js.html
   │  │  │     ├─ NetworkError.js.html
   │  │  │     ├─ ServiceError.js.html
   │  │  │     ├─ ValidationError.js.html
   │  │  │     ├─ index.html
   │  │  │     └─ index.js.html
   │  │  ├─ event
   │  │  │  ├─ EventBus.js.html
   │  │  │  ├─ EventBusSystem.js.html
   │  │  │  └─ index.html
   │  │  ├─ favicon.png
   │  │  ├─ index.html
   │  │  ├─ module
   │  │  │  ├─ Module.js.html
   │  │  │  ├─ ModuleSystem.js.html
   │  │  │  └─ index.html
   │  │  ├─ prettify.css
   │  │  ├─ prettify.js
   │  │  ├─ sort-arrow-sprite.png
   │  │  └─ sorter.js
   │  └─ lcov.info
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ claude_prompt.md
   │  │  ├─ dev_manual.md
   │  │  ├─ dev_roadmap.md
   │  │  └─ technical.md
   │  └─ tools
   │     ├─ combined-files.js
   │     ├─ reverse-files.js
   │     └─ setup-project.js
   ├─ jest.config.mjs
   ├─ package-lock.json
   ├─ package.json
   ├─ server.js
   ├─ src
   │  ├─ app.js
   │  ├─ config
   │  ├─ core
   │  │  ├─ container
   │  │  │  ├─ Container.js
   │  │  │  └─ container-system-docs.md
   │  │  ├─ errors
   │  │  │  ├─ Error.js
   │  │  │  ├─ ErrorSystem.js
   │  │  │  ├─ error-system-docs.md
   │  │  │  ├─ index.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.js
   │  │  │  │     ├─ handler.js
   │  │  │  │     ├─ index.js
   │  │  │  │     └─ serializer.js
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js
   │  │  │     ├─ AuthError.js
   │  │  │     ├─ ConfigError.js
   │  │  │     ├─ ModuleError.js
   │  │  │     ├─ NetworkError.js
   │  │  │     ├─ ServiceError.js
   │  │  │     ├─ ValidationError.js
   │  │  │     └─ index.js
   │  │  ├─ event
   │  │  │  ├─ EventBus.js
   │  │  │  ├─ EventBusSystem.js
   │  │  │  └─ event-bus-docs.md
   │  │  ├─ module
   │  │  │  ├─ Module.js
   │  │  │  ├─ ModuleSystem.js
   │  │  │  └─ module-system-docs.md
   │  │  ├─ service
   │  │  └─ validation
   │  ├─ modules
   │  └─ services
   │     ├─ cache
   │     ├─ database
   │     ├─ email
   │     ├─ ip
   │     └─ logger
   ├─ tests
   │  ├─ core
   │  │  ├─ container
   │  │  │  └─ Container.test.js
   │  │  ├─ errors
   │  │  │  ├─ Error.test.js
   │  │  │  ├─ ErrorSystem.test.js
   │  │  │  ├─ integration.test.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.test.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.test.js
   │  │  │  │     ├─ handler.test.js
   │  │  │  │     └─ serializer.test.js
   │  │  │  └─ types
   │  │  │     ├─ ErrorTypes.test.js
   │  │  │     └─ index.test.js
   │  │  └─ module
   │  │     ├─ Module.test.js
   │  │     └─ ModuleSystem.test.js
   │  └─ index.test.js
   └─ vite.config.js

```
*/


// src/app.js

// src/app.js

import 'dotenv/config';
import Fastify from 'fastify';

// Core System Imports
import { CoreContainer } from './core/container/Container.js';
import { createErrorSystem } from './core/errors/ErrorSystem.js';
import { setupErrorHandler } from './core/errors/integrations/fastify/handler.js';
import { createModuleSystem } from './core/module/ModuleSystem.js';
import { createEventBusSystem } from './core/event/EventBusSystem.js';

export async function buildApp() {
  // Create the core container
  const container = new CoreContainer();

  // Register core systems in proper order
  container.register('errorSystem', createErrorSystem);
  container.register('config', () => ({}));
  container.register('eventBusSystem', createEventBusSystem);
  container.register('moduleSystem', createModuleSystem);

  // Create Fastify instance with error serialization
  const fastify = Fastify({
    logger: {
      level: process.env.LOG_LEVEL || 'info',
      serializers: {
        error: (error) => {
          const errorSystem = container.resolve('errorSystem');
          return errorSystem.serializeError(error);
        }
      }
    }
  });

  // Setup Fastify error handling - THIS LINE IS PRESENT
  setupErrorHandler(fastify);

  // Initialize the container
  try {
    await container.initialize();
  } catch (error) {
    console.error('Container initialization error:', error);
    throw error;
  }

  // Basic route as a health check
  fastify.get('/', async (request, reply) => {
    return { 
      status: 'ok', 
      timestamp: new Date().toISOString() 
    };
  });

  // Graceful shutdown handling
  const closeHandler = async () => {
    try {
      await fastify.close();
      await container.shutdown();
    } catch (error) {
      console.error('Shutdown error:', error);
    }
  };

  // Handle shutdown signals
  process.on('SIGINT', closeHandler);
  process.on('SIGTERM', closeHandler);
  fastify.addHook('onClose', async () => {
    await container.shutdown();
  });

  return fastify;
}


// src/core/container/Container.js

// src/core/container/Container.js

import { EventEmitter } from 'events';
import { CoreError, ConfigError, ServiceError } from '../errors/index.js';
// import { ValidationService } from '../validation/ValidationService.js';

export class CoreContainer extends EventEmitter {
  constructor() {
    super();
    this.components = new Map();
    this.instances = new Map();
    this.dependencies = new Map();
    this.manifests = new Map();
    this.initialized = false;
  }

  /**
   * Register a component manifest
   * @param {string} type - Component type
   * @param {object} manifest - Component manifest
   */
  registerManifest(type, manifest) {
    if (this.manifests.has(type)) {
      throw new ConfigError(
        'DUPLICATE_MANIFEST',
        `Manifest already registered for type: ${type}`
      );
    }
    this.manifests.set(type, manifest);
    this.emit('manifest:registered', { type, manifest });
  }

  /**
   * Register a component with the container
   * @param {string} name - Component name
   * @param {Class} Component - Component constructor
   * @param {object} options - Registration options
   */
  register(name, Component, options = {}) {
    if (this.components.has(name)) {
      throw new ConfigError(
        'DUPLICATE_COMPONENT',
        `Component ${name} is already registered`
      );
    }

    // Store component definition
    this.components.set(name, {
      Component,
      options: {
        singleton: true,
        ...options
      }
    });

    // Store dependencies
    this.dependencies.set(name, Component.dependencies || []);

    this.emit('component:registered', { name, Component });
    return this;
  }

  /**
   * Discover components in a directory
   * @param {string} type - Component type
   * @param {string} basePath - Base directory path
   */
  async discover(type, basePath) {
    if (!this.manifests.has(type)) {
      throw new ConfigError(
        'INVALID_TYPE',
        `No manifest registered for type: ${type}`
      );
    }

    try {
      const manifest = this.manifests.get(type);
      const componentPaths = await this.scanDirectory(basePath);
      const discoveredComponents = new Map();

      for (const path of componentPaths) {
        try {
          const component = await this.loadComponent(path, manifest);
          if (component) {
            discoveredComponents.set(component.name, component);
          }
        } catch (error) {
          this.emit('discovery:error', { path, error });
        }
      }

      this.emit('discovery:completed', { type, components: discoveredComponents });
      return discoveredComponents;
    } catch (error) {
      throw new ServiceError(
        'DISCOVERY_FAILED',
        `Failed to discover ${type} components`,
        { originalError: error }
      );
    }
  }

  /**
   * Load a component from a path
   * @private
   */
  async loadComponent(path, manifest) {
    try {
      const config = await this.loadConfig(path);
      if (config.enabled === false) return null;

      await this.validateConfig(config, manifest.configSchema);
      const implementation = await this.loadImplementation(path);

      return {
        name: config.name,
        config,
        implementation
      };
    } catch (error) {
      throw new ConfigError(
        'LOAD_FAILED',
        `Failed to load component from ${path}`,
        { originalError: error }
      );
    }
  }

  /**
   * Get an instance of a component
   * @param {string} name - Component name
   */
  async resolve(name) {
    if (!this.components.has(name)) {
      throw new ServiceError(
        'UNKNOWN_COMPONENT',
        `Component ${name} is not registered`
      );
    }
  
    const { Component, options } = this.components.get(name);
  
    // Return existing instance for singletons
    if (options.singleton && this.instances.has(name)) {
      return this.instances.get(name);
    }
  
    // Resolve dependencies first
    const deps = this.dependencies.get(name) || [];
    const resolvedDeps = {};
  
    for (const dep of deps) {
      resolvedDeps[dep] = await this.resolve(dep);
    }
  
    // Handle different component types
    let instance;
    if (typeof Component === 'function') {
      if (Component.prototype) {
        // Class constructor
        instance = new Component(resolvedDeps);
      } else {
        // Factory function - handle both sync and async
        instance = await Promise.resolve(Component(resolvedDeps));
      }
    } else {
      instance = Component;
    }
  
    // Initialize if container is initialized
    if (this.initialized && typeof instance.initialize === 'function') {
      await instance.initialize();
    }
  
    // Cache singleton instance
    if (options.singleton) {
      this.instances.set(name, instance);
    }
  
    this.emit('component:resolved', { name, instance });
    return instance;
  }
  /**
   * Initialize all registered components
   */
  async initialize() {
    if (this.initialized) {
      throw new ServiceError(
        'ALREADY_INITIALIZED',
        'Container is already initialized'
      );
    }
    //console.log('Initializing Container...');
    const order = this.resolveDependencyOrder();

    for (const name of order) {
      //console.log(`Resolving component: ${name}`);
      const instance = await this.resolve(name);
      if (typeof instance.initialize === 'function') {
        //console.log(`Initializing component: ${name}`);
        await instance.initialize();
      }
    }

    this.initialized = true;
    this.emit('initialized');

    
  }

  /**
   * Resolve dependency order for initialization
   * @private
   */
  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ConfigError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected: ${name}`
        );
      }

      visiting.add(name);
      
      const component = this.components.get(name);
      const deps = this.dependencies.get(name) || [];
      
      for (const dep of deps) {
        if (!this.components.has(dep)) {
          throw new ConfigError(
            'MISSING_DEPENDENCY',
            `Dependency ${dep} required by ${name} is not registered`
          );
        }
        visit(dep);
      }
      
      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    // Ensure core systems are initialized first
    const initOrder = [
      'errorSystem',
      'config',
      'eventBusSystem',
      'moduleSystem'
    ];

    for (const name of initOrder) {
      if (this.components.has(name)) {
        visit(name);
      }
    }

    // Then handle any remaining components
    for (const name of this.components.keys()) {
      if (!order.includes(name)) {
        visit(name);
      }
    }

    return order;
  }

async shutdown() {
    // Shutdown in reverse dependency order
    const order = this.resolveDependencyOrder().reverse();
  
    for (const name of order) {
      const instance = this.instances.get(name);
      if (instance && typeof instance.shutdown === 'function') {
        try {
          await instance.shutdown();
        } catch (error) {
          // Log error but continue shutdown process
          this.emit('shutdown:error', { 
            component: name, 
            error 
          });
        }
      }
    }
  
    this.instances.clear();
    this.initialized = false;
    this.emit('shutdown');
  }
}


// src/core/container/container-system-docs.md

# CoreContainer System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Core Concepts](#core-concepts)
5. [Installation](#installation)
6. [Usage](#usage)
7. [Advanced Features](#advanced-features)
8. [Best Practices](#best-practices)
9. [Extending the System](#extending-the-system)
10. [Troubleshooting](#troubleshooting)

## Overview

The CoreContainer System is a sophisticated Dependency Injection (DI) and Inversion of Control (IoC) container designed to manage component lifecycles, dependencies, and system initialization. It is responsible for managing the lifecycle and dependencies of the core systems and components in the application, including the ErrorSystem, ModuleSystem, and other registered components.


## Purpose

The primary goals of the CoreContainer System are to:
- Manage component dependencies
- Facilitate loose coupling between system components
- Automate component initialization and shutdown
- Provide a centralized component registry
- Support complex dependency graphs

## System Architecture

### Core Components

1. **CoreContainer** (`src/core/container/Container.js`)
   - Central component management system
   - Handles component registration
   - Manages dependency resolution
   - Controls component lifecycle

### Architecture Diagram

```mermaid
graph TD
    A[CoreContainer] --> B[Component Registration]
    A --> C[Dependency Resolution]
    A --> D[Lifecycle Management]
    
    B --> E[Singleton/Transient Components]
    B --> F[Dependency Tracking]
    
    C --> G[Topological Sorting]
    C --> H[Circular Dependency Detection]
    
    D --> I[Initialization]
    D --> J[Shutdown]
    D --> K[Event Emission]
```

## Core Concepts

### Component Registration

- Components can be registered with optional configuration
- Supports singleton and transient component modes
- Tracks component dependencies
- Supports class and factory function registration

### Dependency Resolution

- Automatically resolves and injects dependencies
- Supports complex dependency graphs
- Prevents circular dependencies
- Ensures correct initialization order

### Lifecycle Management

- Provides `initialize()` and `shutdown()` methods
- Supports component-specific initialization logic
- Graceful shutdown with error handling

### Component Discovery

- Supports component discovery through manifest registration
- Allows for dynamic component loading based on manifests

## Installation

```bash
npm install @your-org/core-container-system
```

## Usage

### Basic Component Registration

```javascript
import { CoreContainer } from '@your-org/core-container-system';

// Class registration
class LoggerService {}

container.register('logger', LoggerService);

// Factory function registration
const createDatabaseService = (deps) => {
  return {
    query: () => { /* ... */ }
  };
};

container.register('database', createDatabaseService);
```

### Singleton vs Transient Components

```javascript
// Singleton registration (default)
container.register('service', ServiceClass);

// Transient registration
container.register('repository', RepositoryClass, { singleton: false });
```

### Advanced Dependency Injection

```javascript
class AuthService {
  constructor(deps) {
    this.database = deps.database;
    this.logger = deps.logger;
  }
}

container.register('auth', AuthService);
```

### Component Discovery with Manifests

```javascript
// Register a component manifest
container.registerManifest('service', {
  configSchema: {
    /* ... */
  }
});

// Discover components based on the manifest
await container.discover('service', './services');
```

### Initialization Process

The `CoreContainer.initialize` method is responsible for initializing the registered components in the correct dependency order. It performs the following steps:

1. Resolves the dependency order of the registered components.
2. Iterates over the components in the resolved order.
3. Resolves each component using the `CoreContainer.resolve` method.
4. If the resolved component has an `initialize` method, it calls component.initialize() to initialize the component.

During this process, the `ErrorSystem`, `ModuleSystem`, and any other registered components that have an initialize method are initialized

### Shutdown Process

The `CoreContainer.shutdown` method is responsible for shutting down the initialized components in the reverse dependency order. It performs the following steps:

1. Resolves the dependency order of the initialized components.
2. Iterates over the components in the reverse order.
3. If the component has a `shutdown` method, it calls component.shutdown() to shut down the component.

During this process, the `ErrorSystem`, `ModuleSystem`, and any other initialized components with a shutdown method are properly shut down.

### Component Registration

Components, including the core systems like `ErrorSystem` and `ModuleSystem`, are registered with the `CoreContainer` using the `CoreContainer.register` method. The registration process involves providing a unique name for the component and either a constructor function or a factory function that creates an instance of the component.

The `ErrorSystem` and `ModuleSystem` are typically registered as factory functions in the buildApp function of src/app.js

```javascript
const errorSystemFactory = () => {
  return createErrorSystem({
    logger: console
  });
};
container.register('errorSystem', errorSystemFactory);

const moduleSystemFactory = (deps) => {
  return createModuleSystem(deps);
};
container.register('moduleSystem', moduleSystemFactory);
```

## Advanced Features

### Event Handling

```javascript
container.on('component:registered', ({ name, component }) => {
  console.log(`Component ${name} registered`);
});
```

### Dependency Injection Modes

- Constructor injection
- Factory function injection

## Best Practices

1. Declare component dependencies explicitly
2. Use interfaces for dependency contracts
3. Register components with clear names
4. Use singleton components judiciously
5. Handle initialization and shutdown properly

## Extending the System

### Custom Component Lifecycle

```javascript
class CustomComponent {
  async initialize() {
    // Custom initialization
  }

  async shutdown() {
    // Custom cleanup
  }
}
```

### Custom Component Discovery

```javascript
container.registerManifest('repository', {
  configSchema: {
    /* ... */
  },
  async discover(container) {
    // Custom discovery logic
  }
});
```

## Troubleshooting

### Common Issues

- Circular dependencies
- Incorrect component registration
- Missing dependencies during resolution

### Debugging Tips

- Use `container.on('error', ...)` to catch container errors
- Inspect the container's `components` and `dependencies` maps
- Use `container.resolve(name)` to manually resolve components

## Limitations

- No support for dynamic component replacement
- Limited support for async factory functions
- No built-in support for scoped containers

## Future Roadmap

- [ ] Async component initialization
- [ ] Scoped container support
- [ ] Dynamic component replacement
- [ ] Improved error handling and diagnostics

## Contributing

Contributions are welcome! Please follow the guidelines in CONTRIBUTING.md.

## License

[Your License Information]


// src/core/errors/Error.js

/**
 * Universal base error class for both client and server environments
 * @extends Error
 */
export class CoreError extends Error {
  /**
   * Create a new CoreError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(message);
    
    // Basic properties
    this.name = this.constructor.name;
    this.code = code;
    this.details = this.sanitizeDetails(details);
    this.timestamp = new Date().toISOString();

      //Debug line 29
      // console.log('Line 29 debug:', {
      //   hasOptions: options !== undefined,
      //   hasCause: options?.cause !== undefined,
      //   causeValue: options?.cause
      // });

    // Handle error cause
    this.initCause(options?.cause);
    
    // Ensure instanceof works correctly
    Object.setPrototypeOf(this, new.target.prototype);
    
    // Capture stack trace if available
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Format stack for browser environment
    if (this.isClientEnvironment()) {
      this.stack = this.formatStackTrace(this.stack);
    }
  }

  /**
   * Initialize error cause with proper error instance
   * @private
   */
  initCause(cause) {
    const ensureValidName = (error) => {
      // Reset to 'Error' if name is empty or only whitespace
      if (!error.name || !error.name.trim()) {
        error.name = 'Error';
      }
      return error;
    };
  
    if (cause instanceof Error) {
      this.cause = ensureValidName(cause);
    } else if (cause && typeof cause === 'object') {
      const error = new Error(cause.message || JSON.stringify(cause));
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        error.name = cause.name;
      }
      this.cause = error;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause);
    }
  }

  /**
   * Sanitize error details for safe serialization
   * @private
   */
  sanitizeDetails(details) {
    try {
      // Test if details can be safely serialized
      JSON.stringify(details);
      return details;
    } catch (error) {
      // If serialization fails, return safe version
      return { 
        error: 'Details contained non-serializable values',
        safeDetails: String(details)
      };
    }
  }

  /**
   * Format stack trace for better readability
   * @private
   */
  formatStackTrace(stack) {
    if (!stack) return stack;
    
    return stack
      .split('\n')
      .filter(line => line.trim())
      .map(line => line.replace(/^ {4}at /, ''))
      .join('\n');
  }

  /**
   * Check if running in client environment
   * @private
   */
  isClientEnvironment() {
    return typeof window !== 'undefined';
  }

  /**
   * Check if running in development environment
   * @private
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';
    }
    return this.isClientEnvironment() && window.ENV === 'development';
  }

  /**
   * Convert error to JSON format
   */
  toJSON() {
    const json = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp
    };
  
    // Only include stack if it exists AND we're in dev
    if (this.isDevEnvironment() && this.stack) {
      json.stack = this.stack;
    }
  
    // Include cause if present
    if (this.cause) {
      json.cause = {
        message: this.cause.message,
        name: this.cause.name || 'Error'
      };
      
      // Only include cause stack if it exists AND we're in dev
      if (this.isDevEnvironment() && this.cause.stack) {
        json.cause.stack = this.cause.stack;
      }
    }
  
    return json;
  }

  /**
   * Create error instance from JSON data
   * @static
   */
  static fromJSON(data) {
    const options = {};
    
    if (data.cause) {
      if (typeof data.cause === 'string') {
        options.cause = data.cause;
      } else {
        options.cause = {
          message: data.cause.message,
          name: data.cause.name
        };
      }
    }

    return new this(
      data.code,
      data.message,
      data.details || {},
      options
    );
  }
}


// src/core/errors/ErrorSystem.js

// src/core/errors/ErrorSystem.js

import { EventEmitter } from 'events';
import { CoreError } from './Error.js';
import { ErrorTypes } from './types/index.js';
import { FastifyIntegration } from './integrations/fastify/FastifyIntegration.js';

export class ErrorSystem extends EventEmitter {
  static dependencies = ['logger'];

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.logger = deps.logger || console;
    this.integrations = new Map();
    this.handlers = new Map();
    this.errorTypes = new Map(Object.entries(ErrorTypes));
    this.initialized = false;

      // Ensure a default handler is always present
  this.registerHandler('*', this.defaultErrorHandler.bind(this));
  }

  async initialize() {
    if (this.initialized) {
      throw new Error('Already initialized');
    }

    // Register default handler
    this.registerHandler('*', this.defaultErrorHandler.bind(this));
    
    // Validate error types
    for (const [name, ErrorType] of this.errorTypes) {
      if (!(ErrorType.prototype instanceof CoreError)) {
        throw new CoreError('INVALID_ERROR_TYPE', `Error type ${name} must extend CoreError`);
      }
    }

    this.initialized = true;
    this.emit('initialized');
  }

  registerIntegration(framework, options = {}) {
    if (!framework) {
      throw new CoreError('INVALID_FRAMEWORK', 'Framework is required');
    }

    const integration = new FastifyIntegration();
    integration.initialize(framework, options);
    
    this.integrations.set(framework, integration);
    return integration;
  }

  registerHandler(errorType, handler) {
    if (typeof handler !== 'function') {
      throw new CoreError('INVALID_HANDLER', 'Handler must be a function');
    }
    this.handlers.set(errorType, handler);
  }

  async handleError(error, context = {}) {
    // Ensure we always have a handler
    const handler = this.handlers.get(error.constructor.name) || this.handlers.get('*') || this.defaultErrorHandler;
  
    try {
      await handler(error, context);
      this.emit('error:handled', { error, context });
    } catch (handlerError) {
      this.logger.error('Error handler failed:', handlerError);
      this.emit('error:handler:failed', { error: handlerError, originalError: error });
      throw handlerError;
    }
  }

// Ensure defaultErrorHandler is always a function
defaultErrorHandler(error, context = {}) {
  this.logger.error('Unhandled error:', {
    type: error.constructor.name,
    code: error.code,
    message: error.message,
    details: error.details,
    context
  });
}

  createError(type, code, message, details = {}, options = {}) {
    const ErrorType = this.errorTypes.get(type) || CoreError;
    return new ErrorType(code, message, details, options);
  }

  async shutdown() {
    if (!this.initialized) return;
    
    this.handlers.clear();
    this.integrations.clear();
    this.errorTypes.clear();
    this.removeAllListeners();
    this.initialized = false;
    this.emit('shutdown');
  }
}

// Factory function for container
export function createErrorSystem(deps) {
  return new ErrorSystem(deps);
}


// src/core/errors/error-system-docs.md

# Error System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Error Types](#error-types)
5. [Installation](#installation)
6. [Usage](#usage)
7. [Advanced Features](#advanced-features)
8. [Best Practices](#best-practices)
9. [Extending the System](#extending-the-system)
10. [Troubleshooting](#troubleshooting)

## Overview

The Error System is a comprehensive, extensible error handling framework designed to provide robust, consistent error management across the application.

## Purpose

The primary goals of the Error System are to:
- Standardize error representation
- Provide detailed error context
- Enable flexible error handling
- Support comprehensive error logging and tracking
- Facilitate easier debugging and system observability

## System Architecture

### Core Components

1. **CoreError** (`src/core/errors/Error.js`)
   - Base error class for all custom errors
   - Provides advanced error serialization
   - Handles error cause tracking
   - Supports environment-specific error formatting

2. **ErrorSystem** (`src/core/errors/ErrorSystem.js`)
   - Manages error types and integrations
   - Provides dynamic error handler registration
   - Implements event-driven error handling

3. **Error Types** (`src/core/errors/types/`)
   - Specialized error classes for different domains:
     * AccessError
     * AuthError
     * ConfigError
     * ModuleError
     * NetworkError
     * ServiceError
     * ValidationError

### Architecture Diagram

```mermaid
graph TD
    A[CoreError] --> B[Specialized Error Types]
    A --> C[Error Serialization]
    A --> D[Environment Handling]
    
    E[ErrorSystem] --> F[Error Handler Management]
    E --> G[Integration Registry]
    E --> H[Event Emission]
    
    B --> I[Domain-Specific Errors]
    I --> J[Access Errors]
    I --> K[Authentication Errors]
    I --> L[Configuration Errors]
```

## Error Codes

### Error Code Structure

Error codes are structured to provide clear, hierarchical categorization:

```javascript
ErrorCodes = {
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR'
  },
  // ... other error code categories
}
```

### Using Error Codes

```javascript
import { ErrorCodes, ValidationError } from '@your-org/error-system';

// Using predefined error codes
const validationError = new ValidationError(
  ErrorCodes.VALIDATION.FAILED, 
  'Validation failed',
  { details: 'Specific validation error' }
);
```

## Framework Integration

## Framework Integration

### Fastify Error Handling

The error system provides deep integration with Fastify, automatically handling various error scenarios:

```javascript
// Automatic error mapping
fastify.get('/route', async (request, reply) => {
  // Throws a 404 if route not found
  // Automatically converted to NetworkError
});

// Custom error types are preserved
throw new ValidationError('INVALID_INPUT', 'Validation failed');
```

### Error Mapping Examples

```javascript
// 404 Route Not Found
// Automatically converted to:
NetworkError {
  code: 'NETWORK_ROUTE_NOT_FOUND',
  message: 'Route GET:/test not found',
  statusCode: 404
}

// Validation Error
ValidationError {
  code: 'VALIDATION_FAILED',
  message: 'Invalid input',
  statusCode: 400,
  validationErrors: [...]
}
```

### Error Serialization

- Consistent JSON error format
- Environment-aware error details
- Preserves error context
- Supports custom error types

### Default Error Handling

```javascript
// Fallback error handler always exists
errorSystem.handleError(error, context);
```


## Error Types

### Available Error Types

1. **AccessError**
   - Used for authorization and access control issues
   - Default status code: 403 (Forbidden)

2. **AuthError**
   - Used for authentication-related errors
   - Default status code: 401 (Unauthorized)

3. **ConfigError**
   - Used for configuration and setup errors
   - Default status code: 500 (Internal Server Error)

4. **ModuleError**
   - Used for module system and initialization errors
   - Default status code: 500 (Internal Server Error)

5. **NetworkError**
   - Used for network-related errors
   - Default status code: 503 (Service Unavailable)

6. **ServiceError**
   - Used for service-level errors
   - Default status code: 503 (Service Unavailable)

7. **ValidationError**
   - Used for input validation errors
   - Default status code: 400 (Bad Request)

## Installation

```bash
npm install @your-org/error-system
```

## Usage

### Basic Error Creation

```javascript
import { 
  ValidationError, 
  ErrorCodes 
} from '@your-org/error-system';

// Create a validation error
const validationError = new ValidationError(
  ErrorCodes.VALIDATION.FAILED, 
  'Invalid user input', 
  { 
    validationErrors: [
      { field: 'email', message: 'Invalid email format' }
    ]
  }
);
```

### Error Handling with ErrorSystem

```javascript
import { ErrorSystem } from '@your-org/error-system';

// Create error system
const errorSystem = new ErrorSystem({ logger: customLogger });

// Register a custom error handler
errorSystem.registerHandler('ValidationError', (error, context) => {
  // Custom handling logic
  logger.warn(`Validation failed: ${error.message}`, {
    errors: error.validationErrors,
    context
  });
});

// Handle an error
try {
  // Some operation that might throw an error
} catch (error) {
  await errorSystem.handleError(error);
}
```

## Advanced Features

### Error Cause Tracking

```javascript
const originalError = new Error('Database connection failed');
const wrappedError = new ServiceError(
  'DB_CONNECTION', 
  'Could not connect to database', 
  {}, 
  { cause: originalError }
);
```

### JSON Serialization

```javascript
const error = new ValidationError('INVALID_INPUT', 'Validation failed');
const serializedError = error.toJSON();
// Can be sent over network, logged, etc.
```

## Best Practices

1. Always use specific error types
2. Include detailed context in error details
3. Use error codes for consistent error identification
4. Log errors with sufficient context
5. Handle errors at appropriate levels

## Extending the System

### Creating a Custom Error Type

```javascript
import { CoreError } from '@your-org/error-system';

class CustomDomainError extends CoreError {
  constructor(code, message, details = {}, options = {}) {
    super(`CUSTOM_${code}`, message, details, options);
    this.statusCode = 422; // Custom status code
  }
}
```

## Troubleshooting

### Common Issues

- **Circular Error Handling**: Avoid recursive error handling
- **Over-logging**: Be cautious about logging sensitive information
- **Error Serialization**: Ensure error details are JSON-serializable

## Future Roadmap

- [ ] Enhanced error tracking
- [ ] Distributed tracing support
- [ ] More granular error categorization
- [ ] Performance optimizations

## Contributing

Guidelines for contributing to the Error System will be added in future versions.

## License

[Your License Information]


// src/core/errors/index.js

// src/core/errors/index.js

import { CoreError } from './Error.js';
import { ErrorTypes as TypedErrors, 
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
} from './types/index.js';

// Create complete ErrorTypes including CoreError
export const ErrorTypes = {
    CoreError,
    ...TypedErrors
};

// Export individual error classes
export {
    CoreError,
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

/**
 * Standard error codes
 */
export const ErrorCodes = {
  // Core errors
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },

  // Module related
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    ROUTE: 'ROUTE_ERROR'
  },

  // Service related
  SERVICE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    CONFIGURATION: 'CONFIGURATION_ERROR',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    RUNTIME: 'RUNTIME_ERROR'
  },

  // Configuration related
  CONFIG: {
    VALIDATION: 'VALIDATION_FAILED',
    MISSING: 'MISSING_REQUIRED',
    INVALID: 'INVALID_VALUE'
  },

  // Validation related
  VALIDATION: {
    SCHEMA: 'SCHEMA_VALIDATION_FAILED',
    TYPE: 'INVALID_TYPE',
    REQUIRED: 'REQUIRED_FIELD_MISSING',
    FAILED: 'VALIDATION_FAILED'  // Added for validation errors
  },

  // Network related
  NETWORK: {
    REQUEST: 'REQUEST_FAILED',
    RESPONSE: 'RESPONSE_ERROR',
    TIMEOUT: 'REQUEST_TIMEOUT',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND'  // Added for 404 errors
  },

  // Authentication related
  AUTH: {
    UNAUTHORIZED: 'UNAUTHORIZED',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    INVALID_TOKEN: 'INVALID_TOKEN'
  },

  // Authorization related
  ACCESS: {
    FORBIDDEN: 'FORBIDDEN',
    INSUFFICIENT_RIGHTS: 'INSUFFICIENT_RIGHTS',
    RESOURCE_ACCESS_DENIED: 'RESOURCE_ACCESS_DENIED'
  }
};

export function createErrorFromResponse(response, defaultMessage = 'Unknown error occurred') {
  const errorData = response.data || response;
  
  // Map error names to constructors from ErrorTypes
  const ErrorConstructor = ErrorTypes[errorData.name] || CoreError;

  return new ErrorConstructor(
      errorData.code || ErrorCodes.CORE.UNKNOWN,
      errorData.message || defaultMessage,
      errorData.details || {},
      { cause: response }
  );
}

export default ErrorTypes;


// src/core/errors/integrations/IFrameworkIntegration.js

// src/core/errors/integrations/IFrameworkIntegration.js

/**
 * Interface for framework error integration
 * @interface
 */
export class IFrameworkIntegration {
  /**
   * Initialize error handling for framework
   * @param {any} framework - Framework instance
   * @param {Object} options - Integration options
   */
  initialize(framework, options = {}) {
    throw new Error('initialize() must be implemented');
  }

  /**
   * Serialize error for framework response
   * @param {Error} error - Error to serialize
   * @returns {Object} Serialized error
   */
  serializeError(error) {
    throw new Error('serializeError() must be implemented');
  }

  /**
   * Map framework error to core error
   * @param {Error} frameworkError - Framework-specific error
   * @returns {CoreError} Mapped core error
   */
  mapError(frameworkError) {
    throw new Error('mapError() must be implemented');
  }
}


// src/core/errors/integrations/fastify/FastifyIntegration.js

// src/core/errors/integrations/fastify/FastifyIntegration.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

export class FastifyIntegration extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  async initialize(fastify, options = {}) {
    if (this.initialized) {
      return;
    }

    // Add error context to request
    fastify.addHook('onRequest', async (request) => {
      if (!request) {
        return;
      }
      
      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    // Set error handler
    fastify.setErrorHandler(async (error, request, reply) => {
      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
  }

  mapError(error) {
    // Already our custom error
    if (error instanceof CoreError) {
      return error;
    }

    // Fastify validation errors
    // TODO: Need a network error
    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    // Route not found
    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    // Generic error
    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}


// src/core/errors/integrations/fastify/handler.js

// src/core/errors/integrations/fastify/handler.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

class FastifyErrorHandler extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  initialize(fastify, options = {}) {
    if (this.initialized) {
      return this;
    }

    if (!fastify || typeof fastify.addHook !== 'function') {
      throw new Error('Invalid fastify instance');
    }

    fastify.addHook('onRequest', async (request) => {
      if (!request) return;

      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    fastify.setErrorHandler(async (error, request, reply) => {
      if (!reply || typeof reply.status !== 'function') {
        throw new Error('Invalid reply object');
      }

      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
    return this;
  }

  mapError(error) {
    if (error instanceof CoreError) {
      return error;
    }

    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}

// Create singleton instance
const fastifyErrorHandler = new FastifyErrorHandler();

export function setupErrorHandler(fastify, options = {}) {
  return fastifyErrorHandler.initialize(fastify, options);
}

export { fastifyErrorHandler, FastifyErrorHandler };


// src/core/errors/integrations/fastify/index.js

export { setupErrorHandler } from './handler.js';
export { errorSerializer } from './serializer.js';


// src/core/errors/integrations/fastify/serializer.js

import { fastifyErrorHandler } from './handler.js';

export const errorSerializer = {
  serializer: (error) => fastifyErrorHandler.serializeError(error)
};


// src/core/errors/types/AccessError.js

import { CoreError } from '../Error.js';

/**
 * Authorization and access control related errors
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Create a new AccessError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options);
    this.statusCode = 403;
  }
}


// src/core/errors/types/AuthError.js

import { CoreError } from '../Error.js';

/**
 * Authentication related errors
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Create a new AuthError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options);
    this.statusCode = 401;
  }
}


// src/core/errors/types/ConfigError.js

import { CoreError } from '../Error.js';

/**
 * Configuration related errors
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Create a new ConfigError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/ModuleError.js

import { CoreError } from '../Error.js';

/**
 * Module system related errors
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Create a new ModuleError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/NetworkError.js

import { CoreError } from '../Error.js';

/**
 * Network related errors
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Create a new NetworkError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options);
    // Use provided status code or default to 503
    this.statusCode = details.statusCode || 503;
  }
}


// src/core/errors/types/ServiceError.js

import { CoreError } from '../Error.js';

/**
 * Service related errors
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Create a new ServiceError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options);
    this.statusCode = 503;
  }
}


// src/core/errors/types/ValidationError.js

import { CoreError } from '../Error.js';

/**
 * Validation related errors
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Create a new ValidationError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details with validation errors
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options);
    this.statusCode = 400;
    this.validationErrors = this.validationErrors = Array.isArray(details.validationErrors) ? details.validationErrors : [];
  }

  /**
   * Convert to JSON format with validation errors
   */
  toJSON() {
    const json = super.toJSON();
    json.validationErrors = this.validationErrors;
    return json;
  }

  /**
   * Create from JSON with validation errors
   * @param {Object} data - JSON data
   */
  static fromJSON(data) {
    const error = super.fromJSON(data);
    error.validationErrors = Array.isArray(data.validationErrors) ? data.validationErrors : [];
    return error;
  }
}


// src/core/errors/types/index.js

// src/core/errors/types/index.js

import { AccessError } from './AccessError.js';
import { AuthError } from './AuthError.js';
import { ConfigError } from './ConfigError.js';
import { ModuleError } from './ModuleError.js';
import { NetworkError } from './NetworkError.js';
import { ServiceError } from './ServiceError.js';
import { ValidationError } from './ValidationError.js';

// Export individual error types
export {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Create the ErrorTypes namespace
const ErrorTypes = {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Export ErrorTypes as both named and default export
export { ErrorTypes };
export default ErrorTypes;


// src/core/event/EventBus.js

// src/core/event/EventBus.js

import { EventEmitter } from 'events';
import { CoreError } from '../errors/Error.js';

export class CoreEventBus extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.queues = new Map();
    this.subscriptions = new Map();
    this.history = new Map();
    this.maxHistorySize = deps.config?.eventHistory?.maxSize || 1000;
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) {
      throw new CoreError('ALREADY_INITIALIZED', 'EventBus is already initialized');
    }

    try {
      // Initialize event tracking
      this.state = {
        status: 'running',
        startTime: Date.now(),
        metrics: new Map(),
        errors: []
      };

      this.initialized = true;
      this.emit('system:initialized', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error);
      throw error;
    }
  }

  async handleError(error, context = {}) {
    if (this.deps.errorSystem) {
      await this.deps.errorSystem.handleError(error, {
        source: 'CoreEventBus',
        ...context
      });
    }
  }
  /**
   * Enhanced emit with queuing and history
   */
  async emit(eventName, data, options = {}) {
    const event = {
      id: crypto.randomUUID(),
      name: eventName,
      data,
      timestamp: new Date().toISOString(),
      metadata: options.metadata || {}
    };

    // Store in history
    this.trackEvent(event);

    // Handle queuing if needed
    if (options.queue) {
      return this.queueEvent(event, options);
    }

    // Normal event emission
    return super.emit(eventName, event);
  }

  /**
   * Enhanced subscription with patterns
   */
  subscribe(pattern, handler, options = {}) {
    const subscription = {
      id: crypto.randomUUID(),
      pattern,
      handler,
      options
    };

    this.subscriptions.set(subscription.id, subscription);
    this.on(pattern, handler);

    return subscription.id;
  }

  /**
   * Queue events for delayed processing
   */
  async queueEvent(event, options = {}) {
    const queue = this.queues.get(event.name) || [];
    queue.push({
      event,
      options,
      timestamp: new Date().toISOString()
    });

    this.queues.set(event.name, queue);

    // Process queue if immediate
    if (options.immediate) {
      await this.processQueue(event.name);
    }
  }

  /**
   * Process queued events
   */
  async processQueue(queueName) {
    const queue = this.queues.get(queueName) || [];
    
    while (queue.length > 0) {
      const { event } = queue.shift();
      await super.emit(event.name, event);
    }

    this.queues.set(queueName, queue);
  }

  /**
   * Track events in history
   */
  trackEvent(event) {
    const history = this.history.get(event.name) || [];
    history.unshift(event);

    // Trim history if needed
    if (history.length > this.maxHistorySize) {
      history.pop();
    }

    this.history.set(event.name, history);
  }

  /**
   * Get event history
   */
  getHistory(eventName) {
    return this.history.get(eventName) || [];
  }

  /**
   * Clear history and queues
   */
  async reset() {
    this.queues.clear();
    this.history.clear();
    this.removeAllListeners();
  }

  async shutdown() {
    if (!this.initialized) return;

    try {
      await this.reset();
      this.initialized = false;
      this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error, { phase: 'shutdown' });
      throw error;
    }
  }
}

// Factory function for container
export function createEventBus(deps = {}) {
    return new CoreEventBus(deps);
  }


// src/core/event/EventBusSystem.js

// src/core/event/EventBusSystem.js

import { EventEmitter } from 'events';
import { CoreEventBus } from './EventBus.js';
import { CoreError } from '../errors/Error.js';

export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];

  constructor(deps) {
    super();
    this.deps = deps;
    this.eventBus = null;
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) {
      throw new CoreError('ALREADY_INITIALIZED', 'EventBusSystem is already initialized');
    }

    try {
      // Create and initialize event bus
      this.eventBus = new CoreEventBus(this.deps);
      await this.eventBus.initialize();

      this.initialized = true;
      this.emit('system:initialized', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error);
      throw error;
    }
  }

  async handleError(error, context = {}) {
    if (this.deps.errorSystem) {
      await this.deps.errorSystem.handleError(error, {
        source: 'EventBusSystem',
        ...context
      });
    }
  }

  getEventBus() {
    if (!this.initialized) {
      throw new CoreError('NOT_INITIALIZED', 'EventBusSystem is not initialized');
    }
    return this.eventBus;
  }

  async shutdown() {
    if (!this.initialized) return;

    try {
      await this.eventBus.shutdown();
      this.initialized = false;
      this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error, { phase: 'shutdown' });
      throw error;
    }
  }
}

// Factory function for container
export function createEventBusSystem(deps = {}) {
  return new EventBusSystem(deps);
}


// src/core/event/event-bus-docs.md

# Event Bus System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Core Components](#core-components)
3. [System Architecture](#system-architecture)
4. [Container Integration](#container-integration)
5. [Lifecycle Management](#lifecycle-management)
6. [Error Handling](#error-handling)
7. [Event Management](#event-management)
8. [Module Integration](#module-integration)
9. [Default Implementations](#default-implementations)
10. [Testing Strategy](#testing-strategy)
11. [Best Practices](#best-practices)
12. [Troubleshooting](#troubleshooting)

## Overview

The EventBus system provides centralized event management and message broker functionality for the TSMIS architecture. It serves as the communication backbone between modules while maintaining system boundaries and proper dependency management.

### Core Dependencies
```javascript
static dependencies = ['errorSystem', 'config'];
```

### Key Features
- Centralized event management
- Module-to-module communication
- Event history tracking
- Message queuing
- Error handling integration
- Health monitoring

## Core Components

### 1. CoreEventBus
Base event handling class providing core event functionality:

```javascript
export class CoreEventBus extends EventEmitter {
  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.queues = new Map();
    this.subscriptions = new Map();
    this.history = new Map();
    this.maxHistorySize = deps.config?.eventHistory?.maxSize || 1000;
    this.initialized = false;
  }

  // Core event handling methods
  async emit(eventName, data, options = {}) {}
  async subscribe(pattern, handler, options = {}) {}
  async queueEvent(event, options = {}) {}
  async processQueue(queueName) {}
}
```

### 2. EventBusSystem
System-level management of the EventBus:

```javascript
export class EventBusSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'config'];

  constructor(deps) {
    super();
    this.deps = deps;
    this.eventBus = null;
    this.initialized = false;
  }

  getEventBus() {
    if (!this.initialized) {
      throw new CoreError('NOT_INITIALIZED', 'EventBusSystem is not initialized');
    }
    return this.eventBus;
  }
}
```

## System Architecture

### Architecture Flow
```mermaid
graph TB
    Container --> EventBusSystem
    EventBusSystem --> CoreEventBus
    
    CoreEventBus --> |Events| ModuleA[Module A]
    CoreEventBus --> |Events| ModuleB[Module B]
    
    ModuleA --> |Emit| CoreEventBus
    ModuleB --> |Emit| CoreEventBus
    
    ErrorSystem --> |Error Handling| CoreEventBus
```

## Container Integration

### Registration
```javascript
// src/app.js
import { createEventBusSystem } from './core/event/EventBusSystem.js';

// Register with container
container.register('eventBusSystem', createEventBusSystem);

// Registration order
container.register('errorSystem', createErrorSystem);
container.register('config', () => ({}));
container.register('eventBusSystem', createEventBusSystem);
container.register('moduleSystem', createModuleSystem);
```

## Lifecycle Management

### Initialization
```javascript
class EventBusSystem {
  async initialize() {
    if (this.initialized) {
      throw new CoreError('ALREADY_INITIALIZED', 'EventBusSystem is already initialized');
    }

    try {
      // Create and initialize event bus
      this.eventBus = new CoreEventBus(this.deps);
      await this.eventBus.initialize();

      this.initialized = true;
      this.emit('system:initialized', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error);
      throw error;
    }
  }
}
```

### Shutdown
```javascript
class EventBusSystem {
  async shutdown() {
    if (!this.initialized) return;

    try {
      await this.eventBus.shutdown();
      this.initialized = false;
      this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      await this.handleError(error, { phase: 'shutdown' });
      throw error;
    }
  }
}
```

## Error Handling

### Integration with ErrorSystem
```javascript
class CoreEventBus {
  async handleError(error, context = {}) {
    if (this.deps.errorSystem) {
      await this.deps.errorSystem.handleError(error, {
        source: 'CoreEventBus',
        ...context
      });
    }
  }
}
```

### Error Propagation
```javascript
async emit(eventName, data, options = {}) {
  try {
    // Event emission logic
  } catch (error) {
    await this.handleError(error, {
      eventName,
      data,
      options
    });
    throw error;
  }
}
```

## Event Management

### Event Structure
```javascript
const event = {
  id: crypto.randomUUID(),
  name: eventName,
  data,
  timestamp: new Date().toISOString(),
  metadata: options.metadata || {}
};
```

### Event Emission
```javascript
async emit(eventName, data, options = {}) {
  const event = this.createEvent(eventName, data, options);
  
  // Store in history
  this.trackEvent(event);

  // Handle queuing if needed
  if (options.queue) {
    return this.queueEvent(event, options);
  }

  // Normal event emission
  return super.emit(eventName, event);
}
```

### Event History
```javascript
trackEvent(event) {
  const history = this.history.get(event.name) || [];
  history.unshift(event);

  if (history.length > this.maxHistorySize) {
    history.pop();
  }

  this.history.set(event.name, history);
}
```

## Module Integration

### Module Access
```javascript
class BusinessModule extends CoreModule {
  constructor(deps) {
    super(deps);
    // Get eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem.getEventBus();
  }
}
```

### Event Handling in Modules
```javascript
class BusinessModule extends CoreModule {
  async setupEventHandlers() {
    const eventBus = this.deps.eventBusSystem.getEventBus();
    
    // Subscribe to events
    eventBus.subscribe('domain.event', this.handleDomainEvent.bind(this));
    eventBus.subscribe('system.*', this.handleSystemEvents.bind(this));
  }

  async handleDomainEvent(event) {
    try {
      // Handle domain event
    } catch (error) {
      await this.handleError(error, { event });
    }
  }
}
```

## Default Implementations

### Factory Functions
```javascript
// EventBusSystem Factory
export function createEventBusSystem(deps = {}) {
  return new EventBusSystem(deps);
}

// CoreEventBus Factory for Testing/Development
export function createEventBus(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {} // No-op error handler
    },
    config: {} // Empty configuration object
  };

  return new CoreEventBus({
    ...defaultDeps,
    ...deps
  });
}
```

### Default Module Integration
```javascript
// In Module Factory
export function createModule(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {}
    },
    eventBusSystem: {
      getEventBus: () => new CoreEventBus({
        errorSystem: deps.errorSystem,
        config: deps.config
      })
    },
    config: {}
  };

  return new CoreModule({
    ...defaultDeps,
    ...deps
  });
}
```

## Testing Strategy

### EventBus Testing
```javascript
describe('CoreEventBus', () => {
  let eventBus;
  let mockDeps;

  beforeEach(() => {
    mockDeps = {
      errorSystem: {
        handleError: jest.fn()
      },
      config: {}
    };
    eventBus = new CoreEventBus(mockDeps);
  });

  test('should emit events', async () => {
    const handler = jest.fn();
    eventBus.on('test.event', handler);
    
    await eventBus.emit('test.event', { data: 'test' });
    expect(handler).toHaveBeenCalled();
  });
});
```

### System Testing
```javascript
describe('EventBusSystem', () => {
  let system;
  let mockDeps;

  beforeEach(() => {
    mockDeps = {
      errorSystem: {
        handleError: jest.fn()
      },
      config: {}
    };
    system = new EventBusSystem(mockDeps);
  });

  test('should initialize', async () => {
    await system.initialize();
    expect(system.initialized).toBe(true);
    expect(system.getEventBus()).toBeDefined();
  });
});
```

## Best Practices

1. Event Naming
- Use domain-driven event names: `domain.action`
- Include version for breaking changes: `user.created.v2`
- Be specific and descriptive

2. Event Handling
- Always use try/catch in handlers
- Validate event data
- Keep handlers focused
- Use proper error context

3. Module Integration
- Get eventBus through eventBusSystem
- Setup handlers in setupEventHandlers
- Clean up subscriptions on shutdown
- Use proper error handling

4. Testing
- Use mock dependencies
- Test both success and error cases
- Verify event handling
- Test lifecycle methods

## Troubleshooting

### Common Issues

1. Event Bus Not Initialized
```javascript
// Check initialization
if (!this.initialized) {
  throw new CoreError('NOT_INITIALIZED', 'EventBusSystem is not initialized');
}
```

2. Missing Dependencies
```javascript
// Validate dependencies
const missing = this.constructor.dependencies.filter(
  dep => !this.deps[dep]
);

if (missing.length > 0) {
  throw new ModuleError(
    'MISSING_DEPENDENCIES',
    `Missing required dependencies: ${missing.join(', ')}`
  );
}
```

3. Event Handler Errors
```javascript
try {
  await handler(event);
} catch (error) {
  await this.handleError(error, {
    event,
    handler: handler.name
  });
}
```

### Debugging Tips

1. Enable Debug Logging
```javascript
const eventBus = this.deps.eventBusSystem.getEventBus();
eventBus.on('*', (event) => {
  console.debug('Event:', event);
});
```

2. Check Event History
```javascript
const history = eventBus.getHistory(eventName);
console.log('Event history:', history);
```

3. Monitor Health
```javascript
const health = await eventBus.checkHealth();
console.log('EventBus health:', health);
```


// src/core/module/Module.js

// src/core/module/Module.js
import { EventEmitter } from 'events';
import { CoreEventBus } from '../event/EventBus.js';
import { ModuleError, ValidationError } from '../errors/index.js';

export class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];
  static version = '1.0.0';
  
  constructor(deps = {}) {
    super();
    this.deps = deps;
    // Get the eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.initialized = false;
    this.config = deps.config || {};
    
    // Enhanced state tracking
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      healthChecks: new Map(),
      lastHealthCheck: null
    };

    // Validate dependencies immediately
    this.validateDependencies();
    
    // Set up health check interval
    this.healthCheckInterval = null;
  }

  validateDependencies() {
    // Check required dependencies
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new ModuleError(
        'MISSING_DEPENDENCIES',
        `Missing required dependencies: ${missing.join(', ')}`
      );
    }

    // Validate eventBusSystem dependency
    if (this.deps.eventBusSystem && typeof this.deps.eventBusSystem.getEventBus !== 'function') {
      throw new ModuleError(
        'INVALID_EVENTBUS_SYSTEM',
        'EventBusSystem missing required method: getEventBus'
      );
    }

    if (this.deps.errorSystem && typeof this.deps.errorSystem.handleError !== 'function') {
      throw new ModuleError(
        'INVALID_ERROR_SYSTEM',
        'ErrorSystem missing required methods'
      );
    }
  }

  async validateConfig() {
    try {
      // Basic config validation
      if (this.config === null || typeof this.config !== 'object') {
        throw new ValidationError(
          'INVALID_CONFIG',
          'Configuration must be an object'
        );
      }

      // Module-specific validation
      await this.onValidateConfig();
      
      return true;
    } catch (error) {
      throw new ModuleError(
        'CONFIG_VALIDATION_FAILED',
        'Failed to validate configuration',
        { originalError: error }
      );
    }
  }

  async initialize() {
    if (this.initialized) {
      throw new ModuleError(
        'ALREADY_INITIALIZED',
        'Module is already initialized'
      );
    }

    try {
      this.state.startTime = Date.now();
      this.state.status = 'initializing';

      // Configuration phase
      await this.validateConfig();
      await this.onConfigure();

      // Setup phase
      await this.setupEventHandlers();
      await this.setupHealthChecks();

      // Initialize phase
      await this.onInitialize();

      // Start health check monitoring
      this.startHealthChecks();
      
      this.initialized = true;
      this.state.status = 'running';

      await this.emit('module:initialized', {
        name: this.constructor.name,
        timestamp: new Date().toISOString()
      });

      return this;

    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message
      });

      throw new ModuleError(
        'INITIALIZATION_FAILED',
        'Failed to initialize module',
        { originalError: error }
      );
    }
  }

  async setupHealthChecks() {
    // Register default health checks
    this.registerHealthCheck('state', async () => {
      return {
        status: this.state.status === 'running' ? 'healthy' : 'unhealthy',
        uptime: Date.now() - this.state.startTime,
        errorCount: this.state.errors.length
      };
    });

    // Allow modules to add their own health checks
    await this.onSetupHealthChecks();
  }

  registerHealthCheck(name, checkFn) {
    if (typeof checkFn !== 'function') {
      throw new ModuleError(
        'INVALID_HEALTH_CHECK',
        `Health check ${name} must be a function`
      );
    }
    this.state.healthChecks.set(name, checkFn);
  }

  startHealthChecks() {
    // Run health checks every 30 seconds by default
    this.healthCheckInterval = setInterval(async () => {
      try {
        const health = await this.checkHealth();
        this.state.lastHealthCheck = health;
        
        if (health.status !== 'healthy') {
          await this.handleError(new ModuleError(
            'HEALTH_CHECK_FAILED',
            'Module health check failed',
            { health }
          ));
        }
      } catch (error) {
        await this.handleError(error);
      }
    }, 30000);
  }

  async checkHealth() {
    const results = {};
    let overallStatus = 'healthy';

    for (const [name, checkFn] of this.state.healthChecks) {
      try {
        results[name] = await checkFn();
        if (results[name].status !== 'healthy') {
          overallStatus = 'unhealthy';
        }
      } catch (error) {
        results[name] = {
          status: 'error',
          error: error.message
        };
        overallStatus = 'unhealthy';
      }
    }

    return {
      name: this.constructor.name,
      version: this.constructor.version,
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks: results
    };
  }

  async handleError(error, context = {}) {
    const safeContext = context || {};

    // Add error to state
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: safeContext
    });

    // Trim error history
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }

    // Forward to error system
    if (this.deps.errorSystem) {
      try {
        await this.deps.errorSystem.handleError(error, {
          module: this.constructor.name,
          ...safeContext
        });
      } catch (handlerError) {
        // Log error handling failure
        console.error('Error in error handling:', handlerError);
      }
    }

    // Emit error event
    await this.emit('module:error', {
      module: this.constructor.name,
      error,
      context: safeContext
    });

    return this;
  }

  async emit(eventName, ...args) {
    // Emit through local EventEmitter
    const localEmitResult = super.emit(eventName, ...args);

    // Broadcast through eventBus if available
    if (this.eventBus?.emit) {
      try {
        await this.eventBus.emit(eventName, ...args);
      } catch (error) {
        await this.handleError(error, {
          event: eventName,
          args
        });
      }
    }

    return localEmitResult;
  }

  async shutdown() {
    try {
      if (!this.initialized) {
        return this;
      }

      this.state.status = 'shutting_down';
      
      // Stop health checks
      if (this.healthCheckInterval) {
        clearInterval(this.healthCheckInterval);
        this.healthCheckInterval = null;
      }

      // Custom shutdown logic
      await this.onShutdown();
      
      // Reset state
      this.initialized = false;
      this.state.status = 'shutdown';
      this.state.startTime = null;
      
      await this.emit('module:shutdown', {
        name: this.constructor.name,
        timestamp: new Date().toISOString()
      });

      return this;
    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message,
        context: { phase: 'shutdown' }
      });

      throw new ModuleError(
        'SHUTDOWN_FAILED',
        'Failed to shutdown module',
        { originalError: error }
      );
    }
  }

  // Lifecycle hooks for derived classes
  async onValidateConfig() {
    // Override in derived classes
    return true;
  }

  async onConfigure() {
    // Override in derived classes
    return Promise.resolve();
  }

  async setupEventHandlers() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onSetupHealthChecks() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onInitialize() {
    // Override in derived classes
    return Promise.resolve();
  }

  async onShutdown() {
    // Override in derived classes
    return Promise.resolve();
  }

  // Metrics tracking
  recordMetric(name, value, tags = {}) {
    this.state.metrics.set(name, {
      value,
      timestamp: Date.now(),
      tags
    });
  }
}

export function createModule(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {} // No-op error handler
    },
    eventBusSystem: {
      getEventBus: () => new CoreEventBus({ // Use CoreEventBus instead of EventEmitter
        errorSystem: deps.errorSystem,
        config: deps.config
      })
    },
    config: {} // Empty configuration object
  };

  const mergedDeps = {
    ...defaultDeps,
    ...deps
  };

  return new CoreModule(mergedDeps);
}

export default {
  CoreModule,
  createModule
};


// src/core/module/ModuleSystem.js

// src/core/module/ModuleSystem.js
import { EventEmitter } from 'events';
import { CoreModule } from './Module.js';
import { ModuleError, ValidationError } from '../errors/index.js';

export class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBusSystem', 'config'];

  constructor(deps) {
    super();
    this.deps = deps;
    this.modules = new Map();
    this.initialized = false;
    // Get eventBus from eventBusSystem
    this.eventBus = deps.eventBusSystem?.getEventBus();
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map(),
      moduleHealth: new Map(),
      healthCheckIntervals: new Map() // Track intervals for proper cleanup
    };

    // Validate dependencies
    this.validateDependencies();
  }

  validateDependencies() {
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new ModuleError(
        'MISSING_DEPENDENCIES',
        `Missing required dependencies: ${missing.join(', ')}`
      );
    }

    // Validate eventBusSystem
    if (!this.deps.eventBusSystem?.getEventBus) {
      throw new ModuleError(
        'INVALID_EVENTBUS_SYSTEM',
        'EventBusSystem missing required methods'
      );
    }

    if (!this.deps.errorSystem?.handleError) {
      throw new ModuleError(
        'INVALID_ERROR_SYSTEM',
        'ErrorSystem missing required methods'
      );
    }
  }

  async emit(eventName, ...args) {
    // Local EventEmitter emission
    const localEmitResult = super.emit(eventName, ...args);
    
    // Use eventBus for global events if available
    if (this.eventBus?.emit) {
      try {
        await this.eventBus.emit(eventName, ...args);
      } catch (error) {
        await this.handleModuleError('ModuleSystem', error);
      }
    }
    
    return localEmitResult;
  }

  async register(name, ModuleClass, config = {}) {
    if (!(ModuleClass.prototype instanceof CoreModule)) {
      throw new ValidationError(
        'INVALID_MODULE',
        'Module must extend CoreModule'
      );
    }

    if (this.modules.has(name)) {
      throw new ModuleError(
        'DUPLICATE_MODULE',
        `Module ${name} is already registered`
      );
    }

    try {
      // Create module instance with dependencies
      const module = new ModuleClass({
        ...this.deps,
        config: {
          ...this.deps.config?.[name],
          ...config
        }
      });

      this.modules.set(name, module);

      // Setup health check listener
      module.on('module:error', async (error) => {
        await this.handleModuleError(name, error);
      });

      await this.emit('module:registered', {
        name,
        timestamp: new Date().toISOString()
      });

      return module;
    } catch (error) {
      throw new ModuleError(
        'REGISTRATION_FAILED',
        `Failed to register module ${name}`,
        { originalError: error }
      );
    }
  }

  async unregister(name) {
    const module = this.modules.get(name);
    if (!module) return;

    try {
      if (module.initialized) {
        await module.shutdown();
      }
      
      this.modules.delete(name);
      
      await this.emit('module:unregistered', {
        name,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      throw new ModuleError(
        'UNREGISTER_FAILED',
        `Failed to unregister module ${name}`,
        { originalError: error }
      );
    }
  }

  async resolve(name) {
    const module = this.modules.get(name);
    if (!module) {
      throw new ModuleError(
        'MODULE_NOT_FOUND',
        `Module ${name} is not registered`
      );
    }
    return module;
  }

  async initialize() {
    if (this.initialized) {
      throw new ModuleError(
        'ALREADY_INITIALIZED',
        'ModuleSystem is already initialized'
      );
    }

    try {
      this.state.startTime = Date.now();
      this.state.status = 'initializing';

      // Initialize modules in dependency order
      const initOrder = this.resolveDependencyOrder();
      
      for (const name of initOrder) {
        const module = this.modules.get(name);
        await module.initialize();
        
        // Start monitoring module health
        await this.startModuleHealthMonitoring(name);
      }

      this.initialized = true;
      this.state.status = 'running';

      await this.emit('system:initialized', {
        timestamp: new Date().toISOString(),
        modules: Array.from(this.modules.keys())
      });

    } catch (error) {
      this.state.status = 'error';
      throw new ModuleError(
        'INITIALIZATION_FAILED',
        'Failed to initialize module system',
        { originalError: error }
      );
    }
  }

  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ModuleError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected for module: ${name}`
        );
      }

      visiting.add(name);

      const module = this.modules.get(name);
      const deps = module.constructor.dependencies || [];

      for (const dep of deps) {
        if (!this.modules.has(dep)) {
          throw new ModuleError(
            'MISSING_DEPENDENCY',
            `Module ${name} requires missing module: ${dep}`
          );
        }
        visit(dep);
      }

      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    for (const name of this.modules.keys()) {
      visit(name);
    }

    return order;
  }

  async startModuleHealthMonitoring(name) {
    const module = this.modules.get(name);
    if (!module) return;

    // Clear any existing interval
    if (this.state.healthCheckIntervals.has(name)) {
      clearInterval(this.state.healthCheckIntervals.get(name));
    }

    // Monitor module health status
    const intervalId = setInterval(async () => {
      try {
        const health = await module.checkHealth();
        this.state.moduleHealth.set(name, health);

        if (health.status !== 'healthy') {
          await this.handleModuleError(name, new ModuleError(
            'UNHEALTHY_MODULE',
            `Module ${name} is unhealthy`,
            { health }
          ));
        }
      } catch (error) {
        await this.handleModuleError(name, error);
      }
    }, 60000); // Check every minute

    // Track the interval for proper cleanup
    this.state.healthCheckIntervals.set(name, intervalId);
  }

  async handleModuleError(moduleName, error) {
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      module: moduleName,
      error: error.message
    });

    // Trim error history
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }

    // Forward to error system
    if (this.deps.errorSystem?.handleError) {
      await this.deps.errorSystem.handleError(error, {
        source: 'ModuleSystem',
        module: moduleName
      });
    }

    await this.emit('module:error', {
      module: moduleName,
      error,
      timestamp: new Date().toISOString()
    });
  }

  async getSystemHealth() {
    const moduleHealth = {};
    let systemStatus = 'healthy';

    for (const [name, module] of this.modules) {
      try {
        const health = await module.checkHealth();
        moduleHealth[name] = health;
        
        if (health.status !== 'healthy') {
          systemStatus = 'degraded';
        }
      } catch (error) {
        moduleHealth[name] = {
          status: 'error',
          error: error.message
        };
        systemStatus = 'unhealthy';
      }
    }

    return {
      status: systemStatus,
      timestamp: new Date().toISOString(),
      uptime: Date.now() - this.state.startTime,
      modules: moduleHealth,
      errorCount: this.state.errors.length
    };
  }

  async shutdown() {
    if (!this.initialized) return;

    try {
      this.state.status = 'shutting_down';

      // Clear all health check intervals
      for (const [name, intervalId] of this.state.healthCheckIntervals) {
        clearInterval(intervalId);
      }
      this.state.healthCheckIntervals.clear();

      // Shutdown modules in reverse dependency order
      const shutdownOrder = this.resolveDependencyOrder().reverse();

      for (const name of shutdownOrder) {
        const module = this.modules.get(name);
        await module.shutdown();
      }

      this.modules.clear();
      this.initialized = false;
      this.state.status = 'shutdown';

      await this.emit('system:shutdown', {
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      this.state.status = 'error';
      throw new ModuleError(
        'SHUTDOWN_FAILED',
        'Failed to shutdown module system',
        { originalError: error }
      );
    }
  }
}

export function createModuleSystem(deps = {}) {
  const defaultDeps = {
    errorSystem: {
      handleError: async () => {} // No-op error handler
    },
    eventBusSystem: {
      getEventBus: () => new EventEmitter() // Default eventBus provider
    },
    config: {} // Empty configuration object
  };

  return new ModuleSystem({
    ...defaultDeps,
    ...deps
  });
}

export default {
  ModuleSystem,
  createModuleSystem
};


// src/core/module/module-system-docs.md

# Module System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Core Concepts](#core-concepts)
3. [System Architecture](#system-architecture)
4. [Core Systems](#core-systems)
5. [Service Systems](#service-systems)
6. [Business Modules](#business-modules)
7. [Integration Patterns](#integration-patterns)
8. [State Management](#state-management)
9. [Error Handling](#error-handling)
10. [Event System](#event-system)
11. [Health Monitoring](#health-monitoring)
12. [Testing Strategy](#testing-strategy)
13. [Best Practices](#best-practices)
14. [Troubleshooting](#troubleshooting)

## Overview

The TSMIS architecture is built on three main layers:
1. Core Systems - Fundamental infrastructure (Container, ErrorSystem, ModuleSystem)
2. Service Systems - Common service functionality
3. Business Modules - Business domain logic

## Core Concepts

### Core Dependencies

The module system has three required dependencies:

```javascript
static dependencies = ['errorSystem', 'eventBus', 'config'];
```
#### Dependency Resolution

Dependencies are resolved in the following ways:

1. Through the Container (primary method)
2. Through default fallbacks (development/testing)
3. Through explicit injection

#### Default Fallbacks

```javascript
const defaultDeps = {
  errorSystem: {
    handleError: async () => {} // No-op handler
  },
  eventBus: new EventEmitter(), // Default emitter
  config: {} // Empty config
};
```

#### Component Registration

Components can be registered in two ways:

1. As Singleton Instances:

```javascript
// In app.js
const eventBus = new EventEmitter();
container.register('eventBus', () => eventBus);
```

2. As Factory Functions:

```javascript
container.register('moduleSystem', (deps) => {
  return createModuleSystem(deps);
});
```
#### Event System Integration

Modules can communicate through the EventBus in two ways:

1. Direct Events (local):

```javascript
// Within a module
this.emit('localEvent', data);
```

2. System Events (global):

```javascript
// Broadcast to all modules
this.deps.eventBus.emit('globalEvent', data);
```
### Architectural Principles
- Clear separation of concerns
- Infrastructure/business logic separation
- Event-driven communication
- Dependency injection
- State management

### Key Features
- Core dependencies management
- Module lifecycle control
- Standardized error handling
- Dual event emission (local + bus)
- Health monitoring
- Metrics tracking

## System Architecture

```mermaid
graph TB
    Container --> ErrorSystem
    Container --> EventBus
    Container --> ModuleSystem
    
    ModuleSystem --> BusinessModules
    
    ErrorSystem --> |Error Handling| BusinessModules
    EventBus --> |Event Flow| BusinessModules
```

## Core Systems

### ModuleSystem
```javascript
class ModuleSystem extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBus'];

  async register(name, Module, config = {}) {
    // Module registration logic
  }

  async resolve(name) {
    // Module resolution logic
  }
}
```

### CoreModule Base Class
```javascript
class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBus', 'config'];
  static version = '1.0.0';

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.initialized = false;
    this.config = deps.config || {};
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map()
    };
  }
}
```

## State Management

### Module States
- created: Initial module state
- initializing: During initialization process
- running: Module is active
- shutting_down: During shutdown process
- shutdown: Module is inactive
- error: Error state

### State Tracking
```javascript
this.state = {
  status: 'created',
  startTime: null,
  errors: [],
  metrics: new Map()
};
```

## Error Handling

### Error Management
```javascript
async handleError(error, context = {}) {
  const safeContext = context || {};

  this.state.errors.push({
    timestamp: new Date().toISOString(),
    error: error.message,
    context: safeContext
  });

  if (this.state.errors.length > 100) {
    this.state.errors.shift();
  }

  if (this.deps.errorSystem) {
    await this.deps.errorSystem.handleError(error, {
      module: this.constructor.name,
      ...safeContext
    });
  }
}
```

## Event System

### Dual Event Emission
```javascript
async emit(eventName, ...args) {
  // Local EventEmitter emission
  const localEmitResult = super.emit(eventName, ...args);
  
  // EventBus broadcast
  if (this.deps.eventBus?.emit) {
    await this.deps.eventBus.emit(eventName, ...args);
  }
  
  return localEmitResult;
}
```

## Health Monitoring

### Health Check Implementation

The system now includes comprehensive health monitoring:

- Component status tracking
- Error history
- Metrics collection
- Performance monitoring

```javascript
async getHealth() {
  return {
    name: this.constructor.name,
    version: this.constructor.version,
    status: this.state.status,
    uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
    initialized: this.initialized,
    errorCount: this.state.errors.length,
    lastError: this.state.errors[this.state.errors.length - 1],
    metrics: Object.fromEntries(this.state.metrics)
  };
}
```

### Metrics Recording
```javascript
recordMetric(name, value) {
  this.state.metrics.set(name, {
    value,
    timestamp: Date.now()
  });
}
```

## Module Lifecycle

### Initialization
```javascript
async initialize() {
  if (this.initialized) {
    throw new ModuleError('ALREADY_INITIALIZED', 'Module is already initialized');
  }

  try {
    this.state.startTime = Date.now();
    this.state.status = 'initializing';

    await this.onConfigure();
    await this.setupEventHandlers();
    await this.onInitialize();
    
    this.initialized = true;
    this.state.status = 'running';
  } catch (error) {
    this.state.status = 'error';
    throw new ModuleError('INITIALIZATION_FAILED', 'Failed to initialize module',
      { originalError: error }
    );
  }
}
```

### Shutdown
```javascript
async shutdown() {
  if (!this.initialized) return;

  try {
    this.state.status = 'shutting_down';
    await this.onShutdown();
    
    this.initialized = false;
    this.state.status = 'shutdown';
    this.state.startTime = null;
  } catch (error) {
    this.state.status = 'error';
    throw new ModuleError('SHUTDOWN_FAILED', 'Failed to shutdown module',
      { originalError: error }
    );
  }
}
```

## Testing Strategy

### Module Testing
```javascript
describe('CoreModule', () => {
  let module;
  let mockDeps;

  beforeEach(() => {
    mockDeps = {
      errorSystem: {
        handleError: jest.fn()
      },
      eventBus: {
        emit: jest.fn()
      },
      config: {}
    };
    module = new CoreModule(mockDeps);
  });

  test('should handle initialization', async () => {
    await module.initialize();
    expect(module.initialized).toBe(true);
    expect(module.state.status).toBe('running');
  });
});
```

## Best Practices

1. Always use Container for dependency injection
2. Utilize event system for module communication
3. Implement health checks for modules
4. Handle errors with proper context
5. Use singleton components judiciously

### 1. Module Implementation
- Validate dependencies in constructor
- Implement lifecycle hooks (onConfigure, onInitialize, onShutdown)
- Handle errors through errorSystem
- Record meaningful metrics
- Maintain clean state transitions

### 2. Error Handling
- Use ModuleError for module-specific errors
- Provide meaningful error contexts
- Limit error history to prevent memory issues
- Forward errors to errorSystem when available

### 3. Event Handling
- Use setupEventHandlers for event subscription
- Leverage dual event emission appropriately
- Handle event errors properly

### 4. Health Monitoring
- Implement meaningful health checks
- Record relevant metrics
- Maintain accurate state information
- Track error history

## Troubleshooting

### Common Issues
1. Initialization Failures
   - Check dependency validation
   - Verify configuration
   - Review initialization hooks

2. State Management
   - Verify state transitions
   - Check metric recording
   - Monitor error history

3. Event Handling
   - Debug local event emission
   - Verify eventBus connectivity
   - Check event handler registration


// server.js

import 'dotenv/config';

const { NODE_ENV = "development", PORT = 3000 } = process.env;
console.time("Start");

let address;

async function startServer() {
  if (NODE_ENV === "production") {
    const { buildApp } = await import("./dist/app.js");
    const app = await buildApp();
    address = await app.listen({ port: '3001', host: '0.0.0.0' });
  } else {
    const { once } = await import("events");
    const { createServer } = await import("vite");
    let appInstance;  // Store the built app instance

    const devServer = await createServer({
      appType: "custom",
      server: { middlewareMode: true },
    });

    const server = devServer.middlewares
      .use(async (req, res, next) => {
        try {
          if (!appInstance) {
            console.log('Building app for the first time.');
            const { buildApp } = await devServer.ssrLoadModule("./src/app.js");
            appInstance = await buildApp();
            await appInstance.ready();
          }

          console.log('Routing request:', req.url);
          appInstance.routing(req, res);
        } catch (err) {
          console.error('Error during request handling:', err);
          return next(err);
        }
      })
      .listen(PORT);

    await once(server, "listening");
    address = `http://localhost:${server.address().port}`;

    // Listen for file changes to trigger a rebuild
    devServer.watcher.on('change', (file) => {
      console.log(`File changed: ${file}. Rebuilding app...`);
      appInstance = null;  // This will trigger a rebuild on the next request
      console.log(`App rebuilt`);
    });
  }

  console.timeEnd("Start");
  console.log(`Env: ${NODE_ENV}`);
  console.log(`Address: ${address}`);
}

startServer().catch((err) => {
  console.error('Failed to start server:', err);
  process.exit(1);
});


// vite.config.js

import { defineConfig } from "vite";
import marko from "@marko/vite";
//import { resolve } from "path";

export default defineConfig({
  //root: resolve(__dirname, "src"),
  plugins: [marko()],
  build: {
    sourcemap: true, // Generate sourcemaps for all builds.
    emptyOutDir: false, // Avoid server & client deleting files from each other.
    outDir: "./dist",
  },
});


// .env

NODE_ENV="development"
PORT="3000"

DATABASE_URL='postgres://postgres:Magarao12@localhost:5432/tsmis_dev'
JWT_SECRET="hgtrh3rthhymn^^7(@jytj00*hh765y"

IPREGISTRY_API_KEY="zo2l5bcj3o5hp0"


MAIL_HOST="smtp.gmail.com"
MAIL_PORT="465"
MAIL_SECURE="true"
MAIL_USER="torosminfo@gmail.com"
MAIL_PASS="oaor cyav zijk nlqn"

HARDCODE_MODULES=false


// package.json

{
    "name": "tsmis",
    "type": "module",
    "description": "toro_sm information system",
    "version": "1.0.0",
    "dependencies": {
        "@fastify/compress": "^7.0.3",
        "@fastify/cookie": "^9.3.1",
        "@fastify/csrf-protection": "^6.4.1",
        "@fastify/formbody": "^7.4.0",
        "@fastify/helmet": "^11.1.1",
        "@fastify/jwt": "^8.0.1",
        "@fastify/postgres": "^5.2.2",
        "@fastify/rate-limit": "^9.1.0",
        "@fastify/static": "^7.0.4",
        "@ipregistry/client": "^6.0.0",
        "@marko/fastify": "^1.1.1",
        "@popperjs/core": "^2.11.8",
        "bcrypt": "^5.1.1",
        "bootstrap": "^5.3.3",
        "dotenv": "^16.4.5",
        "fastify": "^4.28.1",
        "marked": "^14.1.2",
        "marko": "^5.35.8",
        "nodemailer": "^6.9.15"
    },
    "devDependencies": {
        "@babel/core": "^7.26.7",
        "@babel/preset-env": "^7.26.7",
        "@marko/compiler": "^5.37.4",
        "@marko/vite": "^5.0.13",
        "babel-jest": "^29.7.0",
        "cross-env": "^7.0.3",
        "directory-tree-ascii": "^1.0.10",
        "jest": "^29.7.0",
        "postcss-preset-env": "^10.0.6",
        "rimraf": "^6.0.1",
        "sass": "^1.77.4",
        "vite": "^6.0.11"
    },
    "scripts": {
        "build": "rimraf dist && npm run build:server && npm run build:client",
        "build:client": "cross-env NODE_ENV=production vite build",
        "build:server": "cross-env NODE_ENV=production vite build --ssr src/app.js",
        "dev": "node --enable-source-maps server.js",
        "dev:inspect": "node --inspect --enable-source-maps server.js",
        "start": "cross-env NODE_ENV=production node --enable-source-maps server.js",
        "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
        "test:watch": "node --experimental-vm-modules node_modules/jest/bin/jest.js --watch",
        "test:coverage": "node --experimental-vm-modules node_modules/jest/bin/jest.js --coverage"
    }
}

