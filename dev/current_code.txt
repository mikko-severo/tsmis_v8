/** Folder layout
 * cmd: npx directory-tree-ascii . -b node_modules .git

> tsmis@1.0.0 npx
> daa . -b node_modules .git

```
└─ .
   ├─ .env
   ├─ babel.config.js
   ├─ coverage
   │  ├─ clover.xml
   │  ├─ coverage-final.json
   │  ├─ lcov-report
   │  │  ├─ base.css
   │  │  ├─ block-navigation.js
   │  │  ├─ container
   │  │  │  ├─ Container.js.html
   │  │  │  └─ index.html
   │  │  ├─ core
   │  │  │  ├─ bootstrap.js.html
   │  │  │  ├─ container
   │  │  │  │  ├─ Container.js.html
   │  │  │  │  └─ index.html
   │  │  │  ├─ errors
   │  │  │  │  ├─ Error.js.html
   │  │  │  │  ├─ ErrorService.js.html
   │  │  │  │  ├─ index.html
   │  │  │  │  ├─ index.js.html
   │  │  │  │  ├─ integrations
   │  │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  │  ├─ fastify
   │  │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  │  ├─ index.html
   │  │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  │  └─ index.html
   │  │  │  │  ├─ manifest.js.html
   │  │  │  │  └─ types
   │  │  │  │     ├─ AccessError.js.html
   │  │  │  │     ├─ AuthError.js.html
   │  │  │  │     ├─ ConfigError.js.html
   │  │  │  │     ├─ ModuleError.js.html
   │  │  │  │     ├─ NetworkError.js.html
   │  │  │  │     ├─ ServiceError.js.html
   │  │  │  │     ├─ ValidationError.js.html
   │  │  │  │     ├─ index.html
   │  │  │  │     └─ index.js.html
   │  │  │  └─ index.html
   │  │  ├─ errors
   │  │  │  ├─ Error.js.html
   │  │  │  ├─ ErrorSystem.js.html
   │  │  │  ├─ index.html
   │  │  │  ├─ index.js.html
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js.html
   │  │  │  │  ├─ IntegrationRegistry.js.html
   │  │  │  │  ├─ fastify
   │  │  │  │  │  ├─ FastifyIntegration.js.html
   │  │  │  │  │  ├─ handler.js.html
   │  │  │  │  │  ├─ index.html
   │  │  │  │  │  └─ serializer.js.html
   │  │  │  │  └─ index.html
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js.html
   │  │  │     ├─ AuthError.js.html
   │  │  │     ├─ ConfigError.js.html
   │  │  │     ├─ ModuleError.js.html
   │  │  │     ├─ NetworkError.js.html
   │  │  │     ├─ ServiceError.js.html
   │  │  │     ├─ ValidationError.js.html
   │  │  │     ├─ index.html
   │  │  │     └─ index.js.html
   │  │  ├─ favicon.png
   │  │  ├─ index.html
   │  │  ├─ module
   │  │  │  ├─ Module.js.html
   │  │  │  └─ index.html
   │  │  ├─ prettify.css
   │  │  ├─ prettify.js
   │  │  ├─ sort-arrow-sprite.png
   │  │  └─ sorter.js
   │  └─ lcov.info
   ├─ dev
   │  ├─ current_code.txt
   │  ├─ docs
   │  │  ├─ claude_prompt.md
   │  │  ├─ dev_manual.md
   │  │  ├─ dev_roadmap.md
   │  │  └─ technical.md
   │  └─ tools
   │     ├─ combined-files.js
   │     ├─ reverse-files.js
   │     └─ setup-project.js
   ├─ jest.config.mjs
   ├─ package-lock.json
   ├─ package.json
   ├─ server.js
   ├─ src
   │  ├─ app.js
   │  ├─ config
   │  ├─ core
   │  │  ├─ container
   │  │  │  ├─ Container.js
   │  │  │  └─ container-system-docs.md
   │  │  ├─ errors
   │  │  │  ├─ Error.js
   │  │  │  ├─ ErrorSystem.js
   │  │  │  ├─ error-system-docs.md
   │  │  │  ├─ index.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.js
   │  │  │  │     ├─ handler.js
   │  │  │  │     ├─ index.js
   │  │  │  │     └─ serializer.js
   │  │  │  └─ types
   │  │  │     ├─ AccessError.js
   │  │  │     ├─ AuthError.js
   │  │  │     ├─ ConfigError.js
   │  │  │     ├─ ModuleError.js
   │  │  │     ├─ NetworkError.js
   │  │  │     ├─ ServiceError.js
   │  │  │     ├─ ValidationError.js
   │  │  │     └─ index.js
   │  │  ├─ module
   │  │  │  ├─ Module.js
   │  │  │  └─ module-system-docs-updated.md
   │  │  ├─ service
   │  │  └─ validation
   │  ├─ modules
   │  └─ services
   │     ├─ cache
   │     ├─ database
   │     ├─ email
   │     ├─ ip
   │     └─ logger
   ├─ tests
   │  ├─ core
   │  │  ├─ container
   │  │  │  └─ Container.test.js
   │  │  ├─ errors
   │  │  │  ├─ Error.test.js
   │  │  │  ├─ ErrorSystem.test.js
   │  │  │  ├─ integration.test.js
   │  │  │  ├─ integrations
   │  │  │  │  ├─ IFrameworkIntegration.test.js
   │  │  │  │  └─ fastify
   │  │  │  │     ├─ FastifyIntegration.test.js
   │  │  │  │     ├─ handler.test.js
   │  │  │  │     └─ serializer.test.js
   │  │  │  └─ types
   │  │  │     ├─ ErrorTypes.test.js
   │  │  │     └─ index.test.js
   │  │  └─ module
   │  │     └─ Module.test.js
   │  └─ index.test.js
   └─ vite.config.js

```
*/


// src/app.js

import 'dotenv/config';
import Fastify from 'fastify';

// Core System Imports
import { CoreContainer } from './core/container/Container.js';
import { ErrorSystem, createErrorSystem } from './core/errors/ErrorSystem.js';
import { setupErrorHandler } from './core/errors/integrations/fastify/handler.js';

export async function buildApp() {
  // Create the core container
  const container = new CoreContainer();

  // Create and register error system 
  const errorSystemFactory = () => {
    return createErrorSystem({ 
      logger: console 
    });
  };
  
  // Register as a factory function
  container.register('errorSystem', errorSystemFactory);

  // Create Fastify instance with error serialization
  const fastify = Fastify({
    logger: {
      level: process.env.LOG_LEVEL || 'info',
      serializers: {
        error: (error) => {
          // Resolve error system and use its serializer
          const errorSystem = container.resolve('errorSystem');
          return errorSystem.serializeError(error);
        }
      }
    }
  });

  // Setup Fastify error handling
  setupErrorHandler(fastify);

  // Initialize the container
  try {
    await container.initialize();
  } catch (error) {
    console.error('Container initialization error:', error);
    throw error;
  }

  // Basic route as a health check
  fastify.get('/', async (request, reply) => {
    return { 
      status: 'ok', 
      timestamp: new Date().toISOString() 
    };
  });

  // Graceful shutdown handling
  const closeHandler = async () => {
    try {
      // Shutdown Fastify
      await fastify.close();
      
      // Shutdown container
      await container.shutdown();
    } catch (error) {
      console.error('Shutdown error:', error);
    }
  };

  // Handle various shutdown signals
  process.on('SIGINT', closeHandler);
  process.on('SIGTERM', closeHandler);

  // Add server close hook
  fastify.addHook('onClose', async () => {
    await container.shutdown();
  });

  return fastify;
}


// src/core/container/Container.js

// src/core/container/Container.js

import { EventEmitter } from 'events';
import { CoreError, ConfigError, ServiceError } from '../errors/index.js';
// import { ValidationService } from '../validation/ValidationService.js';

export class CoreContainer extends EventEmitter {
  constructor() {
    super();
    this.components = new Map();
    this.instances = new Map();
    this.dependencies = new Map();
    this.manifests = new Map();
    this.initialized = false;
  }

  /**
   * Register a component manifest
   * @param {string} type - Component type
   * @param {object} manifest - Component manifest
   */
  registerManifest(type, manifest) {
    if (this.manifests.has(type)) {
      throw new ConfigError(
        'DUPLICATE_MANIFEST',
        `Manifest already registered for type: ${type}`
      );
    }
    this.manifests.set(type, manifest);
    this.emit('manifest:registered', { type, manifest });
  }

  /**
   * Register a component with the container
   * @param {string} name - Component name
   * @param {Class} Component - Component constructor
   * @param {object} options - Registration options
   */
  register(name, Component, options = {}) {
    if (this.components.has(name)) {
      throw new ConfigError(
        'DUPLICATE_COMPONENT',
        `Component ${name} is already registered`
      );
    }

    // Store component definition
    this.components.set(name, {
      Component,
      options: {
        singleton: true,
        ...options
      }
    });

    // Store dependencies
    this.dependencies.set(name, Component.dependencies || []);

    this.emit('component:registered', { name, Component });
    return this;
  }

  /**
   * Discover components in a directory
   * @param {string} type - Component type
   * @param {string} basePath - Base directory path
   */
  async discover(type, basePath) {
    if (!this.manifests.has(type)) {
      throw new ConfigError(
        'INVALID_TYPE',
        `No manifest registered for type: ${type}`
      );
    }

    try {
      const manifest = this.manifests.get(type);
      const componentPaths = await this.scanDirectory(basePath);
      const discoveredComponents = new Map();

      for (const path of componentPaths) {
        try {
          const component = await this.loadComponent(path, manifest);
          if (component) {
            discoveredComponents.set(component.name, component);
          }
        } catch (error) {
          this.emit('discovery:error', { path, error });
        }
      }

      this.emit('discovery:completed', { type, components: discoveredComponents });
      return discoveredComponents;
    } catch (error) {
      throw new ServiceError(
        'DISCOVERY_FAILED',
        `Failed to discover ${type} components`,
        { originalError: error }
      );
    }
  }

  /**
   * Load a component from a path
   * @private
   */
  async loadComponent(path, manifest) {
    try {
      const config = await this.loadConfig(path);
      if (config.enabled === false) return null;

      await this.validateConfig(config, manifest.configSchema);
      const implementation = await this.loadImplementation(path);

      return {
        name: config.name,
        config,
        implementation
      };
    } catch (error) {
      throw new ConfigError(
        'LOAD_FAILED',
        `Failed to load component from ${path}`,
        { originalError: error }
      );
    }
  }

  /**
   * Get an instance of a component
   * @param {string} name - Component name
   */
  async resolve(name) {
    if (!this.components.has(name)) {
      throw new ServiceError(
        'UNKNOWN_COMPONENT',
        `Component ${name} is not registered`
      );
    }
  
    const { Component, options } = this.components.get(name);
  
    // Return existing instance for singletons
    if (options.singleton && this.instances.has(name)) {
      return this.instances.get(name);
    }
  
    // Resolve dependencies first
    const deps = this.dependencies.get(name) || [];
    const resolvedDeps = {};
  
    // Resolve each dependency
    for (const dep of deps) {
      resolvedDeps[dep] = await this.resolve(dep);
    }
  
    // Handle different component types
    let instance;
    if (typeof Component === 'function') {
      // If it's a class constructor
      if (Component.prototype) {
        // Use dependencies in constructor if it expects them
        instance = Component.length > 0 
          ? new Component(resolvedDeps) 
          : new Component();
      } 
      // If it's a factory function
      else {
        // Call factory with dependencies if it expects them
        instance = Component.length > 0 
          ? Component(resolvedDeps) 
          : Component();
      }
    } else {
      // If it's already an instance
      instance = Component;
    }
  
    // Initialize if container is already initialized
    if (this.initialized && typeof instance.initialize === 'function') {
      await instance.initialize();
    }
  
    // Cache singleton instance
    if (options.singleton) {
      this.instances.set(name, instance);
    }
  
    this.emit('component:resolved', { name, instance });
    return instance;
  }
  /**
   * Initialize all registered components
   */
  async initialize() {
    if (this.initialized) {
      throw new ServiceError(
        'ALREADY_INITIALIZED',
        'Container is already initialized'
      );
    }

    const order = this.resolveDependencyOrder();

    for (const name of order) {
      const instance = await this.resolve(name);
      if (typeof instance.initialize === 'function') {
        await instance.initialize();
      }
    }

    this.initialized = true;
    this.emit('initialized');
  }

  /**
   * Resolve dependency order for initialization
   * @private
   */
  resolveDependencyOrder() {
    const visited = new Set();
    const visiting = new Set();
    const order = [];

    const visit = (name) => {
      if (visited.has(name)) return;
      if (visiting.has(name)) {
        throw new ConfigError(
          'CIRCULAR_DEPENDENCY',
          `Circular dependency detected: ${name}`
        );
      }

      visiting.add(name);
      
      const deps = this.dependencies.get(name) || [];
      for (const dep of deps) {
        if (!this.components.has(dep)) {
          throw new ConfigError(
            'MISSING_DEPENDENCY',
            `Dependency ${dep} required by ${name} is not registered`
          );
        }
        visit(dep);
      }
      
      visiting.delete(name);
      visited.add(name);
      order.push(name);
    };

    for (const name of this.components.keys()) {
      visit(name);
    }

    return order;
  }

  /**
   * Shutdown all components
   */
//   async shutdown() {
//     const order = this.resolveDependencyOrder().reverse();

//     for (const name of order) {
//       const instance = this.instances.get(name);
//       if (instance && typeof instance.shutdown === 'function') {
//         await instance.shutdown();
//       }
//     }

//     this.instances.clear();
//     this.initialized = false;
//     this.emit('shutdown');
//   }

async shutdown() {
    // Shutdown in reverse dependency order
    const order = this.resolveDependencyOrder().reverse();
  
    for (const name of order) {
      const instance = this.instances.get(name);
      if (instance && typeof instance.shutdown === 'function') {
        try {
          await instance.shutdown();
        } catch (error) {
          // Log error but continue shutdown process
          this.emit('shutdown:error', { 
            component: name, 
            error 
          });
        }
      }
    }
  
    this.instances.clear();
    this.initialized = false;
    this.emit('shutdown');
  }
}


// src/core/container/container-system-docs.md

# CoreContainer System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Core Concepts](#core-concepts)
5. [Installation](#installation)
6. [Usage](#usage)
7. [Advanced Features](#advanced-features)
8. [Best Practices](#best-practices)
9. [Extending the System](#extending-the-system)
10. [Troubleshooting](#troubleshooting)

## Overview

The CoreContainer System is a sophisticated Dependency Injection (DI) and Inversion of Control (IoC) container designed to manage component lifecycles, dependencies, and system initialization.

## Purpose

The primary goals of the CoreContainer System are to:
- Manage component dependencies
- Facilitate loose coupling between system components
- Automate component initialization and shutdown
- Provide a centralized component registry
- Support complex dependency graphs

## System Architecture

### Core Components

1. **CoreContainer** (`src/core/container/Container.js`)
   - Central component management system
   - Handles component registration
   - Manages dependency resolution
   - Controls component lifecycle

### Architecture Diagram

```mermaid
graph TD
    A[CoreContainer] --> B[Component Registration]
    A --> C[Dependency Resolution]
    A --> D[Lifecycle Management]
    
    B --> E[Singleton/Transient Components]
    B --> F[Dependency Tracking]
    
    C --> G[Topological Sorting]
    C --> H[Circular Dependency Detection]
    
    D --> I[Initialization]
    D --> J[Shutdown]
    D --> K[Event Emission]
```

## Core Concepts

### Component Registration

- Components can be registered with optional configuration
- Supports singleton and transient component modes
- Tracks component dependencies
- Supports class and factory function registration

### Dependency Resolution

- Automatically resolves and injects dependencies
- Supports complex dependency graphs
- Prevents circular dependencies
- Ensures correct initialization order

### Lifecycle Management

- Provides `initialize()` and `shutdown()` methods
- Supports component-specific initialization logic
- Graceful shutdown with error handling

### Component Discovery

- Supports component discovery through manifest registration
- Allows for dynamic component loading based on manifests

## Installation

```bash
npm install @your-org/core-container-system
```

## Usage

### Basic Component Registration

```javascript
import { CoreContainer } from '@your-org/core-container-system';

// Class registration
class LoggerService {}

container.register('logger', LoggerService);

// Factory function registration
const createDatabaseService = (deps) => {
  return {
    query: () => { /* ... */ }
  };
};

container.register('database', createDatabaseService);
```

### Singleton vs Transient Components

```javascript
// Singleton registration (default)
container.register('service', ServiceClass);

// Transient registration
container.register('repository', RepositoryClass, { singleton: false });
```

### Advanced Dependency Injection

```javascript
class AuthService {
  constructor(deps) {
    this.database = deps.database;
    this.logger = deps.logger;
  }
}

container.register('auth', AuthService);
```

### Component Discovery with Manifests

```javascript
// Register a component manifest
container.registerManifest('service', {
  configSchema: {
    /* ... */
  }
});

// Discover components based on the manifest
await container.discover('service', './services');
```

## Advanced Features

### Event Handling

```javascript
container.on('component:registered', ({ name, component }) => {
  console.log(`Component ${name} registered`);
});
```

### Dependency Injection Modes

- Constructor injection
- Factory function injection

## Best Practices

1. Declare component dependencies explicitly
2. Use interfaces for dependency contracts
3. Register components with clear names
4. Use singleton components judiciously
5. Handle initialization and shutdown properly

## Extending the System

### Custom Component Lifecycle

```javascript
class CustomComponent {
  async initialize() {
    // Custom initialization
  }

  async shutdown() {
    // Custom cleanup
  }
}
```

### Custom Component Discovery

```javascript
container.registerManifest('repository', {
  configSchema: {
    /* ... */
  },
  async discover(container) {
    // Custom discovery logic
  }
});
```

## Troubleshooting

### Common Issues

- Circular dependencies
- Incorrect component registration
- Missing dependencies during resolution

### Debugging Tips

- Use `container.on('error', ...)` to catch container errors
- Inspect the container's `components` and `dependencies` maps
- Use `container.resolve(name)` to manually resolve components

## Limitations

- No support for dynamic component replacement
- Limited support for async factory functions
- No built-in support for scoped containers

## Future Roadmap

- [ ] Async component initialization
- [ ] Scoped container support
- [ ] Dynamic component replacement
- [ ] Improved error handling and diagnostics

## Contributing

Contributions are welcome! Please follow the guidelines in CONTRIBUTING.md.

## License

[Your License Information]


// src/core/errors/Error.js

/**
 * Universal base error class for both client and server environments
 * @extends Error
 */
export class CoreError extends Error {
  /**
   * Create a new CoreError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(message);
    
    // Basic properties
    this.name = this.constructor.name;
    this.code = code;
    this.details = this.sanitizeDetails(details);
    this.timestamp = new Date().toISOString();

      //Debug line 29
      // console.log('Line 29 debug:', {
      //   hasOptions: options !== undefined,
      //   hasCause: options?.cause !== undefined,
      //   causeValue: options?.cause
      // });

    // Handle error cause
    this.initCause(options?.cause);
    
    // Ensure instanceof works correctly
    Object.setPrototypeOf(this, new.target.prototype);
    
    // Capture stack trace if available
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    // Format stack for browser environment
    if (this.isClientEnvironment()) {
      this.stack = this.formatStackTrace(this.stack);
    }
  }

  /**
   * Initialize error cause with proper error instance
   * @private
   */
  initCause(cause) {
    const ensureValidName = (error) => {
      // Reset to 'Error' if name is empty or only whitespace
      if (!error.name || !error.name.trim()) {
        error.name = 'Error';
      }
      return error;
    };
  
    if (cause instanceof Error) {
      this.cause = ensureValidName(cause);
    } else if (cause && typeof cause === 'object') {
      const error = new Error(cause.message || JSON.stringify(cause));
      if (cause.name && typeof cause.name === 'string' && cause.name.trim()) {
        error.name = cause.name;
      }
      this.cause = error;
    } else if (typeof cause === 'string') {
      this.cause = new Error(cause);
    }
  }

  /**
   * Sanitize error details for safe serialization
   * @private
   */
  sanitizeDetails(details) {
    try {
      // Test if details can be safely serialized
      JSON.stringify(details);
      return details;
    } catch (error) {
      // If serialization fails, return safe version
      return { 
        error: 'Details contained non-serializable values',
        safeDetails: String(details)
      };
    }
  }

  /**
   * Format stack trace for better readability
   * @private
   */
  formatStackTrace(stack) {
    if (!stack) return stack;
    
    return stack
      .split('\n')
      .filter(line => line.trim())
      .map(line => line.replace(/^ {4}at /, ''))
      .join('\n');
  }

  /**
   * Check if running in client environment
   * @private
   */
  isClientEnvironment() {
    return typeof window !== 'undefined';
  }

  /**
   * Check if running in development environment
   * @private
   */
  isDevEnvironment() {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';
    }
    return this.isClientEnvironment() && window.ENV === 'development';
  }

  /**
   * Convert error to JSON format
   */
  toJSON() {
    const json = {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp
    };
  
    // Only include stack if it exists AND we're in dev
    if (this.isDevEnvironment() && this.stack) {
      json.stack = this.stack;
    }
  
    // Include cause if present
    if (this.cause) {
      json.cause = {
        message: this.cause.message,
        name: this.cause.name || 'Error'
      };
      
      // Only include cause stack if it exists AND we're in dev
      if (this.isDevEnvironment() && this.cause.stack) {
        json.cause.stack = this.cause.stack;
      }
    }
  
    return json;
  }

  /**
   * Create error instance from JSON data
   * @static
   */
  static fromJSON(data) {
    const options = {};
    
    if (data.cause) {
      if (typeof data.cause === 'string') {
        options.cause = data.cause;
      } else {
        options.cause = {
          message: data.cause.message,
          name: data.cause.name
        };
      }
    }

    return new this(
      data.code,
      data.message,
      data.details || {},
      options
    );
  }
}


// src/core/errors/ErrorSystem.js

// src/core/errors/ErrorSystem.js

import { EventEmitter } from 'events';
import { CoreError } from './Error.js';
import { ErrorTypes } from './types/index.js';
import { FastifyIntegration } from './integrations/fastify/FastifyIntegration.js';

export class ErrorSystem extends EventEmitter {
  static dependencies = ['logger'];

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.logger = deps.logger || console;
    this.integrations = new Map();
    this.handlers = new Map();
    this.errorTypes = new Map(Object.entries(ErrorTypes));
    this.initialized = false;

      // Ensure a default handler is always present
  this.registerHandler('*', this.defaultErrorHandler.bind(this));
  }

  async initialize() {
    if (this.initialized) {
      throw new Error('Already initialized');
    }

    // Register default handler
    this.registerHandler('*', this.defaultErrorHandler.bind(this));
    
    // Validate error types
    for (const [name, ErrorType] of this.errorTypes) {
      if (!(ErrorType.prototype instanceof CoreError)) {
        throw new CoreError('INVALID_ERROR_TYPE', `Error type ${name} must extend CoreError`);
      }
    }

    this.initialized = true;
    this.emit('initialized');
  }

  registerIntegration(framework, options = {}) {
    if (!framework) {
      throw new CoreError('INVALID_FRAMEWORK', 'Framework is required');
    }

    const integration = new FastifyIntegration();
    integration.initialize(framework, options);
    
    this.integrations.set(framework, integration);
    return integration;
  }

  registerHandler(errorType, handler) {
    if (typeof handler !== 'function') {
      throw new CoreError('INVALID_HANDLER', 'Handler must be a function');
    }
    this.handlers.set(errorType, handler);
  }

  async handleError(error, context = {}) {
    // Ensure we always have a handler
    const handler = this.handlers.get(error.constructor.name) || this.handlers.get('*') || this.defaultErrorHandler;
  
    try {
      await handler(error, context);
      this.emit('error:handled', { error, context });
    } catch (handlerError) {
      this.logger.error('Error handler failed:', handlerError);
      this.emit('error:handler:failed', { error: handlerError, originalError: error });
      throw handlerError;
    }
  }

// Ensure defaultErrorHandler is always a function
defaultErrorHandler(error, context = {}) {
  this.logger.error('Unhandled error:', {
    type: error.constructor.name,
    code: error.code,
    message: error.message,
    details: error.details,
    context
  });
}

  createError(type, code, message, details = {}, options = {}) {
    const ErrorType = this.errorTypes.get(type) || CoreError;
    return new ErrorType(code, message, details, options);
  }

  async shutdown() {
    if (!this.initialized) return;
    
    this.handlers.clear();
    this.integrations.clear();
    this.errorTypes.clear();
    this.removeAllListeners();
    this.initialized = false;
    this.emit('shutdown');
  }
}

// Factory function for container
export function createErrorSystem(deps) {
  return new ErrorSystem(deps);
}


// src/core/errors/error-system-docs.md

# Error System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Purpose](#purpose)
3. [System Architecture](#system-architecture)
4. [Error Types](#error-types)
5. [Installation](#installation)
6. [Usage](#usage)
7. [Advanced Features](#advanced-features)
8. [Best Practices](#best-practices)
9. [Extending the System](#extending-the-system)
10. [Troubleshooting](#troubleshooting)

## Overview

The Error System is a comprehensive, extensible error handling framework designed to provide robust, consistent error management across the application.

## Purpose

The primary goals of the Error System are to:
- Standardize error representation
- Provide detailed error context
- Enable flexible error handling
- Support comprehensive error logging and tracking
- Facilitate easier debugging and system observability

## System Architecture

### Core Components

1. **CoreError** (`src/core/errors/Error.js`)
   - Base error class for all custom errors
   - Provides advanced error serialization
   - Handles error cause tracking
   - Supports environment-specific error formatting

2. **ErrorSystem** (`src/core/errors/ErrorSystem.js`)
   - Manages error types and integrations
   - Provides dynamic error handler registration
   - Implements event-driven error handling

3. **Error Types** (`src/core/errors/types/`)
   - Specialized error classes for different domains:
     * AccessError
     * AuthError
     * ConfigError
     * ModuleError
     * NetworkError
     * ServiceError
     * ValidationError

### Architecture Diagram

```mermaid
graph TD
    A[CoreError] --> B[Specialized Error Types]
    A --> C[Error Serialization]
    A --> D[Environment Handling]
    
    E[ErrorSystem] --> F[Error Handler Management]
    E --> G[Integration Registry]
    E --> H[Event Emission]
    
    B --> I[Domain-Specific Errors]
    I --> J[Access Errors]
    I --> K[Authentication Errors]
    I --> L[Configuration Errors]
```

## Error Codes

### Error Code Structure

Error codes are structured to provide clear, hierarchical categorization:

```javascript
ErrorCodes = {
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR'
  },
  // ... other error code categories
}
```

### Using Error Codes

```javascript
import { ErrorCodes, ValidationError } from '@your-org/error-system';

// Using predefined error codes
const validationError = new ValidationError(
  ErrorCodes.VALIDATION.FAILED, 
  'Validation failed',
  { details: 'Specific validation error' }
);
```

## Framework Integration

## Framework Integration

### Fastify Error Handling

The error system provides deep integration with Fastify, automatically handling various error scenarios:

```javascript
// Automatic error mapping
fastify.get('/route', async (request, reply) => {
  // Throws a 404 if route not found
  // Automatically converted to NetworkError
});

// Custom error types are preserved
throw new ValidationError('INVALID_INPUT', 'Validation failed');
```

### Error Mapping Examples

```javascript
// 404 Route Not Found
// Automatically converted to:
NetworkError {
  code: 'NETWORK_ROUTE_NOT_FOUND',
  message: 'Route GET:/test not found',
  statusCode: 404
}

// Validation Error
ValidationError {
  code: 'VALIDATION_FAILED',
  message: 'Invalid input',
  statusCode: 400,
  validationErrors: [...]
}
```

### Error Serialization

- Consistent JSON error format
- Environment-aware error details
- Preserves error context
- Supports custom error types

### Default Error Handling

```javascript
// Fallback error handler always exists
errorSystem.handleError(error, context);
```


## Error Types

### Available Error Types

1. **AccessError**
   - Used for authorization and access control issues
   - Default status code: 403 (Forbidden)

2. **AuthError**
   - Used for authentication-related errors
   - Default status code: 401 (Unauthorized)

3. **ConfigError**
   - Used for configuration and setup errors
   - Default status code: 500 (Internal Server Error)

4. **ModuleError**
   - Used for module system and initialization errors
   - Default status code: 500 (Internal Server Error)

5. **NetworkError**
   - Used for network-related errors
   - Default status code: 503 (Service Unavailable)

6. **ServiceError**
   - Used for service-level errors
   - Default status code: 503 (Service Unavailable)

7. **ValidationError**
   - Used for input validation errors
   - Default status code: 400 (Bad Request)

## Installation

```bash
npm install @your-org/error-system
```

## Usage

### Basic Error Creation

```javascript
import { 
  ValidationError, 
  ErrorCodes 
} from '@your-org/error-system';

// Create a validation error
const validationError = new ValidationError(
  ErrorCodes.VALIDATION.FAILED, 
  'Invalid user input', 
  { 
    validationErrors: [
      { field: 'email', message: 'Invalid email format' }
    ]
  }
);
```

### Error Handling with ErrorSystem

```javascript
import { ErrorSystem } from '@your-org/error-system';

// Create error system
const errorSystem = new ErrorSystem({ logger: customLogger });

// Register a custom error handler
errorSystem.registerHandler('ValidationError', (error, context) => {
  // Custom handling logic
  logger.warn(`Validation failed: ${error.message}`, {
    errors: error.validationErrors,
    context
  });
});

// Handle an error
try {
  // Some operation that might throw an error
} catch (error) {
  await errorSystem.handleError(error);
}
```

## Advanced Features

### Error Cause Tracking

```javascript
const originalError = new Error('Database connection failed');
const wrappedError = new ServiceError(
  'DB_CONNECTION', 
  'Could not connect to database', 
  {}, 
  { cause: originalError }
);
```

### JSON Serialization

```javascript
const error = new ValidationError('INVALID_INPUT', 'Validation failed');
const serializedError = error.toJSON();
// Can be sent over network, logged, etc.
```

## Best Practices

1. Always use specific error types
2. Include detailed context in error details
3. Use error codes for consistent error identification
4. Log errors with sufficient context
5. Handle errors at appropriate levels

## Extending the System

### Creating a Custom Error Type

```javascript
import { CoreError } from '@your-org/error-system';

class CustomDomainError extends CoreError {
  constructor(code, message, details = {}, options = {}) {
    super(`CUSTOM_${code}`, message, details, options);
    this.statusCode = 422; // Custom status code
  }
}
```

## Troubleshooting

### Common Issues

- **Circular Error Handling**: Avoid recursive error handling
- **Over-logging**: Be cautious about logging sensitive information
- **Error Serialization**: Ensure error details are JSON-serializable

## Future Roadmap

- [ ] Enhanced error tracking
- [ ] Distributed tracing support
- [ ] More granular error categorization
- [ ] Performance optimizations

## Contributing

Guidelines for contributing to the Error System will be added in future versions.

## License

[Your License Information]


// src/core/errors/index.js

// src/core/errors/index.js

import { CoreError } from './Error.js';
import { ErrorTypes as TypedErrors, 
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
} from './types/index.js';

// Create complete ErrorTypes including CoreError
export const ErrorTypes = {
    CoreError,
    ...TypedErrors
};

// Export individual error classes
export {
    CoreError,
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

/**
 * Standard error codes
 */
export const ErrorCodes = {
  // Core errors
  CORE: {
    UNKNOWN: 'UNKNOWN_ERROR',
    INITIALIZATION: 'INITIALIZATION_FAILED',
    VALIDATION: 'VALIDATION_FAILED'
  },

  // Module related
  MODULE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    REGISTRATION: 'REGISTRATION_FAILED',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    ROUTE: 'ROUTE_ERROR'
  },

  // Service related
  SERVICE: {
    INITIALIZATION: 'INITIALIZATION_FAILED',
    CONFIGURATION: 'CONFIGURATION_ERROR',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    RUNTIME: 'RUNTIME_ERROR'
  },

  // Configuration related
  CONFIG: {
    VALIDATION: 'VALIDATION_FAILED',
    MISSING: 'MISSING_REQUIRED',
    INVALID: 'INVALID_VALUE'
  },

  // Validation related
  VALIDATION: {
    SCHEMA: 'SCHEMA_VALIDATION_FAILED',
    TYPE: 'INVALID_TYPE',
    REQUIRED: 'REQUIRED_FIELD_MISSING',
    FAILED: 'VALIDATION_FAILED'  // Added for validation errors
  },

  // Network related
  NETWORK: {
    REQUEST: 'REQUEST_FAILED',
    RESPONSE: 'RESPONSE_ERROR',
    TIMEOUT: 'REQUEST_TIMEOUT',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND'  // Added for 404 errors
  },

  // Authentication related
  AUTH: {
    UNAUTHORIZED: 'UNAUTHORIZED',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    INVALID_TOKEN: 'INVALID_TOKEN'
  },

  // Authorization related
  ACCESS: {
    FORBIDDEN: 'FORBIDDEN',
    INSUFFICIENT_RIGHTS: 'INSUFFICIENT_RIGHTS',
    RESOURCE_ACCESS_DENIED: 'RESOURCE_ACCESS_DENIED'
  }
};

export function createErrorFromResponse(response, defaultMessage = 'Unknown error occurred') {
  const errorData = response.data || response;
  
  // Map error names to constructors from ErrorTypes
  const ErrorConstructor = ErrorTypes[errorData.name] || CoreError;

  return new ErrorConstructor(
      errorData.code || ErrorCodes.CORE.UNKNOWN,
      errorData.message || defaultMessage,
      errorData.details || {},
      { cause: response }
  );
}

export default ErrorTypes;


// src/core/errors/integrations/IFrameworkIntegration.js

// src/core/errors/integrations/IFrameworkIntegration.js

/**
 * Interface for framework error integration
 * @interface
 */
export class IFrameworkIntegration {
  /**
   * Initialize error handling for framework
   * @param {any} framework - Framework instance
   * @param {Object} options - Integration options
   */
  initialize(framework, options = {}) {
    throw new Error('initialize() must be implemented');
  }

  /**
   * Serialize error for framework response
   * @param {Error} error - Error to serialize
   * @returns {Object} Serialized error
   */
  serializeError(error) {
    throw new Error('serializeError() must be implemented');
  }

  /**
   * Map framework error to core error
   * @param {Error} frameworkError - Framework-specific error
   * @returns {CoreError} Mapped core error
   */
  mapError(frameworkError) {
    throw new Error('mapError() must be implemented');
  }
}


// src/core/errors/integrations/fastify/FastifyIntegration.js

// src/core/errors/integrations/fastify/FastifyIntegration.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

export class FastifyIntegration extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  async initialize(fastify, options = {}) {
    if (this.initialized) {
      return;
    }

    // Add error context to request
    fastify.addHook('onRequest', async (request) => {
      if (!request) {
        return;
      }
      
      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    // Set error handler
    fastify.setErrorHandler(async (error, request, reply) => {
      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
  }

  mapError(error) {
    // Already our custom error
    if (error instanceof CoreError) {
      return error;
    }

    // Fastify validation errors
    // TODO: Need a network error
    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    // Route not found
    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    // Generic error
    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}


// src/core/errors/integrations/fastify/handler.js

// src/core/errors/integrations/fastify/handler.js

import { IFrameworkIntegration } from '../IFrameworkIntegration.js';
import { CoreError, ErrorCodes } from '../../index.js';
import { ValidationError, NetworkError } from '../../types/index.js';

class FastifyErrorHandler extends IFrameworkIntegration {
  constructor() {
    super();
    this.initialized = false;
  }

  initialize(fastify, options = {}) {
    if (this.initialized) {
      return this;
    }

    if (!fastify || typeof fastify.addHook !== 'function') {
      throw new Error('Invalid fastify instance');
    }

    fastify.addHook('onRequest', async (request) => {
      if (!request) return;

      request.errorContext = {
        url: request?.url || '',
        method: request?.method || '',
        id: request?.id
      };
    });

    fastify.setErrorHandler(async (error, request, reply) => {
      if (!reply || typeof reply.status !== 'function') {
        throw new Error('Invalid reply object');
      }

      const errorContext = {
        requestId: request?.id,
        timestamp: new Date().toISOString(),
        url: request?.url || '',
        method: request?.method || ''
      };

      const mappedError = this.mapError(error);
      const serializedError = this.serializeError(mappedError, errorContext);

      reply.status(mappedError.statusCode || 500);
      return reply.send(serializedError);
    });

    this.initialized = true;
    return this;
  }

  mapError(error) {
    if (error instanceof CoreError) {
      return error;
    }

    if (error?.validation) {
      const validationError = new ValidationError(
        'FAILED',
        'Request validation failed',
        {
          validationErrors: error.validation
        }
      );
      validationError.statusCode = error.statusCode || 400;
      return validationError;
    }

    if (error?.statusCode === 404) {
      const notFoundError = new NetworkError(
        'ROUTE_NOT_FOUND',
        `Route ${error.method || ''}:${error.url || ''} not found`
      );
      notFoundError.statusCode = 404;
      return notFoundError;
    }

    const genericError = new CoreError(
      ErrorCodes.CORE.UNKNOWN,
      error?.message || 'An unexpected error occurred',
      {
        originalError: process.env.NODE_ENV === 'development' ? error : undefined
      }
    );

    genericError.statusCode = error?.statusCode || 500;
    return genericError;
  }

  serializeError(error, context = {}) {
    const safeContext = context || {};

    if (error instanceof CoreError) {
      const serialized = error.toJSON();
      return {
        ...serialized,
        context: safeContext
      };
    }

    return {
      code: ErrorCodes.CORE.UNKNOWN,
      message: error?.message || 'Unknown error occurred',
      timestamp: new Date().toISOString(),
      context: safeContext
    };
  }
}

// Create singleton instance
const fastifyErrorHandler = new FastifyErrorHandler();

export function setupErrorHandler(fastify, options = {}) {
  return fastifyErrorHandler.initialize(fastify, options);
}

export { fastifyErrorHandler, FastifyErrorHandler };


// src/core/errors/integrations/fastify/index.js

export { setupErrorHandler } from './handler.js';
export { errorSerializer } from './serializer.js';


// src/core/errors/integrations/fastify/serializer.js

import { fastifyErrorHandler } from './handler.js';

export const errorSerializer = {
  serializer: (error) => fastifyErrorHandler.serializeError(error)
};


// src/core/errors/types/AccessError.js

import { CoreError } from '../Error.js';

/**
 * Authorization and access control related errors
 * @extends CoreError
 */
export class AccessError extends CoreError {
  /**
   * Create a new AccessError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`ACCESS_${code}`, message, details, options);
    this.statusCode = 403;
  }
}


// src/core/errors/types/AuthError.js

import { CoreError } from '../Error.js';

/**
 * Authentication related errors
 * @extends CoreError
 */
export class AuthError extends CoreError {
  /**
   * Create a new AuthError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`AUTH_${code}`, message, details, options);
    this.statusCode = 401;
  }
}


// src/core/errors/types/ConfigError.js

import { CoreError } from '../Error.js';

/**
 * Configuration related errors
 * @extends CoreError
 */
export class ConfigError extends CoreError {
  /**
   * Create a new ConfigError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`CONFIG_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/ModuleError.js

import { CoreError } from '../Error.js';

/**
 * Module system related errors
 * @extends CoreError
 */
export class ModuleError extends CoreError {
  /**
   * Create a new ModuleError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`MODULE_${code}`, message, details, options);
    this.statusCode = 500;
  }
}


// src/core/errors/types/NetworkError.js

import { CoreError } from '../Error.js';

/**
 * Network related errors
 * @extends CoreError
 */
export class NetworkError extends CoreError {
  /**
   * Create a new NetworkError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`NETWORK_${code}`, message, details, options);
    // Use provided status code or default to 503
    this.statusCode = details.statusCode || 503;
  }
}


// src/core/errors/types/ServiceError.js

import { CoreError } from '../Error.js';

/**
 * Service related errors
 * @extends CoreError
 */
export class ServiceError extends CoreError {
  /**
   * Create a new ServiceError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`SERVICE_${code}`, message, details, options);
    this.statusCode = 503;
  }
}


// src/core/errors/types/ValidationError.js

import { CoreError } from '../Error.js';

/**
 * Validation related errors
 * @extends CoreError
 */
export class ValidationError extends CoreError {
  /**
   * Create a new ValidationError
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {Object} [details={}] - Additional error details with validation errors
   * @param {Object} [options={}] - Error options
   */
  constructor(code, message, details = {}, options = {}) {
    super(`VALIDATION_${code}`, message, details, options);
    this.statusCode = 400;
    this.validationErrors = this.validationErrors = Array.isArray(details.validationErrors) ? details.validationErrors : [];
  }

  /**
   * Convert to JSON format with validation errors
   */
  toJSON() {
    const json = super.toJSON();
    json.validationErrors = this.validationErrors;
    return json;
  }

  /**
   * Create from JSON with validation errors
   * @param {Object} data - JSON data
   */
  static fromJSON(data) {
    const error = super.fromJSON(data);
    error.validationErrors = Array.isArray(data.validationErrors) ? data.validationErrors : [];
    return error;
  }
}


// src/core/errors/types/index.js

// src/core/errors/types/index.js

import { AccessError } from './AccessError.js';
import { AuthError } from './AuthError.js';
import { ConfigError } from './ConfigError.js';
import { ModuleError } from './ModuleError.js';
import { NetworkError } from './NetworkError.js';
import { ServiceError } from './ServiceError.js';
import { ValidationError } from './ValidationError.js';

// Export individual error types
export {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Create the ErrorTypes namespace
const ErrorTypes = {
    AccessError,
    AuthError,
    ConfigError,
    ModuleError,
    NetworkError,
    ServiceError,
    ValidationError
};

// Export ErrorTypes as both named and default export
export { ErrorTypes };
export default ErrorTypes;


// src/core/module/Module.js

// src/core/module/Module.js

import { EventEmitter } from 'events';
import { ModuleError } from '../errors/index.js';

export class CoreModule extends EventEmitter {
  static dependencies = ['errorSystem', 'eventBus', 'config'];
  static version = '1.0.0';

  constructor(deps = {}) {
    super();
    this.deps = deps;
    this.initialized = false;
    this.config = null;
    this.state = {
      status: 'created',
      startTime: null,
      errors: [],
      metrics: new Map()
    };

    // Validate required dependencies
    this.validateDependencies();
  }

  validateDependencies() {
    const missing = this.constructor.dependencies.filter(
      dep => !this.deps[dep]
    );

    if (missing.length > 0) {
      throw new ModuleError(
        'MISSING_DEPENDENCIES',
        `Missing required dependencies: ${missing.join(', ')}`
      );
    }
  }

  async initialize() {
    if (this.initialized) {
      throw new ModuleError(
        'ALREADY_INITIALIZED',
        'Module is already initialized'
      );
    }

    try {
      this.state.startTime = Date.now();
      this.state.status = 'initializing';

      // Added more explicit initialization steps
      await this.onConfigure();
      await this.setupEventHandlers();
      await this.onInitialize();
      
      this.initialized = true;
      this.state.status = 'running';

      return this;

    } catch (error) {
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message
      });

      throw new ModuleError(
        'INITIALIZATION_FAILED',
        'Failed to initialize module',
        { originalError: error }
      );
    }
  }

  async onConfigure() {
    // Cover lines 62-68: Explicit configuration handling
    if (this.config === null || this.config === undefined) {
      // Ensure config is always an object
      this.config = {};
    }

    // Optional additional configuration logic
    if (Object.keys(this.config).length === 0) {
      // Default configuration if empty
      this.config.default = true;
    }

    return Promise.resolve();
  }

  async setupEventHandlers() {
    // Default event handler setup
    // Can be overridden or extended by child classes
    return Promise.resolve();
  }

  async onInitialize() {
    // Default initialization logic
    // Can be overridden by child classes
    return Promise.resolve();
  }

  async handleError(error, context = {}) {
    // Ensure context is an object
    const safeContext = context || {};

    // Add error to state
    this.state.errors.push({
      timestamp: new Date().toISOString(),
      error: error.message,
      context: safeContext
    });

    // Trim error history if needed
    if (this.state.errors.length > 100) {
      this.state.errors.shift();
    }

    // Forward to error system with enhanced error handling
    if (this.deps.errorSystem) {
      try {
        await this.deps.errorSystem.handleError(error, {
          module: this.constructor.name,
          ...safeContext
        });
      } catch (handlerError) {
        // Log error handling failure
        console.error('Error in error handling:', handlerError);
      }
    }

    return this;
  }

  async emit(eventName, ...args) {
    // Emit through local EventEmitter
    const localEmitResult = super.emit(eventName, ...args);

    // Broadcast through eventBus
    if (this.deps.eventBus && typeof this.deps.eventBus.emit === 'function') {
      await this.deps.eventBus.emit(eventName, ...args);
    }

    return localEmitResult;
  }

  async shutdown() {
    try {
      // Cover line 188: Explicit shutdown handling
      if (!this.initialized) {
        // Early return if not initialized
        return this;
      }

      this.state.status = 'shutting_down';
      
      // Ensure onShutdown is called
      await this.onShutdown();
      
      // Reset state
      this.initialized = false;
      this.state.status = 'shutdown';
      this.state.startTime = null;
      
      return this;
    } catch (error) {
      // Enhanced error handling
      this.state.status = 'error';
      this.state.errors.push({
        timestamp: new Date().toISOString(),
        error: error.message,
        context: { phase: 'shutdown' }
      });

      throw new ModuleError(
        'SHUTDOWN_FAILED',
        'Failed to shutdown module',
        { originalError: error }
      );
    }
  }

  async onShutdown() {
    // Default shutdown logic
    // Can be overridden by child classes
    return Promise.resolve();
  }

  async getHealth() {
    try {
      // Cover line 119: Explicit metrics handling
      const metricsData = this.state.metrics instanceof Map 
        ? Object.fromEntries(this.state.metrics) 
        : {};

      return {
        name: this.constructor.name,
        version: this.constructor.version,
        status: this.state.status,
        uptime: this.state.startTime ? Date.now() - this.state.startTime : 0,
        initialized: this.initialized,
        errorCount: this.state.errors.length,
        lastError: this.state.errors[this.state.errors.length - 1],
        metrics: metricsData
      };
    } catch (error) {
      // Fallback error handling
      return {
        name: this.constructor.name,
        status: 'error',
        error: error.message,
        timestamp: new Date().toISOString(),
        metrics: {}
      };
    }
  }


  // Optional metric recording method
  recordMetric(name, value) {
    this.state.metrics.set(name, {
      value,
      timestamp: Date.now()
    });
  }
}

export function createModule(deps = {}) {
    // Provide default dependencies if not supplied
    const defaultDeps = {
      errorSystem: {
        handleError: async () => {} // No-op error handler
      },
      eventBus: new EventEmitter(), // Default event emitter
      config: {} // Empty configuration object
    };
  
    // Merge provided deps with defaults, giving priority to provided deps
    const mergedDeps = {
      ...defaultDeps,
      ...deps
    };
  
    return new CoreModule(mergedDeps);
  }
  export default {
    CoreModule,
    createModule
  };


// src/core/module/module-system-docs-updated.md

# Module System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Core Concepts](#core-concepts)
3. [System Architecture](#system-architecture)
4. [Core Systems](#core-systems)
5. [Service Systems](#service-systems)
6. [Business Modules](#business-modules)
7. [Integration Patterns](#integration-patterns)
8. [Lifecycle Management](#lifecycle-management)
9. [Error Handling](#error-handling)
10. [Event System](#event-system)
11. [Testing Strategy](#testing-strategy)
12. [Best Practices](#best-practices)
13. [Troubleshooting](#troubleshooting)

## Overview

The TSMIS architecture is built on three main layers:
1. Core Systems - Fundamental infrastructure 
2. Service Systems - Common service functionality
3. Business Modules - Business domain logic

## Core Concepts

### Architectural Principles
- Clear separation of concerns
- Infrastructure/business logic separation
- Domain-driven design
- Event-driven communication
- Dependency injection

### Key Features
- Containerized core systems
- Service encapsulation
- Business domain isolation
- Cross-cutting concerns management
- Health monitoring

## System Architecture

```mermaid
graph TB
    %% Core Container Level
    CC[CoreContainer] --> ES[ErrorSystem]
    CC --> MS[ModuleSystem]
    CC --> EB[EventBus]
    CC --> CFG[ConfigSystem]

    %% ModuleSystem managing business modules
    MS --> HR[HR Module]
    MS --> SALES[Sales Module]
    MS --> WIKI[Wiki Module]
    MS --> INV[Inventory Module]

    %% Core module dependencies
    HR --> ES
    HR --> EB
    HR --> CFG

    SALES --> ES
    SALES --> EB
    SALES --> CFG

    WIKI --> ES
    WIKI --> EB
    WIKI --> CFG

    INV --> ES
    INV --> EB
    INV --> CFG

    %% Service systems would be registered with container
    CC --> DBS[DatabaseSystem]
    CC --> AS[AuthSystem]
    CC --> FS[FileSystem]

    %% Service system dependencies would be injected into modules that need them
    HR -.-> DBS
    HR -.-> AS
    HR -.-> FS

    SALES -.-> DBS
    SALES -.-> AS

    %% Event communication
    EB -.-> HR
    EB -.-> SALES
    EB -.-> WIKI
    EB -.-> INV
```

### Detailed Service Integration

```mermaid
graph TB
    subgraph BusinessModule[Business Module]
        BM[HR Module]
        BL[Business Logic]
    end
    
    subgraph ServiceSystems[Service Systems]
        DBS[DatabaseSystem]
        AS[AuthSystem]
        FS[FileSystem]
        EMS[EmailSystem]
    end

    BM --> BL
    BL --> DBS
    BL --> AS
    BL --> FS
    BL --> EMS

    subgraph CrossCutting[Cross-cutting]
        ES[ErrorSystem]
        EB[EventBus]
    end

    ES -.-> BM
    EB -.-> BM
```

## Core Systems

### ModuleSystem
```javascript
// Module registration
await moduleSystem.register('hrModule', HRModule, {
  config: moduleConfig
});

// Module discovery
await moduleSystem.discover('./modules');
```

### ErrorSystem
```javascript
// Error handling in modules
try {
  await this.processEmployee(data);
} catch (error) {
  await this.deps.errorSystem.handleError(error, {
    module: 'hrModule',
    operation: 'processEmployee',
    data
  });
}
```

### EventBus
```javascript
// Event broadcasting
await this.deps.eventBus.emit('employee:created', {
  id: employee.id,
  department: employee.department
});
```

## Service Systems

### DatabaseSystem
```javascript
class DatabaseSystem {
  async query(sql, params) {
    // Database operations
  }
  
  async transaction(callback) {
    // Transaction handling
  }
}
```

### AuthSystem
```javascript
class AuthSystem {
  async authenticate(credentials) {
    // Authentication logic
  }
  
  async authorize(user, resource, action) {
    // Authorization logic
  }
}
```

### FileSystem
```javascript
class FileSystem {
  async store(path, content, metadata) {
    // File operations
  }
  
  async retrieve(path) {
    // File retrieval
  }
}
```

## Business Modules

### Business Module File Structure

A typical business module follows this file structure:

```
modules/accounting/
├── index.js         # Module definition & setup
├── config.js        # Module config
├── errors/          # Module specific errors
├── services/        # Business logic 
├── routes/          # API routes
├── plugins/         # Special tools or features to the specific module
└── schemas/         # Validation schemas
```

- `index.js`: Contains the module class definition and setup code.
- `config.js`: Holds the module-specific configuration.
- `errors/`: Contains module-specific error classes.
- `services/`: Encapsulates the business logic and interactions with other services.
- `routes/`: Defines the API routes handled by the module.
- `plugins/`: Contains special tools or features specific to the module.
- `schemas/`: Holds validation schemas for the module's data.

### Module Implementation
```javascript
class HRModule extends CoreModule {
  static dependencies = ['database', 'auth', 'file', 'email'];

  async processEmployee(data) {
    // Use service systems through dependencies
    await this.deps.database.transaction(async (tx) => {
      await this.deps.auth.authorize('employee.create');
      const employee = await tx.createEmployee(data);
      await this.deps.file.store(`employees/${employee.id}`, data.documents);
      await this.deps.email.send('welcome', employee.email);
    });
  }
}
```

### Module Configuration
```javascript
{
  "modules": {
    "hrModule": {
      "enabled": true,
      "config": {
        "employeeDefaults": {
          "department": "unassigned",
          "status": "pending"
        },
        "documentTypes": ["id", "contract", "certificates"]
      }
    }
  }
}
```

## Integration Patterns

### Service Integration
```javascript
class SalesModule extends CoreModule {
  async createOrder(orderData) {
    // Database integration
    const order = await this.deps.database.query(
      'INSERT INTO orders...'
    );

    // File storage integration
    await this.deps.file.store(
      `orders/${order.id}`, 
      orderData.documents
    );

    // Email integration
    await this.deps.email.send(
      'order-confirmation',
      order.customerEmail
    );

    // Event emission
    await this.deps.eventBus.emit('order:created', order);
  }
}
```

### Cross-module Communication
```javascript
// Inventory module listening to Sales events
class InventoryModule extends CoreModule {
  getEventHandlers() {
    return {
      'order:created': this.updateStock.bind(this)
    };
  }

  async updateStock(orderEvent) {
    await this.deps.database.transaction(async (tx) => {
      // Update inventory
    });
  }
}
```

## Lifecycle Management

### Module Lifecycle
```javascript
class WikiModule extends CoreModule {
  async initialize() {
    // Setup database tables
    await this.deps.database.query(`
      CREATE TABLE IF NOT EXISTS wiki_pages...
    `);

    // Initialize search index
    await this.initializeSearch();
  }

  async shutdown() {
    // Cleanup resources
    await this.cleanupTempFiles();
  }
}
```

## Testing Strategy

### Unit Testing
```javascript
describe('HR Module', () => {
  let hrModule;
  let mockDeps;

  beforeEach(() => {
    mockDeps = {
      database: createMockDatabase(),
      auth: createMockAuth(),
      file: createMockFileSystem(),
      email: createMockEmailSystem()
    };
    hrModule = new HRModule(mockDeps);
  });

  test('should process employee', async () => {
    await hrModule.processEmployee(employeeData);
    expect(mockDeps.database.query).toHaveBeenCalled();
  });
});
```

### Integration Testing
```javascript
describe('Module Integration', () => {
  let container;

  beforeAll(async () => {
    container = new CoreContainer();
    
    // Register systems
    container.register('database', createDatabaseSystem);
    container.register('moduleSystem', createModuleSystem);
    
    await container.initialize();
  });

  test('should handle complete business flow', async () => {
    const hrModule = await container.resolve('hrModule');
    await hrModule.processEmployee(testData);
    // Verify results
  });
});
```

## Best Practices

### 1. Module Implementation
- Focus on business logic
- Use service systems for infrastructure
- Handle errors appropriately
- Emit relevant events
- Implement health checks

### 2. Service Usage
- Access through dependencies
- Use transactions where needed
- Handle service errors
- Monitor service health

### 3. Testing
- Mock service dependencies
- Test business logic
- Verify service integration
- Test error scenarios
- Check event handling

## Troubleshooting

### Common Issues
1. Service Dependencies
   - Check service availability
   - Verify service configuration
   - Monitor service health

2. Business Logic
   - Debug module initialization
   - Check business rules
   - Verify data flow

3. Integration Issues
   - Check service connectivity
   - Verify event flow
   - Debug cross-module communication


// server.js

import 'dotenv/config';

const { NODE_ENV = "development", PORT = 3000 } = process.env;
console.time("Start");

let address;

async function startServer() {
  if (NODE_ENV === "production") {
    const { buildApp } = await import("./dist/app.js");
    const app = await buildApp();
    address = await app.listen({ port: '3001', host: '0.0.0.0' });
  } else {
    const { once } = await import("events");
    const { createServer } = await import("vite");
    let appInstance;  // Store the built app instance

    const devServer = await createServer({
      appType: "custom",
      server: { middlewareMode: true },
    });

    const server = devServer.middlewares
      .use(async (req, res, next) => {
        try {
          if (!appInstance) {
            console.log('Building app for the first time.');
            const { buildApp } = await devServer.ssrLoadModule("./src/app.js");
            appInstance = await buildApp();
            await appInstance.ready();
          }

          console.log('Routing request:', req.url);
          appInstance.routing(req, res);
        } catch (err) {
          console.error('Error during request handling:', err);
          return next(err);
        }
      })
      .listen(PORT);

    await once(server, "listening");
    address = `http://localhost:${server.address().port}`;

    // Listen for file changes to trigger a rebuild
    devServer.watcher.on('change', (file) => {
      console.log(`File changed: ${file}. Rebuilding app...`);
      appInstance = null;  // This will trigger a rebuild on the next request
      console.log(`App rebuilt`);
    });
  }

  console.timeEnd("Start");
  console.log(`Env: ${NODE_ENV}`);
  console.log(`Address: ${address}`);
}

startServer().catch((err) => {
  console.error('Failed to start server:', err);
  process.exit(1);
});


// vite.config.js

import { defineConfig } from "vite";
import marko from "@marko/vite";
//import { resolve } from "path";

export default defineConfig({
  //root: resolve(__dirname, "src"),
  plugins: [marko()],
  build: {
    sourcemap: true, // Generate sourcemaps for all builds.
    emptyOutDir: false, // Avoid server & client deleting files from each other.
    outDir: "./dist",
  },
});


// .env

NODE_ENV="development"
PORT="3000"

DATABASE_URL='postgres://postgres:Magarao12@localhost:5432/tsmis_dev'
JWT_SECRET="hgtrh3rthhymn^^7(@jytj00*hh765y"

IPREGISTRY_API_KEY="zo2l5bcj3o5hp0"


MAIL_HOST="smtp.gmail.com"
MAIL_PORT="465"
MAIL_SECURE="true"
MAIL_USER="torosminfo@gmail.com"
MAIL_PASS="oaor cyav zijk nlqn"

HARDCODE_MODULES=false


// package.json

{
    "name": "tsmis",
    "type": "module",
    "description": "toro_sm information system",
    "version": "1.0.0",
    "dependencies": {
        "@fastify/compress": "^7.0.3",
        "@fastify/cookie": "^9.3.1",
        "@fastify/csrf-protection": "^6.4.1",
        "@fastify/formbody": "^7.4.0",
        "@fastify/helmet": "^11.1.1",
        "@fastify/jwt": "^8.0.1",
        "@fastify/postgres": "^5.2.2",
        "@fastify/rate-limit": "^9.1.0",
        "@fastify/static": "^7.0.4",
        "@ipregistry/client": "^6.0.0",
        "@marko/fastify": "^1.1.1",
        "@popperjs/core": "^2.11.8",
        "bcrypt": "^5.1.1",
        "bootstrap": "^5.3.3",
        "dotenv": "^16.4.5",
        "fastify": "^4.28.1",
        "marked": "^14.1.2",
        "marko": "^5.35.8",
        "nodemailer": "^6.9.15"
    },
    "devDependencies": {
        "@babel/core": "^7.26.7",
        "@babel/preset-env": "^7.26.7",
        "@marko/compiler": "^5.37.4",
        "@marko/vite": "^5.0.13",
        "babel-jest": "^29.7.0",
        "cross-env": "^7.0.3",
        "directory-tree-ascii": "^1.0.10",
        "jest": "^29.7.0",
        "postcss-preset-env": "^10.0.6",
        "rimraf": "^6.0.1",
        "sass": "^1.77.4",
        "vite": "^6.0.11"
    },
    "scripts": {
        "build": "rimraf dist && npm run build:server && npm run build:client",
        "build:client": "cross-env NODE_ENV=production vite build",
        "build:server": "cross-env NODE_ENV=production vite build --ssr src/app.js",
        "dev": "node --enable-source-maps server.js",
        "dev:inspect": "node --inspect --enable-source-maps server.js",
        "start": "cross-env NODE_ENV=production node --enable-source-maps server.js",
        "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
        "test:watch": "node --experimental-vm-modules node_modules/jest/bin/jest.js --watch",
        "test:coverage": "node --experimental-vm-modules node_modules/jest/bin/jest.js --coverage"
    }
}

